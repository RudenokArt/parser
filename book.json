[{"url":"/ru/php/book/oop/intro/","content":"\n\t\t\t\t<h1>Введение в классы и объекты в PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами займемся изучением ООП в\n\tPHP. Давайте рассмотрим пример из жизни,\n\tа потом перенесем его на PHP.\n</p>\n<p>\n\tВ качестве примера возьмем автомобиль. У\n\tнего есть колеса, цвет, вид кузова, объем\n\tдвигателя и так далее. Кроме того, водитель\n\tможет отдавать ему команды: ехать, остановится,\n\tповернуть направо, налево и тп.\n</p>\n<p>\n\tМожно говорить о том, что существует некоторый\n\t<dfn>класс</dfn> автомобилей, обладающий общими\n\tсвойствами (у всех есть колеса и всем им\n\tможно отдавать команды).\n</p>\n<p>\n\tКонкретный автомобиль, стоящий на улице -\n\tэто представитель этого класса, или, другими\n\tсловами, <dfn>объект</dfn> этого класса. У всех\n\tобъектов этого класса есть <dfn>свойства</dfn>:\n\tколичество колес, цвет, вид кузова и <dfn>методы</dfn>:\n\tехать, остановится, повернуть направо, налево.\n</p>\n<p>\n\tДругими словами сам класс - это чертеж, по\n\tкоторым на заводе делаются автомобили. Объект\n\tже - это сама машина, сделанная по этим чертежам.\n</p>\n<p>\n\tВ PHP класс создается с помощью ключевого\n\tслова <code class=\"code inline\">class</code>, за которым следует название\n\tэтого класса. Давайте сделаем класс <code class=\"code inline\">Car</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Car\n\t{\n\t\t// тут код, то есть PHP-чертеж автомобиля\n\t}\n?&gt;</code>\n</div>\n<p>\n\tУкажем теперь в нашем чертеже, что любой\n\tавтомобиль, созданный по этому чертежу, будет\n\tиметь свойство для цвета и свойство для количества\n\tтоплива.\n</p>\n<p>\n\tДля этого внутри класса напишем свойство\n\t<code class=\"code inline\">$color</code> и свойство <code class=\"code inline\">$fuel</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Car\n\t{\n\t\t// Зададим свойства (по сути переменные класса):\n\t\tpublic $color; // цвет автомобиля\n\t\tpublic $fuel; // количество топлива\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь сделаем методы нашего класса.\n\tВ PHP методы, подобно обычным функциям, объявляются\n\tс помощью ключевого слова <code class=\"code inline\">function</code>,\n\tперед которым пишется ключевое слово <code class=\"code inline\">public</code>.\n</p>\n<p>\n\tКак уже упоминалось выше, наш автомобиль\n\tможет ехать, может поворачивать, может останавливаться.\n\tСделаем соответствующие методы в нашем классе:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Car\n\t{\n\t\tpublic $color; // цвет автомобиля\n\t\tpublic $fuel; // количество топлива\n\t\t\n\t\t// Команда ехать:\n\t\tpublic function go()\n\t\t{\n\t\t\t// какой-то PHP код\n\t\t}\n\t\t\n\t\t// Команда поворачивать:\n\t\tpublic function turn()\n\t\t{\n\t\t\t// какой-то PHP код\n\t\t}\n\t\t\n\t\t// Команда остановиться:\n\t\tpublic function stop()\n\t\t{\n\t\t\t// какой-то PHP код\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tМы с вами сделали чертеж нашего автомобиля.\n\tТеперь нужно отправится на завод и сделать\n\tобъект этого класса (то есть конкретный автомобиль).\n</p>\n<p>\n\tВ PHP это делается с помощью ключевого слова\n\t<code class=\"code inline\">new</code>, после которого пишется имя класса:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnew Car; // командуем заводу сделать автомобиль\n?&gt;</code>\n</div>\n<p>\n\tОднако, если просто создать объект класса\n\t- это ни к чему не приведет (это все равно,\n\tчто, к примеру, объявить массив и никуда\n\tего не записать). Нам нужна переменная для\n\tхранения этого объекта.\n</p>\n<p>\n\tПусть эта переменная будет называться <code class=\"code inline\">$myCar</code>\n\t- запишем в нее созданный нами объект:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$myCar = new Car; // запишем созданный объект в переменную $myCar\n?&gt;</code>\n</div>\n<p>\n\tПосле создания автомобиля можно обращаться\n\tк его свойствам. Обращение к ним происходит\n\tчерез стрелочку <code class=\"code inline\">-></code>. Давайте установим\n\tсвойства нашего объекта:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$myCar = new Car; // командуем заводу сделать автомобиль\n\t\n\t// Устанавливаем свойства объекта:\n\t$myCar-&gt;color = 'red'; // красим в красный цвет\n\t$myCar-&gt;fuel = 50; // заливаем топливо\n?&gt;</code>\n</div>\n<p>\n\tВсе, наш автомобиль создан, покрашен и заправлен.\n\tТеперь мы можем отдавать ему команды через\n\tметоды этого автомобиля.\n</p>\n<p>\n\tОбращение к методам также происходит через\n\tстрелочку, но, в отличие от свойства, после\n\tимени метода следует писать круглые скобки.\n\tДавайте покомандуем нашим объектом:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$myCar-&gt;go();   // автомодиль-&gt;едь\n\t$myCar-&gt;turn(); // автомодиль-&gt;поверни\n\t$myCar-&gt;stop(); // автомодиль-&gt;остановись\n?&gt;</code>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/properties/","content":"\n\t\t\t\t<h1>Работа со свойствами объектов на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами научимся работать с объектами\n\tи их свойствами на более практическом примере.\n\tДавайте сделаем класс <code class=\"code inline\">User</code>, который\n\tбудет описывать юзера нашего сайта. Пусть\n\tу нашего пользователя будет два свойства:\n\tимя и возраст. Напишем код нашего класса:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name; // свойство для имени\n\t\tpublic $age; // свойство для возраста\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПока наш класс ничего не делает - он просто\n\tописывает, что будут иметь объекты этого\n\tкласса (в нашем случае каждый объект будет\n\tиметь имя и возраст). По сути, пока мы не\n\tсоздадим хотя бы один объект нашего класса\n\t- ничего полезного не произойдет.\n</p>\n<p>\n\tДавайте создадим объект нашего класса. При\n\tэтом нужно иметь ввиду, что классы принято\n\tназывать большими буквами, а объекты этих\n\tклассов - маленькими:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Объявляем класс:\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t}\n\t\n\t// Создаем объект нашего класса:\n\t$user = new User;\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь что-нибудь запишем в свойства\n\tнашего объекта, а потом выведем эти данные\n\tна экран:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t}\n\t\n\t$user = new User; // создаем объект нашего класса\n\t$user-&gt;name = 'john'; // записываем имя в свойство name\n\t$user-&gt;age = 25; // записываем возраст в свойство age\n\t\n\techo $user-&gt;name; // выводим записанное имя\n\techo $user-&gt;age; // выводим записанный возраст\n?&gt;</code>\n</div>\n<p>\n\tКак вы уже поняли - в свойства объекта можно\n\tчто-то записывать и из свойств можно выводить\n\tих содержимое. Давайте теперь сделаем <code class=\"number inline\">2</code>\n\tобъекта-юзера: <code class=\"string inline\">'john'</code> и <code class=\"string inline\">'eric'</code>,\n\tзаполним их данными и выведем на экран сумму\n\tих возрастов:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t}\n\t\n\t// Первый объект\n\t$user1 = new User; // создаем первый объект\n\t$user1-&gt;name = 'john'; // записываем имя\n\t$user1-&gt;age = 25; // записываем возраст\n\t\n\t// Второй объект\n\t$user2 = new User; // создаем второй объект\n\t$user2-&gt;name = 'eric'; // записываем имя\n\t$user2-&gt;age = 30; // записываем возраст\n\t\n\t// Найдем сумму возрастов:\n\techo $user1-&gt;age + $user2-&gt;age; // выведет 55\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code> (работник),\n\t\tв котором будут следующие свойства - <code class=\"code inline\">name</code>\n\t\t(имя), <code class=\"code inline\">age</code> (возраст), <code class=\"code inline\">salary</code>\n\t\t(зарплата).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте объект класса <code class=\"code inline\">Employee</code>, затем\n\t\tустановите его свойства в следующие значения\n\t\t- имя <code class=\"string inline\">'john'</code>, возраст <code class=\"number inline\">25</code>, зарплата\n\t\t<code class=\"number inline\">1000</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте второй объект класса <code class=\"code inline\">Employee</code>,\n\t\tустановите его свойства в следующие значения\n\t\t- имя <code class=\"string inline\">'eric'</code>, возраст <code class=\"number inline\">26</code>, зарплата\n\t\t<code class=\"number inline\">2000</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыведите на экран сумму зарплат созданных юзеров.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыведите на экран сумму возрастов созданных юзеров.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/methods/","content":"\n\t\t\t\t<h1>Работа с методами объектов</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПерейдем теперь к методам. <dfn>Методы</dfn>\n\t- это по сути функции которые может вызывать\n\tкаждый объект. При написании кода разница\n\tмежду методами и свойствами в том, что для\n\tметодов надо писать круглые скобки в конце,\n\tа для свойств - не надо.\n</p>\n<p>\n\tДавайте потренируемся - сделаем метод <code class=\"code inline\">show()</code>,\n\tкоторый будет выводить некоторый текст:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Создаем метод:\n\t\tpublic function show()\n\t\t{\n\t\t\treturn '!!!';\n\t\t}\n\t}\n\t\n\t$user = new User;\n\t$user-&gt;name = 'john';\n\t$user-&gt;age = 25;\n\t\n\t// Вызовем наш метод:\n\techo $user-&gt;show(); // выведет '!!!'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код реализуйте такой\n\t\tже класс <code class=\"code inline\">User</code> с методом <code class=\"code inline\">show()</code>.\n\t</p>\n</div>\n\n<h2>Параметры метода</h2>\n<p>\n\tТак как метод - это по сути обычная функция,\n\tон может принимать параметры так же, как\n\tи все функции. Давайте сделаем так, чтобы\n\tнаш метод <code class=\"code inline\">show()</code> параметром принимал\n\tкакую-нибудь строку и добавлял ей в конец\n\t<code class=\"string inline\">'!!!'</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Создаем метод:\n\t\tpublic function show($str)\n\t\t{\n\t\t\treturn $str . '!!!';\n\t\t}\n\t}\n\t\n\t$user = new User;\n\t$user-&gt;name = 'john';\n\t$user-&gt;age = 25;\n\t\n\t// Вызовем наш метод:\n\techo $user-&gt;show('hello'); // выведет 'hello!!!'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код реализуйте такой\n\t\tже класс <code class=\"code inline\">User</code> с методом <code class=\"code inline\">show()</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/properties-and-this/","content":"\n\t\t\t\t<h1>Обращение к свойствам класса через $this</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть теперь наш метод <code class=\"code inline\">show()</code> выводит\n\tнечто полезное - имя пользователя, которое\n\tхранится в свойстве <code class=\"code inline\">name</code>. Для того,\n\tчтобы обратиться к свойству класса внутри\n\tметода этого класса, вместо имени объекта\n\tследует писать специальную переменную <code class=\"code inline\">$this</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\tpublic function show()\n\t\t{\n\t\t\treturn $this-&gt;name; // вернем имя из свойства\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПочему внутри класса нельзя написать так\n\t- <code class=\"code inline\">$user->name</code>? Потому что это имя\n\tпеременной <i>снаружи класса</i> и сам класс\n\tпро это имя ничего не знает (более того,\n\tу нас же могут быть несколько объектов одного\n\tкласса, и у них будут разные имена переменных).\n</p>\n<p>\n\tДавайте создадим объект нашего класса и проверим\n\tработу метода <code class=\"code inline\">show()</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\tpublic function show()\n\t\t{\n\t\t\t// Возвращаем имя:\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t}\n\t\n\t$user = new User; // создаем объект класса\n\t$user-&gt;name = 'john'; // записываем имя\n\t$user-&gt;age = 25; // записываем возраст\n\t\n\t// Вызываем наш метод:\n\techo $user-&gt;show(); // выведет 'john'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code>, в котором\n\t\tбудут следующие свойства - <code class=\"code inline\">name</code>, <code class=\"code inline\">age</code>,\n\t\t<code class=\"code inline\">salary</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте в классе <code class=\"code inline\">Employee</code> метод <code class=\"code inline\">getName</code>,\n\t\tкоторый будет возвращать имя работника.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте в классе <code class=\"code inline\">Employee</code> метод <code class=\"code inline\">getAge</code>,\n\t\tкоторый будет возвращать возраст работника.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте в классе <code class=\"code inline\">Employee</code> метод <code class=\"code inline\">getSalary</code>,\n\t\tкоторый будет возвращать зарплату работника.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте в классе <code class=\"code inline\">Employee</code> метод <code class=\"code inline\">checkAge</code>,\n\t\tкоторый будет проверять то, что работнику\n\t\tбольше <code class=\"number inline\">18</code> лет и возвращать <code class=\"code inline\">true</code>,\n\t\tесли это так, и <code class=\"code inline\">false</code>, если это не так.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте два объекта класса <code class=\"code inline\">Employee</code>,\n\t\tзапишите в их свойства какие-либо значения.\n\t\tС помощью метода <code class=\"code inline\">getSalary</code> найдите\n\t\tсумму зарплат созданных работников.\n\t</p>\n</div>\n\n<h2>Запись свойств</h2>\n<p>\n\tС помощью <code class=\"code inline\">$this</code> свойства можно не\n\tтолько прочитывать, но и записывать. Давайте\n\tсделаем метод <code class=\"code inline\">setName()</code>, который параметром\n\tбудем принимать имя пользователя и записывать\n\tего в свойство <code class=\"code inline\">name</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Метод для изменения имени юзера:\n\t\tpublic function setName($name)\n\t\t{\n\t\t\t$this-&gt;name = $name; // запишем новое значение свойства name\n\t\t}\n\t}\n\t\n\t$user = new User; // создаем объект класса\n\t$user-&gt;name = 'john'; // записываем имя\n\t$user-&gt;age = 25; // записываем возраст\n\t\n\t// Установим новое имя:\n\t$user-&gt;setName('eric');\n\t\n\t// Проверим, что имя изменилось:\n\techo $user-&gt;name; // выведет 'eric'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">User</code>, в котором будут\n\t\tследующие свойства - <code class=\"code inline\">name</code> и <code class=\"code inline\">age</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте метод <code class=\"code inline\">setAge</code>, который параметром\n\t\tбудет принимать новый возраст пользователя.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте объект класса <code class=\"code inline\">User</code> с именем\n\t\t<code class=\"string inline\">'john'</code> и возрастом <code class=\"number inline\">25</code>. С помощью\n\t\tметода <code class=\"code inline\">setAge</code> поменяйте возраст на\n\t\t<code class=\"number inline\">30</code>. Выведите новое значение возраста\n\t\tна экран.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tМодифицируйте метод <code class=\"code inline\">setAge</code> так, чтобы\n\t\tон вначале проверял, что переданный возраст\n\t\tбольше или равен <code class=\"number inline\">18</code>. Если это так\n\t\t- пусть метод меняет возраст пользователя,\n\t\tа если не так - то ничего не делает.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code>, в котором\n\t\tбудут следующие свойства работника - <code class=\"code inline\">name</code>,\n\t\t<code class=\"code inline\">salary</code>. Сделайте метод <code class=\"code inline\">doubleSalary</code>,\n\t\tкоторый текущую зарплату будет увеличивать\n\t\tв <code class=\"number inline\">2</code> раза.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Rectangle</code>, в котором\n\t\tв свойствах будут записаны ширина и высота\n\t\tпрямоугольника.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ классе <code class=\"code inline\">Rectangle</code> сделайте метод\n\t\t<code class=\"code inline\">getSquare</code>, который будет возвращать\n\t\tплощадь этого прямоугольника.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ классе <code class=\"code inline\">Rectangle</code> сделайте метод\n\t\t<code class=\"code inline\">getPerimeter</code>, который будет возвращать\n\t\tпериметр этого прямоугольника.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/methods-and-this/","content":"\n\t\t\t\t<h1>Обращение к методам класса через $this</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tЧерез <code class=\"code inline\">$this</code> можно обращаться не только\n\tк свойствам объекта, но и к его методам.\n\tПосмотрим на примере. Пусть у нас есть класс\n\t<code class=\"code inline\">User</code>, а в нем метод <code class=\"code inline\">setAge</code>\n\tдля изменения возраста юзера:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Метод для изменения возраста юзера:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте добавим проверку введенного возраста:\n\tесли он от <code class=\"number inline\">18</code> до <code class=\"number inline\">60</code>, то будем\n\tменять возраст на новый, а если нет - то\n\tменять не будем:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Метод для изменения возраста юзера:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Если возраст от 18 до 60:\n\t\t\tif ($age &gt;= 18 and $age &lt;= 60) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть также нам нужен метод <code class=\"code inline\">addAge</code>,\n\tкоторый будет добавлять некоторое количество\n\tлет к текущему возрасту:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Метод для изменения возраста юзера:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Если возраст от 18 до 60:\n\t\t\tif ($age &gt;= 18 and $age &lt;= 60) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Метод для добавления к возрасту:\n\t\tpublic function addAge($years)\n\t\t{\n\t\t\t$this-&gt;age = $this-&gt;age + $years;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВ метод <code class=\"code inline\">addAge</code>, конечно же, также\n\tнеобходимо добавить проверку возраста, сделаем\n\tэто:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Метод для изменения возраста юзера:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Если возраст от 18 до 60:\n\t\t\tif ($age &gt;= 18 and $age &lt;= 60) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Метод для добавления к возрасту:\n\t\tpublic function addAge($years)\n\t\t{\n\t\t\t$newAge = $this-&gt;age + $years; // вычислим новый возраст\n\t\t\t\n\t\t\t// Если НОВЫЙ возраст от 18 до 60:\n\t\t\tif ($newAge &gt;= 18 and $newAge &lt;= 60) {\n\t\t\t\t$this-&gt;age = $newAge; // обновим, если новый возраст прошел проверку\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПолучится, что ограничения на возраст теперь\n\tзадаются в двух местах (в методе <code class=\"code inline\">setAge</code>\n\tи в методе <code class=\"code inline\">addAge</code>), что не очень хорошо:\n\tесли мы захотим поменять ограничение, нам\n\tпридется сделать это в двух местах - это\n\tнеудобно, и в каком-то из мест мы можем забыть\n\tвнести изменения - это опасно, ведь наш код\n\tполучится с трудноуловимой ошибкой.\n</p>\n<p>\n\tДавайте вынесем проверку возраста на корректность\n\tв отдельный <i>вспомогательный</i> метод\n\t<code class=\"code inline\">isAgeCorrect</code>, в который параметром\n\tбудет передаваться возраст для проверки,\n\tи используем его внутри методов <code class=\"code inline\">setAge</code>\n\tи <code class=\"code inline\">addAge</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Метод для проверки возраста:\n\t\tpublic function isAgeCorrect($age)\n\t\t{\n\t\t\tif ($age &gt;= 18 and $age &lt;= 60) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Метод для изменения возраста юзера:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($age)) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Метод для добавления к возрасту:\n\t\tpublic function addAge($years)\n\t\t{\n\t\t\t$newAge = $this-&gt;age + $years; // вычислим новый возраст\n\t\t\t\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($newAge)) {\n\t\t\t\t$this-&gt;age = $newAge; // обновим, если новый возраст прошел проверку\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТеперь любое изменения в условиях проверки\n\tможно будет легко сделать в одном месте.\n\tПроверим, что все работает как надо:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User;\n\t\n\t$user-&gt;setAge(30); // установим возраст в 30\n\techo $user-&gt;age; // выведет 30\n\t\n\t$user-&gt;setAge(10); // установим некорректный возраст\n\techo $user-&gt;age; // не выведет 10, а выведет 30\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код создайте такой\n\t\tже класс <code class=\"code inline\">User</code> с такими же методами.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте объект этого класса <code class=\"code inline\">User</code>\n\t\tпроверьте работу методов <code class=\"code inline\">setAge</code> и\n\t\t<code class=\"code inline\">addAge</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте также метод <code class=\"code inline\">subAge</code>, который\n\t\tбудет выполнять уменьшение текущего возраста\n\t\tна переданное количество лет.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/access-modifiers-public-and-private/","content":"\n\t\t\t\t<h1>Модификаторы доступа public и private в PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tКлючевое слово <code class=\"code inline\">public</code>, которое мы\n\tпишем перед именами указывает на то, что\n\tданные свойства и методы доступны извне (вне\n\tкода класса). В противоположность ключевое\n\tслово <code class=\"code inline\">private</code>, которое указывает на\n\tто, что свойства и методы недоступны извне.\n</p>\n<p>\n\tЗачем это надо? К примеру, у нас есть класс,\n\tреализующий некоторый функционал. Есть набор\n\tметодов, но часть этих методов является вспомогательными.\n</p>\n<p>\n\tБудет лучше, чтобы эти вспомогательные методы\n\tнельзя было использовать вне нашего класса.\n\tВ этом случае мы легко сможем поредактировать\n\tкод этих вспомогательных методов и будем\n\tуверенными в том, что их снаружи никто не\n\tиспользует и ничего страшного не случится.\n</p>\n<p>\n\tТакой подход называется <dfn>инкапсуляцией</dfn>\n\t- все лишнее не должно быть доступно извне,\n\tв этом случае жизнь программиста станет проще.\n</p>\n<p>\n\tТо же самое касается и свойств. Некоторые\n\tсвойства выполняют чисто вспомогательную\n\tфункцию и не должны быть доступны вне класса,\n\tиначе мы их можем случайно поменять снаружи\n\tи сломать работу нашего кода.\n</p>\n<p>\n\tМетоды и свойства, которые мы хотим сделать\n\tнедоступными извне, называются <dfn>приватными</dfn>\n\tи объявляются с помощью ключевого слова <code class=\"code inline\">private</code>.\n</p>\n<p>\n\tДавайте попробуем - объявим свойства <code class=\"code inline\">$name</code>\n\tи <code class=\"code inline\">$age</code> приватными и попытаемся обратиться\n\tк ним снаружи - мы сразу увидим ошибку:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t}\n\t\n\t$user = new User;\n\t\n\t// Выдаст ошибку, так как свойство name - private:\n\t$user-&gt;name = 'john';\n?&gt;</code>\n</div>\n\n<h2>Применим на практике</h2>\n<p>\n\tДавайте посмотрим на класс <code class=\"code inline\">User</code>, который\n\tмы сделали в предыдущем уроке:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Метод для проверки возраста:\n\t\tpublic function isAgeCorrect($age)\n\t\t{\n\t\t\treturn $age &gt;= 18 and $age &lt;= 60;\n\t\t}\n\t\t\n\t\t// Метод для изменения возраста юзера:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($age)) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Метод для добавления к возрасту:\n\t\tpublic function addAge($years)\n\t\t{\n\t\t\t$newAge = $this-&gt;age + $years; // вычислим новый возраст\n\t\t\t\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($newAge)) {\n\t\t\t\t$this-&gt;age = $newAge; // обновим, если новый возраст прошел проверку\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак мы знаем, метод <code class=\"code inline\">isAgeCorrect</code> является\n\tвспомогательным и мы не планируем использовать\n\tего снаружи класса. Логично сделать его приватным,\n\tчтобы другой программист, который будет потом\n\tработать над нашим проектом (или мы сами\n\tчерез некоторое время) случайно не использовал\n\tэтот метод снаружи класса.\n</p>\n<p>\n\tСделаем это:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Объявим приватным:\n\t\tprivate function isAgeCorrect($age)\n\t\t{\n\t\t\treturn $age &gt;= 18 and $age &lt;= 60;\n\t\t}\n\t\t\n\t\t// Метод для изменения возраста юзера:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($age)) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Метод для добавления к возрасту:\n\t\tpublic function addAge($years)\n\t\t{\n\t\t\t$newAge = $this-&gt;age + $years; // вычислим новый возраст\n\t\t\t\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($newAge)) {\n\t\t\t\t$this-&gt;age = $newAge; // обновим, если новый возраст прошел проверку\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tОбычно все приватные методы размещают в конце\n\tкласса, давайте перенесем наш метод в самый низ:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Метод для изменения возраста юзера:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($age)) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Метод для добавления к возрасту:\n\t\tpublic function addAge($years)\n\t\t{\n\t\t\t$newAge = $this-&gt;age + $years; // вычислим новый возраст\n\t\t\t\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($newAge)) {\n\t\t\t\t$this-&gt;age = $newAge; // обновим, если новый возраст прошел проверку\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Метод для проверки возраста:\n\t\tprivate function isAgeCorrect($age)\n\t\t{\n\t\t\treturn $age &gt;= 18 and $age &lt;= 60;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСуществует специальное правило: если вы делаете\n\tновый метод и не знаете, сделать его публичным\n\tили приватным, - делайте приватным. В дальнейшем,\n\tесли он понадобится снаружи, - вы поменяете\n\tего на публичный.\n</p>\n<p>\n\tЕще раз резюмируем: слова <code class=\"code inline\">public</code> и\n\t<code class=\"code inline\">private</code> не нужны для реализации логики\n\tпрограммы, а нужны для того, чтобы уберечь\n\tпрограммистов от ошибок.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код внесите такие же\n\t\tправки в класс <code class=\"code inline\">User</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПопробуйте вызвать метод <code class=\"code inline\">isAgeCorrect</code>\n\t\tснаружи класса. Убедитесь, что это будет\n\t\tвызывать ошибку.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Student</code> со свойствами\n\t\t<code class=\"code inline\">$name</code> и <code class=\"code inline\">$course</code> (курс студента,\n\t\tот <code class=\"number inline\">1</code>-го до <code class=\"number inline\">5</code>-го).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ классе <code class=\"code inline\">Student</code> сделайте <code class=\"code inline\">public</code>\n\t\tметод <code class=\"code inline\">transferToNextCourse</code>, который\n\t\tбудет переводить студента на следующий курс.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыполните в методе <code class=\"code inline\">transferToNextCourse</code>\n\t\tпроверку на то, что следующий курс не больше\n\t\t<code class=\"number inline\">5</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВынесите проверку курса в отдельный <code class=\"code inline\">private</code>\n\t\tметод <code class=\"code inline\">isCourseCorrect</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/constructor/","content":"\n\t\t\t\t<h1>Конструктор объекта в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте рассмотрим следующий код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Класс с публичными свойствами name и age:\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t}\n\t\n\t// Создаем объект класса:\n\t$user = new User;\n\t\n\t// Записываем данные:\n\t$user-&gt;name = 'john';\n\t$user-&gt;age = 25;\n\t\n\t// Прочитываем данные:\n\techo $user-&gt;name; // выведет 'john'\n\techo $user-&gt;age; // выведет 25\n?&gt;</code>\n</div>\n<p>\n\tВ данном коде не очень удобно то, что легко можно\n\tзабыть записать данные в какое-нибудь свойство\n\tобъекта, особенно если этих свойств много.\n</p>\n<p>\n\tБыло бы удобно этот код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Создаем объект класса:\n\t$user = new User;\n\t\n\t// Записываем данные:\n\t$user-&gt;name = 'john';\n\t$user-&gt;age = 25;\n?&gt;</code>\n</div>\n<p>\n\tЗаменить на вот этот:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 25); // создадим объект, сразу заполнив его данными\n?&gt;</code>\n</div>\n<p>\n\tТо есть сделать так, чтобы поля объекта заполнялись\n\tпри его создании - в этом случае мы никак\n\tне сможем забыть задать значения этих полей.\n</p>\n<p>\n\tДля решения проблемы нам поможет метод <dfn>конструктор</dfn>\n\tс названием <code class=\"code inline\">__construct</code>. Суть в следующем\n\t- если в коде класса существует метод с таким\n\tназванием - он будет вызываться в момент\n\tсоздания объекта:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Конструктор объекта:\n\t\tpublic function __construct()\n\t\t{\n\t\t\techo '!!!';\n\t\t}\n\t}\n\t\n\t$user = new User; // выведет '!!!'\n?&gt;</code>\n</div>\n<p>\n\tКонструктор в общем-то такой же метод, как\n\tи все остальные и может принимать параметры,\n\tсмотрите на примере:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\tpublic function __construct($var1, $var2)\n\t\t{\n\t\t\techo $var1 + $var2; // найдем сумму параметров\n\t\t}\n\t}\n\t\n\t$user = new User(1, 2); // выведет 3\n?&gt;</code>\n</div>\n<p>\n\tИтак, давайте переделаем наш код, применив\n\tконструктор:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Конструктор объекта:\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name; // запишем данные в свойство name\n\t\t\t$this-&gt;age = $age; // запишем данные в свойство age\n\t\t}\n\t}\n\t\n\t$user = new User('john', 25); // создадим объект, сразу заполнив его данными\n\t\n\techo $user-&gt;name; // выведет 'john'\n\techo $user-&gt;age; // выведет 25\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code>, в котором\n\t\tбудут следующие публичные свойства - <code class=\"code inline\">name</code>,\n\t\t<code class=\"code inline\">age</code>, <code class=\"code inline\">salary</code>. Сделайте так,\n\t\tчтобы эти свойства заполнялись в конструкторе\n\t\tпри создании объекта.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте объект класса <code class=\"code inline\">Employee</code> с\n\t\tименем <code class=\"string inline\">'eric'</code>, возрастом <code class=\"number inline\">25</code>,\n\t\tзарплатой <code class=\"number inline\">1000</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте объект класса <code class=\"code inline\">Employee</code> с\n\t\tименем <code class=\"string inline\">'kyle'</code>, возрастом <code class=\"number inline\">30</code>,\n\t\tзарплатой <code class=\"number inline\">2000</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыведите на экран сумму зарплат\n\t\tсозданных вами юзеров.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/getters-and-setters/","content":"\n\t\t\t\t<h1>Работа с геттерами и сеттерами в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте рассмотрим следующий класс:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\t// Метод для изменения возраста юзера:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($age)) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Метод для проверки возраста:\n\t\tprivate function isAgeCorrect($age)\n\t\t{\n\t\t\treturn $age &gt;= 18 and $age &lt;= 60;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, у нас есть публичные свойства\n\t<code class=\"code inline\">name</code> и <code class=\"code inline\">age</code>, публичный метод\n\t<code class=\"code inline\">setAge</code> для изменения возраста и приватный\n\tметод проверки возраста <code class=\"code inline\">isAgeCorrect</code>.\n</p>\n<p>\n\tОчевидно, что предполагается, что возраст\n\tвсегда будет меняться через метод <code class=\"code inline\">setAge</code>,\n\tтак как в нем выполняется проверка возраста\n\tна корректность.\n</p>\n<p>\n\tОднако, ничего не мешает сделать так:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User;\n\t\n\t// Вместо вызова setAge установим некорректный возраст напрямую:\n\t$user-&gt;age = 100500; // и у нас получится!\n?&gt;</code>\n</div>\n<p>\n\tУпс... Получается, что мы надеемся, что везде\n\tи всегда возраст будет меняться через <code class=\"code inline\">setAge</code>,\n\tно случайно другой программист или мы сами\n\tможем напрямую обратиться к свойству и записать\n\tв него все, что угодно.\n</p>\n<p>\n\tЭто ошибкоопасное место и с этим нужно что-то\n\tсделать.\n</p>\n<p>\n\tДля решения проблемы можно объявить возраст\n\tприватным:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tprivate $age; // объявим возраст приватным\n\t\t\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Проверим возраст на корректность:\n\t\t\tif ($this-&gt;isAgeCorrect($age)) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate function isAgeCorrect($age)\n\t\t{\n\t\t\treturn $age &gt;= 18 and $age &lt;= 60;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТеперь установить возраст напрямую (корректный\n\tили нет - не важно) не получится:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User;\n\t\n\t// Теперь установить возраст напрямую не получится:\n\t$user-&gt;age = 100500; // увидим ошибку PHP!\n?&gt;</code>\n</div>\n<p>\n\tОтлично, мы получили то, что хотели. Но теперь\n\tесть другая проблема: мы не можем прочитать\n\tвозраст снаружи, так как он приватный:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User;\n\t\n\t// Правильным образом установим возраст:\n\t$user-&gt;setAge(50);\n\t\n\t// Попытка прочитать новый возраст приведет к ошибке PHP:\n\techo $user-&gt;age; // а нам бы этого не хотелось...\n?&gt;</code>\n</div>\n<p>\n\tДля решения проблемы сделаем еще один метод\n\t<code class=\"code inline\">getAge</code>, с помощью которого мы будем\n\tпрочитывать значения свойства <code class=\"code inline\">age</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tprivate $age; // объявим возраст приватным\n\t\t\n\t\t// Метод для чтения возраста юзера:\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\tif ($this-&gt;isAgeCorrect($age)) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate function isAgeCorrect($age)\n\t\t{\n\t\t\treturn $age &gt;= 18 and $age &lt;= 60;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТеперь мы свободно можем и менять, и получать\n\tвозраст:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User;\n\t\n\t// Установим возраст:\n\t$user-&gt;setAge(50);\n\t\n\t// Прочитаем новый возраст:\n\techo $user-&gt;getAge(); // выведет 50\n?&gt;</code>\n</div>\n<p>\n\tТакой подход, который мы сейчас сделали,\n\t- стандартный. Его удобно использовать тогда,\n\tкогда нам нужна какая-то проверка в сеттере.\n\tВ терминах этого подхода метод <code class=\"code inline\">getAge</code>\n\tназывается <dfn>геттером</dfn> (<span class=\"translate-prefix\">англ.</span> <span class=\"translate-en\">getter</span>),\n\tа метод <code class=\"code inline\">setAge</code> - <dfn>сеттером</dfn> (<span class=\"translate-prefix\">англ.</span> <span class=\"translate-en\">setter</span>).\n</p>\n<p>\n\tОчень часто бывает так, что даже если нам\n\tне нужны никакие проверки - все равно свойство\n\tобъявляется приватным, а для доступа к нему\n\tиспользуются геттеры и сеттеры. Почему? Потому\n\tчто, возможно, нам захочется добавить проверку\n\tв дальнейшем и, если все изменения свойства\n\tв коде делаются через сеттер, нам не придется\n\tвносить правки в код снаружи класса - мы\n\tпросто внесем одну правку в сам сеттер.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code>, в котором\n\t\tбудут следующие приватные свойства: <code class=\"code inline\">name</code>,\n\t\t<code class=\"code inline\">age</code> и <code class=\"code inline\">salary</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте геттеры и сеттеры для всех свойств\n\t\tкласса <code class=\"code inline\">Employee</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДополните класс <code class=\"code inline\">Employee</code> приватным\n\t\tметодом <code class=\"code inline\">isAgeCorrect</code>, который будет\n\t\tпроверять возраст на корректность (от <code class=\"number inline\">1</code>\n\t\tдо <code class=\"number inline\">100</code> лет). Этот метод должен использоваться\n\t\tв сеттере <code class=\"code inline\">setAge</code> перед установкой\n\t\tнового возраста (если возраст не корректный\n\t\t- он не должен меняться).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть зарплата наших работников хранится\n\t\tв долларах. Сделайте так, чтобы геттер <code class=\"code inline\">getSalary</code>\n\t\tдобавлял в конец числа с зарплатой значок\n\t\tдоллара. Говоря другими словами в свойстве\n\t\t<code class=\"code inline\">salary</code> зарплата будет хранится просто\n\t\tчислом, но геттер будет возвращать ее с долларом\n\t\tна конце.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/read-only-properties/","content":"\n\t\t\t\t<h1>Свойства только для чтения в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами сделаем так, чтобы в объекте\n\tкакое-то свойство было доступно только для\n\tчтения, но не для записи (<span class=\"translate-prefix\">англ.</span> <span class=\"translate-en\">read-only</span>).\n</p>\n<p>\n\tЭто делается следующим образом: для такого\n\tсвойства нужно сделать геттер, но не делать\n\tсеттер. В этом случае свойство можно будет\n\tпрочитать с помощью геттера, но нельзя будет\n\tзаписать, так как сеттер отсутствует. При\n\tэтом изначальное значение свойства будет\n\tзадаваться в конструкторе при создании объекта.\n</p>\n<p>\n\tДавайте попробуем реализовать описанное.\n\tПусть у нас дан вот такой класс <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем так, чтобы свойство <code class=\"code inline\">name</code>\n\tбыло доступно только для чтения, а свойство\n\t<code class=\"code inline\">age</code> - и для чтения и для записи. Для\n\tэтого свойству <code class=\"code inline\">name</code> сделаем только\n\tгеттер, а свойству <code class=\"code inline\">age</code> - и геттер и сеттер:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\t// Геттер для имени:\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\t// Геттер для возраста:\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\t// Сеттер для возраста:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь добавим конструктор объекта,\n\tв котором будем задавать начальные значения\n\tнаших свойств:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\t// Конструктор объекта:\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t\t\n\t\t// Геттер для имени:\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\t// Геттер для возраста:\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\t// Сеттер для возраста:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВсе - наша задача решена, убедимся в этом:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 25); // создаем объект с начальными данными\n\t\n\t// Имя можно только читать, но нельзя поменять:\n\techo $user-&gt;getName(); // выведет 'john'\n\t\n\t// Возраст можно и читать, и менять:\n\techo $user-&gt;getAge(); // выведет 25\n\techo $user-&gt;setAge(30); // установим возраст в значение 30\n\techo $user-&gt;getAge(); // выведет 30\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code>, в котором\n\t\tбудут следующие свойства: <code class=\"code inline\">name</code>, <code class=\"code inline\">surname</code>\n\t\tи <code class=\"code inline\">salary</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте так, чтобы свойства <code class=\"code inline\">name</code>\n\t\tи <code class=\"code inline\">surname</code> были доступны только для\n\t\tчтения, а свойство <code class=\"code inline\">salary</code> - и для\n\t\tчтения, и для записи.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/one-class-one-file/","content":"\n\t\t\t\t<h1>Хранение классов в отдельных файлах в PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДо этого урока мы писали наши классы в том\n\tже файле, где и вызывали их. В реальной жизни\n\tклассы обычно хранятся в отдельных файлах,\n\tпричем каждый класс в своем отдельном файле.\n\tПри этом существует соглашение о том, что\n\tфайл с классом следует называть так же, как\n\tи сам класс. Давайте посмотрим на практике.\n\tСделаем файл <code class=\"path inline\">User.php</code> с классом <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть теперь у нас есть файл <code class=\"path inline\">index.php</code>,\n\tв котором мы хотим воспользоваться нашим\n\tклассом <code class=\"code inline\">User</code>. Мы не можем в этом файле\n\tпросто взять и создать объект класса <code class=\"code inline\">User</code>\n\t- это вызовет ошибку, так как PHP не сможет\n\tнайди код этого класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User; // это вызовет ошибку\n?&gt;</code>\n</div>\n<p>\n\tДля того, чтобы класс <code class=\"code inline\">User</code> был доступен\n\tв файле <code class=\"path inline\">index.php</code>, нужно подключить\n\tэтому нему файл с нашим классом. Сделаем\n\tэто с помощью команды <code class=\"code inline\">require_once</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\trequire_once 'User.php'; // подключаем наш класс\n\t$user = new User;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте несколько классов в разных файлах.\n\t\tПодключите ваши классы к файлу <code class=\"path inline\">index.php</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/objects-in-array/","content":"\n\t\t\t\t<h1>Хранение объектов в массивах в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас дан вот такой класс <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПодключим файл с нашим классом к файлу <code class=\"path inline\">index.php</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\trequire_once 'User.php';\n?&gt;</code>\n</div>\n<p>\n\tСоздадим три объекта нашего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('john', 21);\n\t$user2 = new User('eric', 22);\n\t$user3 = new User('kyle', 23);\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь запишем созданные нами объекты\n\tв массив <code class=\"code inline\">$users</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('john', 21);\n\t$user2 = new User('eric', 22);\n\t$user3 = new User('kyle', 23);\n\t\n\t$users[] = $user1;\n\t$users[] = $user2;\n\t$users[] = $user3;\n\t\n\tvar_dump($users);\n?&gt;</code>\n</div>\n<p>\n\tВ общем-то переменные, в которые мы сохраняем\n\tнаши объекты, и не нужны. Можем сократить наш код:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$users[] = new User('john', 21);\n\t$users[] = new User('eric', 22);\n\t$users[] = new User('kyle', 23);\n\t\n\tvar_dump($users);\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь переделаем наш код в другом\n\tстиле - добавим элементы в массив сразу при\n\tего создании:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('john', 21);\n\t$user2 = new User('eric', 22);\n\t$user3 = new User('kyle', 23);\n\t\n\t$users = [$user1, $user2, $user3];\n\tvar_dump($users);\n?&gt;</code>\n</div>\n<p>\n\tЗдесь также можно избавится от промежуточных\n\tпеременных:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$users = [\n\t\tnew User('john', 21),\n\t\tnew User('eric', 22),\n\t\tnew User('kyle', 23)\n\t];\n\t\n\tvar_dump($users);\n?&gt;</code>\n</div>\n<p>\n\tНеважно каким способом мы создаем наш массив\n\tс объектами - важен сам принцип: объекты\n\tможно хранить в массивах. Затем эти объекты\n\tможно, к примеру, перебрать циклом. Давайте\n\tсделаем это:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$users = [\n\t\tnew User('john', 21),\n\t\tnew User('eric', 22),\n\t\tnew User('kyle', 23)\n\t];\n\t\n\t// Переберем созданный массив циклом:\n\tforeach ($users as $user) {\n\t\techo $user-&gt;name . ' ' . $user-&gt;age . '&lt;br&gt;';\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">City</code>, в котором будут\n\t\tследующие свойства: <code class=\"code inline\">name</code>, <code class=\"code inline\">population</code>\n\t\t(количество населения).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте <code class=\"number inline\">5</code> объектов класса <code class=\"code inline\">City</code>,\n\t\tзаполните их данными и запишите в массив.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПереберите созданный вами массив с городами\n\t\tциклом и выведите города и их население на экран.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/constructor-initial-properties-values/","content":"\n\t\t\t\t<h1>Начальные значения свойств в конструкторе</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас есть какой-то класс с двумя свойствами:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic $prop1;\n\t\tpublic $prop2;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем так, чтобы при создании объекта\n\tкласса эти свойства имели какие-либо значения.\n\tКак вы уже знаете, в момент создания объекта\n\tвызывается метод-конструктор. Зададим начальные\n\tзначения свойства в этом методе:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic $prop1;\n\t\tpublic $prop2;\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;prop1 = 'value1'; // начальное значение свойства\n\t\t\t$this-&gt;prop2 = 'value2'; // начальное значение свойства\n\t\t}\n\t}\n\t\n\t$test = new Test;\n\techo $test-&gt;prop1; // выведет 'value1'\n\techo $test-&gt;prop2; // выведет 'value2'\n?&gt;</code>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tПусть у нас есть класс <code class=\"code inline\">Student</code> с двумя\n\tсвойствами - <code class=\"code inline\">name</code> и <code class=\"code inline\">course</code>\n\t(<span class=\"translate-ru\">курс студента</span>). Сделаем так, чтобы\n\tимя студента приходило параметром при создании\n\tобъекта, а курс автоматически принимал значение\n\t<code class=\"number inline\">1</code>:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student\n\t{\n\t\tprivate $name;\n\t\tprivate $course;\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;course = 1; // курс изначально равен 1\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСделаем геттеры для наших свойств:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student\n\t{\n\t\tprivate $name;\n\t\tprivate $course;\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;course = 1;\n\t\t}\n\t\t\n\t\t// Геттер имени:\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\t// Геттер курса:\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть имя созданного студента будет неизменяемым\n\tи доступным только для чтения, а вот для\n\tкурса мы сделаем метод, который будет переводить\n\tнашего студента на следующий курс:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student\n\t{\n\t\tprivate $name;\n\t\tprivate $course;\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;course = 1;\n\t\t}\n\t\t\n\t\t// Геттер имени:\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\t// Геттер курса:\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t\t\n\t\t// Перевод студента на новый курс:\n\t\tpublic function transferToNextCourse()\n\t\t{\n\t\t\t$this-&gt;course++;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нашего класса:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student('john'); // создаем объект класса\n\t\n\techo $student-&gt;getCourse(); // выведет 1 - начальное значение\n\t$student-&gt;transferToNextCourse(); // переведем студента на следующий курс\n\techo $student-&gt;getCourse(); // выведет 2\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код реализуйте такой\n\t\tже класс <code class=\"code inline\">Student</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tМодифицируйте метод <code class=\"code inline\">transferToNextCourse</code>\n\t\tтак, чтобы при переводе на новый курс выполнялась\n\t\tпроверка того, что новый курс не будет больше\n\t\t<code class=\"number inline\">5</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/declaring-initial-properties-values/","content":"\n\t\t\t\t<h1>Начальные значения свойств при объявлении</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tРассмотрим следующий класс:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic $prop1;\n\t\tpublic $prop2;\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;prop1 = 'value1'; // начальное значение свойства prop1\n\t\t\t$this-&gt;prop2 = 'value2'; // начальное значение свойства prop2\n\t\t}\n\t}\n\t\n\t$test = new Test;\n\techo $test-&gt;prop1; // выведет 'value1'\n\techo $test-&gt;prop2; // выведет 'value2'\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, в этом коде в конструкторе\n\tобъекта мы задаем начальные значения свойств.\n\tНа самом деле можно сократить лишний код,\n\tзадав начальные значения свойств прямо при\n\tих объявлении:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic $prop1 = 'value1'; // начальное значение свойства prop1\n\t\tpublic $prop2 = 'value2'; // начальное значение свойства prop2\n\t}\n\t\n\t$test = new Test;\n\techo $test-&gt;prop1; // выведет 'value1'\n\techo $test-&gt;prop2; // выведет 'value2'\n?&gt;</code>\n</div>\n\n<h2>Замечания</h2>\n<p>\n\tКонечно же, не обязательно задавать начальные\n\tзначения всем свойствам:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic $prop1 = 'value1'; // задаем начальное значение\n\t\tpublic $prop2; // не задаем\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПри задании начальных значений свойств можно\n\tвыполнять некоторые операции (самые примитивные):\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic $prop = 1 + 2; // найдем сумму чисел\n\t}\n\t\n\t$test = new Test;\n\techo $test-&gt;prop; // выведет 3\n?&gt;</code>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tПусть у нас есть вот такой класс <code class=\"code inline\">Student</code>,\n\tв конструкторе которого задается начальное\n\tзначение свойства <code class=\"code inline\">course</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student\n\t{\n\t\tprivate $name;\n\t\tprivate $course;\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;course = 1; // начальное значение курса\n\t\t}\n\t\t\n\t\tpublic function transferToNextCourse()\n\t\t{\n\t\t\t$this-&gt;course++;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте вынесем начальное значение курса\n\tв объявление свойства:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student\n\t{\n\t\tprivate $name;\n\t\tprivate $course = 1; // начальное значение курса\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\tpublic function transferToNextCourse()\n\t\t{\n\t\t\t$this-&gt;course++;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tПусть у нас есть вот такой класс <code class=\"code inline\">Arr</code>,\n\tу которого есть метод <code class=\"code inline\">add</code> для добавления\n\tчисел и метод <code class=\"code inline\">getSum</code> для получения\n\tсуммы всех добавленных чисел:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\t// Массив для хранения чисел:\n\t\tprivate $numbers;\n\t\t\n\t\t// Добавляет число в набор:\n\t\tpublic function add($num)\n\t\t{\n\t\t\t$this-&gt;numbers[] = $num;\n\t\t}\n\t\t\n\t\t// Находит сумму чисел набора:\n\t\tpublic function getSum()\n\t\t{\n\t\t\treturn array_sum($this-&gt;numbers);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте воспользуемся нашим классом <code class=\"code inline\">Arr</code>\n\t- добавим несколько чисел и найдем их сумму:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr;\n\t\n\t$arr-&gt;add(1);\n\t$arr-&gt;add(2);\n\t$arr-&gt;add(3);\n\t\n\techo $arr-&gt;getSum(); // выведет 6\n?&gt;</code>\n</div>\n<p>\n\tВсе вроде работает, но что будет, если сразу\n\tпосле создания вызвать метод <code class=\"code inline\">getSum</code>?\n\tВот таким образом:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr;\n\techo $arr-&gt;getSum();\n?&gt;</code>\n</div>\n<p>\n\tТакой код вызовет ошибку, потому что функция\n\t<code class=\"code inline\">array_sum</code> пытается найти сумму массива\n\tиз свойства <code class=\"code inline\">numbers</code>. Но это свойство\n\tеще не определено и имеет значение <code class=\"code inline\">null</code>.\n\tЭто и приводит к ошибке. Давайте исправим\n\tпроблему, объявив наше свойство пустым массивом:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\tprivate $numbers = []; // задаем начальное значение свойства как []\n\t\t\n\t\tpublic function add($num)\n\t\t{\n\t\t\t$this-&gt;numbers[] = $num;\n\t\t}\n\t\t\n\t\tpublic function getSum()\n\t\t{\n\t\t\treturn array_sum($this-&gt;numbers);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr;\n\techo $arr-&gt;getSum(); // выведет 0\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте класс <code class=\"code inline\">Arr</code>, похожий на тот,\n\t\tкоторый я реализовал выше. В отличие от моего\n\t\tкласса метод <code class=\"code inline\">add</code> вашего класса параметром\n\t\tдолжен принимать массив чисел. Все числа\n\t\tиз этого массива должны добавляться в конец\n\t\tмассива <code class=\"code inline\">$this->numbers</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте также метод <code class=\"code inline\">getAvg</code>, который\n\t\tбудет находить среднее арифметическое чисел.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/variable-properties-names/","content":"\n\t\t\t\t<h1>Переменные названия свойств объектов в PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас есть вот такой класс <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n\t\n\t$user = new User('john', 21);\n\techo $user-&gt;name; // выведет 'john'\n?&gt;</code>\n</div>\n<p>\n\tНа примере этого класса мы сейчас разберем\n\tто, что названия свойств можно хранить в\n\tпеременной.\n</p>\n<p>\n\tК примеру, пусть у нас есть переменная <code class=\"code inline\">$prop</code>,\n\tв которой лежит строка <code class=\"string inline\">'name'</code>. Тогда\n\tобращение <code class=\"code inline\">$user->$prop</code> по сути эквивалентно\n\tобращению <code class=\"code inline\">$user->name</code>. Такое хитрое\n\tобращения к свойствам класса используется\n\tредко, но иногда бывает полезно.\n</p>\n<p>\n\tПосмотрим на примере:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 21);\n\t\n\t$prop = 'name';\n\techo $user-&gt;$prop; // выведет 'john'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">City</code>, в котором будут\n\t\tследующие свойства - <code class=\"code inline\">name</code>, <code class=\"code inline\">foundation</code>\n\t\t(<span class=\"translate-ru\">дата основания</span>), <code class=\"code inline\">population</code>\n\t\t(<span class=\"translate-ru\">население</span>). Создайте объект этого\n\t\tкласса.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть дана переменная <code class=\"code inline\">$props</code>, в которой\n\t\tхранится массив названий свойств класса <code class=\"code inline\">City</code>.\n\t\tПереберите этот массив циклом <code class=\"code inline\">foreach</code>\n\t\tи выведите на экран значения соответствующих\n\t\tсвойств.\n\t</p>\n</div>\n\n<h2>Массив свойств</h2>\n<p>\n\tПусть теперь дан вот такой класс <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $surname; // фамилия\n\t\tpublic $name; // имя\n\t\tpublic $patronymic; // отчество\n\t\t\n\t\tpublic function __construct($surname, $name, $patronymic)\n\t\t{\n\t\t\t$this-&gt;surname = $surname;\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;patronymic = $patronymic;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tИ пусть дан массив свойств\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$props = ['surname', 'name', 'patronymic'];\n?&gt;</code>\n</div>\n<p>\n\tПопробуем теперь вывести значение свойства,\n\tкоторое хранится в нулевом элементе массива,\n\tто есть в <code class=\"code inline\">$props[0]</code>. Просто так, однако,\n\tэто не будет работать:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('Иванов', 'Иван', 'Иванович');\n\t\n\t$props = ['surname', 'name', 'patronymic'];\n\techo $user-&gt;$props[0]; // так работать не будет\n?&gt;</code>\n</div>\n<p>\n\tДля того, чтобы такое сложное имя свойства\n\tзаработало, его нужно взять в фигурные скобки,\n\tвот так:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('Иванов', 'Иван', 'Иванович');\n\t\n\t$props = ['surname', 'name', 'patronymic'];\n\techo $user-&gt;{$props[0]}; // выведет 'Иванов'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте мой код класса <code class=\"code inline\">User</code> и массив\n\t\t<code class=\"code inline\">$props</code>. В моем примере на экран выводится\n\t\tфамилия юзера. Выведите еще и имя, и отчество.\n\t</p>\n</div>\n\n<h2>Ассоциативный массив</h2>\n<p>\n\tМассив, кстати, может быть и ассоциативным:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('Иванов', 'Иван', 'Иванович');\n\t\n\t$props = ['prop1' =&gt; 'surname', 'prop2' =&gt; 'name', 'prop3' =&gt; 'patronymic'];\n\techo $user-&gt;{$props['prop1']}; // выведет 'Иванов'\n?&gt;</code>\n</div>\n\n<h2>Имя свойства из функции</h2>\n<p>\n\tИмя свойства также может быть из функции:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tfunction getProp()\n\t{\n\t\treturn 'surname';\n\t}\n\t\n\t$user = new User('Иванов', 'Иван', 'Иванович');\n\techo $user-&gt;{getProp()}; // выведет 'Иванов'\n?&gt;</code>\n</div>\n\n<h2>Имя свойства из свойства другого объекта</h2>\n<p>\n\tИмя свойства может быть даже свойством другого\n\tобъекта.\n</p>\n<p>\n\tПроиллюстрируем кодом. Пусть для примера\n\tдан объект <code class=\"code inline\">Prop</code>, который в свойстве\n\t<code class=\"code inline\">value</code> будет содержать название свойства\n\tобъекта <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Prop\n\t{\n\t\tpublic $value;\n\t\t\n\t\tpublic function __construct($value)\n\t\t{\n\t\t\t$this-&gt;value = $value;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте выведем фамилию юзера с помощью объекта\n\t<code class=\"code inline\">Prop</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('Иванов', 'Иван', 'Иванович');\n\t$prop = new Prop('surname'); // будем выводить значение свойства surname\n\t\n\techo $user-&gt;{$prop-&gt;value}; // выведет 'Иванов'\n?&gt;</code>\n</div>\n\n<h2>Имя свойства из метода другого объекта</h2>\n<p>\n\tИмя свойства также может браться из метода\n\tдругого объекта:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Prop\n\t{\n\t\tprivate $value;\n\t\t\n\t\tpublic function __construct($value)\n\t\t{\n\t\t\t$this-&gt;value = $value;\n\t\t}\n\t\t\n\t\tpublic function getValue()\n\t\t{\n\t\t\treturn $this-&gt;value;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте выведем фамилию юзера:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('Иванов', 'Иван', 'Иванович');\n\t$prop = new Prop('surname'); // будем выводить значение свойства surname\n\t\n\techo $user-&gt;{$prop-&gt;getValue()}; // выведет 'Иванов'\n?&gt;</code>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/variable-methods-names/","content":"\n\t\t\t\t<h1>Переменные названия методов</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПо аналогии с названиями свойств в переменной\n\tтакже можно хранить и имена методов. Давайте\n\tпосмотрим на примере. Пусть у нас дан вот\n\tтакой класс <code class=\"code inline\">User</code> с геттерами свойств:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть в переменной <code class=\"code inline\">$method</code> хранится\n\tимя метода. Давайте вызовем метод с таким именем:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 21);\n\t\n\t$method = 'getName';\n\techo $user-&gt;$method(); // выведет 'john'\n?&gt;</code>\n</div>\n<p>\n\tЕсли имя метода получается из массива, то\n\tтакое обращение к методу следует брать в\n\tфигурные скобки вот таким образом (круглые\n\tскобки будут снаружи фигурных):\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 21);\n\t\n\t$methods = ['getName', 'getAge'];\n\techo $user-&gt;{$methods[0]}(); // выведет 'john'\n?&gt;</code>\n</div>\n<p>\n\tВсе остальные нюансы точно такие же, как\n\tи при работе со свойствами из переменной.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tПусть массив <code class=\"code inline\">$methods</code> будет ассоциативным\n\t\tс ключами <code class=\"code inline\">method1</code> и <code class=\"code inline\">method2</code>:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$methods = ['method1' =&gt; 'getName', 'method2' =&gt; 'getAge'];\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tВыведите имя и возраст пользователя с помощью\n\t\tэтого массива.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/method-call-after-object-creation/","content":"\n\t\t\t\t<h1>Вызов метода сразу после создания объекта</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас дан класс <code class=\"code inline\">Arr</code>, который\n\tхранит в себе массив чисел и может вычислять\n\tсумму этих чисел с помощью метода <code class=\"code inline\">getSum</code>.\n\tСами числа приходят в виде массива в конструктор\n\tобъекта, а также могут добавляться по одному\n\tс помощью метода <code class=\"code inline\">add</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\tprivate $numbers = []; // массив чисел\n\t\t\n\t\tpublic function __construct($numbers)\n\t\t{\n\t\t\t$this-&gt;numbers = $numbers; // записываем массив $numbers в свойство\n\t\t}\n\t\t\n\t\t// Добавляем еще одно число в наш массив:\n\t\tpublic function add($number)\n\t\t{\n\t\t\t$this-&gt;numbers[] = $number;\n\t\t}\n\t\t\n\t\t// Находим сумму чисел:\n\t\tpublic function getSum()\n\t\t{\n\t\t\treturn array_sum($this-&gt;numbers);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВот пример использования класса <code class=\"code inline\">Arr</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr([1, 2, 3]); // создаем объект, записываем в него массив [1, 2, 3]\n\t$arr-&gt;add(4); // добавляем в конец массива число 4\n\t$arr-&gt;add(5); // добавляем в конец массива число 5\n\t\n\t// Находим сумму элементов массива:\n\techo $arr-&gt;getSum(); // выведет 15\n?&gt;</code>\n</div>\n<p>\n\tМожет такое быть, что все нужные числа мы\n\tпередадим в момент создания объекта, а затем\n\tсразу захотим найти их сумму:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr([1, 2, 3]);\n\techo $arr-&gt;getSum(); // выведет 6\n?&gt;</code>\n</div>\n<p>\n\tЕсли мы больше не планируем делать никаких\n\tманипуляций с объектом, то код выше можно\n\tпереписать короче: можно создать объект и\n\tсразу вызвать его метод <code class=\"code inline\">getSum</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Arr([1, 2, 3]))-&gt;getSum(); // выведет 6\n?&gt;</code>\n</div>\n<p>\n\tВот еще пример - найдем сумму двух массивов:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Arr([1, 2, 3]))-&gt;getSum() + (new Arr([4, 5, 6]))-&gt;getSum();\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код реализуйте такой\n\t\tже класс <code class=\"code inline\">Arr</code> и вызовите его метод\n\t\t<code class=\"code inline\">getSum</code> сразу после создания объекта.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/methods-chains/","content":"\n\t\t\t\t<h1>Цепочки методов</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас дан класс <code class=\"code inline\">Arr</code>, который\n\tхранит в себе массив чисел и может вычислять\n\tсумму этих чисел с помощью метода <code class=\"code inline\">getSum</code>.\n\tЧисла могут добавляться по одному с помощью\n\tметода <code class=\"code inline\">add</code>, либо группой с помощью\n\tметода <code class=\"code inline\">push</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\tprivate $numbers = [];\n\t\t\n\t\tpublic function add($number)\n\t\t{\n\t\t\t$this-&gt;numbers[] = $number;\n\t\t}\n\t\t\n\t\tpublic function push($numbers)\n\t\t{\n\t\t\t$this-&gt;numbers = array_merge($this-&gt;numbers, $numbers);\n\t\t}\n\t\t\n\t\tpublic function getSum()\n\t\t{\n\t\t\treturn array_sum($this-&gt;numbers);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПример использования класса <code class=\"code inline\">Arr</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr; // создаем объект\n\t\n\t$arr-&gt;add(1); // добавляем в массив число 1\n\t$arr-&gt;add(2); // добавляем в массив число 2\n\t$arr-&gt;push([3, 4]); // добавляем группу чисел\n\t\n\techo $arr-&gt;getSum(); // находим сумму элементов массива\n?&gt;</code>\n</div>\n<p>\n\tПусть теперь мы хотим сделать так, чтобы\n\tметоды вызывались не отдельно, а цепочкой,\n\tвот так:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo $arr-&gt;add(1)-&gt;add(2)-&gt;push([3, 4])-&gt;getSum(); // это наша цель\n?&gt;</code>\n</div>\n<p>\n\tДля того, чтобы можно было написать такую\n\tцепочку, нужно, чтобы все методы, которые\n\tучаствуют в цепочке возвращали <code class=\"code inline\">$this</code>\n\t(кроме последнего). Поправим наш класс <code class=\"code inline\">Arr</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\tprivate $numbers = []; // массив чисел\n\t\t\n\t\tpublic function add($number)\n\t\t{\n\t\t\t$this-&gt;numbers[] = $number;\n\t\t\treturn $this; // вернем ссылку сами на себя\n\t\t}\n\t\t\n\t\tpublic function push($numbers)\n\t\t{\n\t\t\t$this-&gt;numbers = array_merge($this-&gt;numbers, $numbers);\n\t\t\treturn $this; // вернем ссылку сами на себя\n\t\t}\n\t\t\n\t\tpublic function getSum()\n\t\t{\n\t\t\treturn array_sum($this-&gt;numbers);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим, что все работает:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr;\n\techo $arr-&gt;add(1)-&gt;add(2)-&gt;push([3, 4])-&gt;getSum(); // выведет 10\n?&gt;</code>\n</div>\n<p>\n\tМожно упростить еще больше:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Arr)-&gt;add(1)-&gt;add(2)-&gt;push([3, 4])-&gt;getSum(); // выведет 10\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код самостоятельно\n\t\tреализуйте такой же класс <code class=\"code inline\">Arr</code>, методы\n\t\tкоторого будут вызываться в виде цепочки.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class-as-methods-set/","content":"\n\t\t\t\t<h1>Класс как набор методов в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tЧасто классы используются просто как набор\n\tнекоторых методов, сгруппированных вместе.\n\tВ этом случае нам не нужно создавать много\n\tобъектов этого класса, а достаточно всего одного.\n</p>\n<p>\n\tДля примера давайте сделаем класс <code class=\"code inline\">ArraySumHelper</code>,\n\tкоторый предоставит нам набор методов для\n\tработы с массивами. Каждый метод нашего класса\n\tбудет принимать массив, что-то с ним делать\n\tи возвращать результат. Пусть у нас будет\n\tследующий набор методов:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass ArraySumHelper\n\t{\n\t\t// Сумма элементов массива:\n\t\tpublic function getSum1($arr)\n\t\t{\n\t\t\t\n\t\t}\n\t\t\n\t\t// Сумма квадратов элементов массива:\n\t\tpublic function getSum2($arr)\n\t\t{\n\t\t\t\n\t\t}\n\t\t\n\t\t// Сумма кубов элементов массива:\n\t\tpublic function getSum3($arr)\n\t\t{\n\t\t\t\n\t\t}\n\t\t\n\t\t// Сумма четвертых степеней элементов массива:\n\t\tpublic function getSum4($arr)\n\t\t{\n\t\t\t\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте посмотрим, как мы будем пользоваться\n\tнашим классом:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arraySumHelper = new ArraySumHelper;\n\t\n\t$arr = [1, 2, 3];\n\techo $arraySumHelper-&gt;getSum1($arr);\n\techo $arraySumHelper-&gt;getSum2($arr);\n\techo $arraySumHelper-&gt;getSum3($arr);\n\techo $arraySumHelper-&gt;getSum4($arr);\n?&gt;</code>\n</div>\n<p>\n\tВот еще пример - найдем сумму квадратов элементов\n\tмассива и сумму кубов и сложим результат вместе:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arraySumHelper = new ArraySumHelper;\n\t\n\t$arr = [1, 2, 3];\n\techo $arraySumHelper-&gt;getSum2($arr) + $arraySumHelper-&gt;getSum3($arr);\n?&gt;</code>\n</div>\n<p>\n\tФактически мы получаем набор функций, просто\n\tсгруппированных в одном классе. Однако, в\n\tотличие от обычного набора функций, мы можем\n\tпользоваться преимуществами ООП - например,\n\tделать вспомогательные методы приватными,\n\tчтобы они не были доступны извне класса.\n</p>\n<p>\n\tДавайте приступим к написанию кода нашего класса.\n</p>\n<p>\n\tЕсли обдумать реализацию методов, то становится\n\tочевидно, что они будут фактически одинаковыми,\n\tотличие будет только в степени, в которую\n\tбудут возводится элементы нашего массива.\n\tВот код, иллюстрирующий это:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass ArraySumHelper\n\t{\n\t\tpublic function getSum1($arr)\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($arr as $elem) {\n\t\t\t\t$sum += $elem; // первая степень элемента - это сам элемент\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t\t\n\t\tpublic function getSum2($arr)\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($arr as $elem) {\n\t\t\t\t$sum += pow($elem, 2); // возведем во вторую степень\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t\t\n\t\tpublic function getSum3($arr)\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($arr as $elem) {\n\t\t\t\t$sum += pow($elem, 3); // возведем в третью степень\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t\t\n\t\tpublic function getSum4($arr)\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($arr as $elem) {\n\t\t\t\t$sum += pow($elem, 4); // возведем в четвертую степень\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВместо того, чтобы реализовывать каждый метод\n\tзаново, давайте лучше сделаем вспомогательный\n\tприватный метод <code class=\"code inline\">getSum</code>, который параметрами\n\tбудет принимать массив и степень и возвращать\n\tсумму степеней элементов массива:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tprivate function getSum($arr, $power) {\n\t\t$sum = 0;\n\t\t\t\n\t\tforeach ($arr as $elem) {\n\t\t\t$sum += pow($elem, $power);\n\t\t}\n\t\t\n\t\treturn $sum;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте поменяем методы нашего класса с использованием\n\tнового метода <code class=\"code inline\">getSum</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass ArraySumHelper\n\t{\n\t\tpublic function getSum1($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 1);\n\t\t}\n\t\t\n\t\tpublic function getSum2($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 2);\n\t\t}\n\t\t\n\t\tpublic function getSum3($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 3);\n\t\t}\n\t\t\n\t\tpublic function getSum4($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 4);\n\t\t}\n\t\t\n\t\tprivate function getSum($arr, $power) {\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($arr as $elem) {\n\t\t\t\t$sum += pow($elem, $power);\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tНаш класс <code class=\"code inline\">ArraySumHelper</code> больше учебный,\n\tчем реальный, но тут вам важно понять принцип\n\t- то, что часто некоторый класс может использоваться\n\tпросто как набор методов и при этом создается\n\tтолько один объект класса. В дальнейшем мы\n\tбудем разбирать более жизненные (но и более\n\tсложные) примеры.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tНапишите реализацию методов класса <code class=\"code inline\">ArrayAvgHelper</code>,\n\t\tзаготовки методов которого расположены ниже:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass ArraySumHelper\n\t{\n\t\t/*\n\t\t\tНаходит сумму первых\n\t\t\tстепеней элементов массива:\n\t\t*/\n\t\tpublic function getAvg1($arr)\n\t\t{\n\t\t\n\t\t}\n\t\t\n\t\t/*\n\t\t\tНаходит сумму вторых степеней\n\t\t\tэлементов массива и извлекает\n\t\t\tиз нее квадратный корень:\n\t\t*/\n\t\tpublic function getAvg2($arr)\n\t\t{\n\t\t\n\t\t}\n\t\t\n\t\t/*\n\t\t\tНаходит сумму третьих степеней\n\t\t\tэлементов массива и извлекает\n\t\t\tиз нее кубический корень:\n\t\t*/\n\t\tpublic function getAvg3($arr)\n\t\t{\n\t\t\n\t\t}\n\t\t\n\t\t/*\n\t\t\tНаходит сумму четвертых степеней\n\t\t\tэлементов массива и извлекает\n\t\t\tиз нее корень четвертой степени:\n\t\t*/\n\t\tpublic function getAvg4($arr)\n\t\t{\n\t\t\n\t\t}\n\t\t\n\t\t/*\n\t\t\tВспомогательный метод, который параметром\n\t\t\tпринимает массив и степень и возвращает\n\t\t\tсумму степеней элементов массива:\n\t\t*/\n\t\tprivate function getSum($arr, $power)\n\t\t{\n\t\t\n\t\t}\n\t\t\n\t\t/*\n\t\t\tВспомогательный метод, который параметром\n\t\t\tпринимает целое число и степень и возвращает\n\t\t\tкорень заданной степени из числа:\n\t\t*/\n\t\tprivate function calcSqrt($num, $power)\n\t\t{\n\t\t\n\t\t}\n\t}\n?&gt;</code>\n\t</div>\n\t<p class=\"comment\">\n\t\tМатематическая подсказка: корень первой степени - это само число.\n\t\tТо есть <code class=\"code inline\">calcSqrt(число, 1)</code> должно просто вернуть само число.\n\t</p>\n\t<p class=\"comment\">\n\t\tА корень любой степени можно найти с помощью\n\t\tфункции <code class=\"code inline\">pow</code>, просто параметром передав ей дробь.\n\t\tНапример, <code class=\"code inline\">pow(число, 1/3)</code> - так найдем корень третьей степени.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/classes-inheritance/","content":"\n\t\t\t\t<h1>Наследование классов</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПредставьте, что у вас есть класс <code class=\"code inline\">User</code>.\n\tОн нужен вам для каких-то целей и в общем-то\n\tполностью вас устраивает - доработки этому\n\tклассу в не нужны.\n</p>\n<p>\n\tВот этот класс:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function setName($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tА теперь представим себе ситуацию, когда\n\tнам понадобился еще и класс <code class=\"code inline\">Employee</code>.\n\tРаботник очень похож на юзера, имеет те же\n\tсвойства и методы, но еще и добавляет свои\n\t- свойство <code class=\"code inline\">salary</code>, а также геттер\n\tи сеттер для этого свойства. Вот этот класс:\n</p>\n<div class=\"block\" data-file=\"Employee.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Employee\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\tprivate $salary; // зарплата\n\t\t\n\t\t// Геттер зарплаты\n\t\tpublic function getSalary()\n\t\t{\n\t\t\treturn $this-&gt;salary;\n\t\t}\n\t\t\n\t\t// Сеттер зарплаты\n\t\tpublic function setSalary($salary)\n\t\t{\n\t\t\t$this-&gt;salary = $salary;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\tpublic function setName($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак мы видим, код классов <code class=\"code inline\">User</code> и <code class=\"code inline\">Employee</code>\n\tпрактически полностью совпадает. Было бы\n\tнамного лучше сделать так, чтобы общая часть\n\tбыла записана только в одном месте.\n</p>\n<p>\n\tДля решения проблемы существует такая вещь,\n\tкак <dfn>наследование</dfn>. С помощью наследования\n\tмы можем заставить наш класс <code class=\"code inline\">Employee</code>\n\tпозаимствовать (<dfn>унаследовать</dfn>) методы\n\tи свойства класса <code class=\"code inline\">User</code> и просто дополнить\n\tих своими методами и свойствами.\n</p>\n<p>\n\tКласс, от которого наследуют называется <dfn>родителем</dfn>\n\t(<span class=\"translate-prefix\">англ.</span> <span class=\"translate-en\">parent</span>), а класс, который\n\tнаследует - <dfn>потомком</dfn>. Класс-потомок\n\tнаследует только публичные методы и свойства,\n\tно не приватные.\n</p>\n<p>\n\tНаследование реализуется с помощью ключевого\n\tслова <code class=\"code inline\">extends</code> (переводится как <span class=\"translate-ru\">расширяет</span>).\n\tПерепишем наш класс <code class=\"code inline\">Employee</code> так,\n\tчтобы он наследовал от <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"Employee.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Employee extends User\n\t{\n\t\tprivate $salary;\n\t\t\n\t\tpublic function getSalary()\n\t\t{\n\t\t\treturn $this-&gt;salary;\n\t\t}\n\t\t\n\t\tpublic function setSalary($salary)\n\t\t{\n\t\t\t$this-&gt;salary = $salary;\n\t\t}\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нового класса <code class=\"code inline\">Employee</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$employee = new Employee;\n\t\n\t$employee-&gt;setSalary(1000); // метод класса Employee\n\t$employee-&gt;setName('john'); // метод унаследован от родителя\n\t$employee-&gt;setAge(25); // метод унаследован от родителя\n\t\n\techo $employee-&gt;getSalary(); // метод класса Employee\n\techo $employee-&gt;getName(); // метод унаследован от родителя\n\techo $employee-&gt;getAge(); // метод унаследован от родителя\n?&gt;</code>\n</div>\n<div class=\"notice\">\n\t<p>\n\t\tКласс-потомок не унаследовал от своего родителя\n\t\tприватные свойства <code class=\"code inline\">name</code> и <code class=\"code inline\">age</code>\n\t\t- попытка обратится к ним вызовет ошибку.\n\t\tПри этом, однако, в классе-потомке доступны\n\t\tгеттеры и сеттеры этих свойств, так как эти\n\t\tгеттеры и сеттеры являются публичными.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код реализуйте такие\n\t\tже классы <code class=\"code inline\">User</code>, <code class=\"code inline\">Employee</code>.\n\t</p>\n</div>\n\n<h2>Несколько потомков</h2>\n<p>\n\tПреимущества наследования в том, что каждый\n\tкласс может несколько потомков. Давайте посмотрим\n\tна примере. Пусть кроме работника нам нужен\n\tеще и класс <code class=\"code inline\">Student</code> - давайте также\n\tунаследуем его от <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $course; // курс\n\t\t\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t\t\n\t\tpublic function setCourse($course)\n\t\t{\n\t\t\t$this-&gt;course = $course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нашего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student;\n\t\n\t$student-&gt;setCourse(3); // метод класса Student\n\t$student-&gt;setName('john'); // метод унаследован от родителя\n\t$student-&gt;setAge(25); // метод унаследован от родителя\n\t\n\techo $student-&gt;getCourse(); // метод класса Student\n\techo $student-&gt;getName(); // метод унаследован от родителя\n\techo $student-&gt;getAge(); // метод унаследован от родителя\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код реализуйте такой\n\t\tже класс <code class=\"code inline\">Student</code>, наследующий от класса\n\t\t<code class=\"code inline\">User</code>.\n\t</p>\n</div>\n\n<h2>Наследование от наследников</h2>\n<p>\n\tПусть у нас есть класс-родитель и класс-потомок.\n\tОт этого потомка также могут наследовать\n\tдругие классы, от его потомков другие и так\n\tдалее. Для примера пусть от класса <code class=\"code inline\">User</code>\n\tнаследует <code class=\"code inline\">Student</code>, а от него в свою\n\tочередь наследует класс <code class=\"code inline\">StudentBSU</code>:\n</p>\n<div class=\"block\" data-file=\"StudentBSU.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass StudentBSU extends Student\n\t{\n\t\t// добавляем свои свойства и методы\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Programmer</code>, который\n\t\tбудет наследовать от класса <code class=\"code inline\">Employee</code>.\n\t\tПусть новый класс имеет свойство <code class=\"code inline\">langs</code>,\n\t\tв котором будет хранится массив языков, которыми\n\t\tвладеет программист. Сделайте также геттер\n\t\tи сеттер для этого свойства.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\t<span class=\"-task-\"></span> Сделайте класс\n\t\t<code class=\"code inline\">Driver</code> (<span class=\"translate-ru\">водитель</span>), который\n\t\tбудет наследовать от класса <code class=\"code inline\">Employee</code>.\n\t\tПусть новый класс добавляет следующие свойства:\n\t\tводительский стаж, категория вождения (A,\n\t\tB, C, D), а также геттеры и сеттеры к ним.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/access-modifier-protected/","content":"\n\t\t\t\t<h1>Модификатор доступа protected в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tКак вы уже знаете, приватные свойства и методы\n\tне наследуются. Если вы хотите, чтобы метод\n\tили свойство появились у потомка, вы должны\n\tобъявить их как <code class=\"code inline\">public</code>. Проблема,\n\tоднако, в том, что публичные методы будут\n\tтакже доступны и извне класса, а мы бы этого\n\tне хотели.\n</p>\n<p>\n\tДругими словами, мы хотели бы, чтобы некоторые\n\tметоды или свойства родителя наследовались\n\tпотомками, но при этом для всего остального\n\tмира вели себя как приватные.\n</p>\n<p>\n\tДля решения этой проблемы существует специальный\n\tмодификатор <code class=\"code inline\">protected</code>, который и реализует\n\tописанное. Давайте изучим его работу на реальном\n\tпримере. Пусть у нас дан вот такой класс\n\t<code class=\"code inline\">User</code> с приватными свойствами <code class=\"code inline\">name</code>\n\tи <code class=\"code inline\">age</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function setName($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть от класса <code class=\"code inline\">User</code> наследует класс\n\t<code class=\"code inline\">Student</code>:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $course;\n\t\t\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t\t\n\t\tpublic function setCourse($course)\n\t\t{\n\t\t\t$this-&gt;course = $course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПока все отлично и все работает.\n</p>\n<p>\n\tПусть теперь мы решили в классе <code class=\"code inline\">Student</code>\n\tсделать метод <code class=\"code inline\">addOneYear</code>, который\n\tбудет добавлять <code class=\"number inline\">1</code> год к свойству <code class=\"code inline\">age</code>.\n\tДавайте реализуем указанный метод:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $course;\n\t\t\n\t\t// Реализуем этот метод:\n\t\tpublic function addOneYear()\n\t\t{\n\t\t\t$this-&gt;age++;\n\t\t}\n\t\t\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t\t\n\t\tpublic function setCourse($course)\n\t\t{\n\t\t\t$this-&gt;course = $course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроблема в том, что если оставить свойство\n\t<code class=\"code inline\">age</code> приватным, то мы не сможем обратится\n\tк нему в классе-потомке - это выдаст ошибку\n\tпри попытке вызова метода <code class=\"code inline\">addOneYear</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student();\n\t\n\t$student-&gt;setAge(25);\n\t$student-&gt;addOneYear(); // выдаст ошибку\n?&gt;</code>\n</div>\n<p>\n\tДля исправления ошибки поправим класс <code class=\"code inline\">User</code>\n\t- объявим свойство <code class=\"code inline\">age</code> как <code class=\"code inline\">protected</code>,\n\tа не как <code class=\"code inline\">private</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprotected $age; // объявим свойство как protected\n\t\t...\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТеперь метод <code class=\"code inline\">addOneYear</code> потомка сможет\n\tменять свойство <code class=\"code inline\">age</code>, но оно по-прежнему\n\tне будет доступно извне наших классов. Проверим\n\tработу класса <code class=\"code inline\">Student</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student();\n\t\n\t$student-&gt;setName('john'); // установим имя\n\t$student-&gt;setCourse(3);    // установим курс\n\t$student-&gt;setAge(25);      // установим возраст в 25\n\t\n\t$student-&gt;addOneYear();    // увеличим возраст на единицу\n\techo $student-&gt;getAge();   // выведет 26\n?&gt;</code>\n</div>\n<p>\n\tПопытка обратится к свойству <code class=\"code inline\">age</code> снаружи\n\tкласса выдаст ошибку, как нам и нужно:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student();\n\t$student-&gt;age = 30; // выдаст ошибку\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте мой код класса <code class=\"code inline\">User</code>. Самостоятельно\n\t\tне подсматривая в мой код реализуйте описанный\n\t\tкласс <code class=\"code inline\">Student</code> с методами <code class=\"code inline\">getCourse</code>,\n\t\t<code class=\"code inline\">setCourse</code> и <code class=\"code inline\">addOneYear</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/overriding-of-parent-methods/","content":"\n\t\t\t\t<h1>Перезапись методов родителя в классе потомке</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть дан класс <code class=\"code inline\">User</code> с приватными\n\tсвойствами <code class=\"code inline\">name</code> и <code class=\"code inline\">age</code>, а также\n\tгеттерами и сеттерами этих свойств. При этом\n\tв сеттере возраста выполняется проверка возраста\n\tна то, что он равен или больше <code class=\"number inline\">18</code> лет:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function setName($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\tif ($age &gt;= 18) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tОт класса <code class=\"code inline\">User</code> наследует класс <code class=\"code inline\">Student</code>\n\tс приватным свойством <code class=\"code inline\">course</code>, его\n\tгеттером и сеттером:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $course;\n\t\t\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t\t\n\t\tpublic function setCourse($course)\n\t\t{\n\t\t\t$this-&gt;course = $course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПредположим теперь, что метод <code class=\"code inline\">setAge</code>,\n\tкоторый <code class=\"code inline\">Student</code> наследует от <code class=\"code inline\">User</code>\n\tнам чем-то не подходит, например, нам нужна\n\tтакже проверка того, что возраст студента\n\tдо <code class=\"number inline\">25</code> лет.\n</p>\n<p>\n\tТо есть проверка на то, что возраст более\n\t<code class=\"number inline\">18</code> лет нас устраивает, но хотелось\n\tбы иметь добавочную проверку на то, что он\n\tменьше <code class=\"number inline\">25</code>.\n</p>\n<p>\n\tДля решения проблемы мы используем то, что\n\tв PHP в классе-потомке разрешено сделать\n\tметод с таким же именем, как и у родителя,\n\tтаким образом переопределив этот метод родителя\n\tна свой.\n</p>\n<p>\n\tКак раз то, что нам нужно.\n</p>\n<p>\n\tИтак, давайте напишем свой <code class=\"code inline\">setAge</code>\n\tв классе <code class=\"code inline\">Student</code>. Наш метод будет\n\tпроверять то, что возраст студента\n\tот <code class=\"number inline\">18</code> до <code class=\"number inline\">25</code> лет:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $course;\n\t\t\n\t\t// Перезаписываем метод родителя:\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\tif ($age &gt;= 18 and $age &lt;= 25) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t\t\n\t\tpublic function setCourse($course)\n\t\t{\n\t\t\t$this-&gt;course = $course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТак как наш метод <code class=\"code inline\">setAge</code> использует\n\tсвойство <code class=\"code inline\">age</code> от родителя, то в родителе\n\tэто свойство надо объявить как защищенное:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprotected $age; // изменим модификатор доступа на protected\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function setName($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\tif ($age &gt;= 18) {\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте проверим работу переопределенного\n\tметода <code class=\"code inline\">setAge</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student;\n\t\n\t$student-&gt;setAge(24);    // укажем корректный возраст\n\techo $student-&gt;getAge(); // выведет 24 - возраст поменялся\n\t\n\t$student-&gt;setAge(30);    // укажем некорректный возраст\n\techo $student-&gt;getAge(); // выведет 24 - возраст не поменялся\n?&gt;</code>\n</div>\n\n<h2>Работа с parent</h2>\n<p>\n\tСейчас в нашем новом методе <code class=\"code inline\">setAge</code>\n\tмы выполняем проверку того, что возраст от\n\t<code class=\"number inline\">18</code> до <code class=\"number inline\">25</code> лет. Однако, проверку,\n\tтого, что возраст от <code class=\"number inline\">18</code> лет выполняет\n\tи метод <code class=\"code inline\">setAge</code> родителя. Это значит,\n\tчто если мы захотим изменить нижнюю границу\n\tвозраста - нам придется сделать это в двух\n\tместах: в коде класса родителя и в коде класса\n\tпотомка.\n</p>\n<p>\n\tБыло бы удобно, если мы метод <code class=\"code inline\">setAge</code>\n\tпотомка мог использовать метод <code class=\"code inline\">setAge</code>\n\tот родителя, ведь в методе родителя расположена\n\tчасть кода, которая нам подходит и мы не\n\tхотим ее дублировать в методе потомка.\n</p>\n<p>\n\tТакое можно сделать с помощью ключевого слова\n\t<code class=\"code inline\">parent</code>, указывающего на родителя.\n\tС его помощью к переопределенному методу\n\tродителя можно обратиться так: <code class=\"code inline\">parent::setAge()</code>,\n\tто есть ключевое слово <code class=\"code inline\">parent</code>, затем\n\tдва двоеточия и сам метод.\n</p>\n<p>\n\tДавайте доработаем наш класс <code class=\"code inline\">Student</code>\n\tтак, чтобы использовался метод <code class=\"code inline\">setAge</code>\n\tродителя:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $course;\n\t\t\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\t// Если возраст меньше или равен 25:\n\t\t\tif ($age &lt;= 25) {\n\t\t\t\t// Вызываем метод родителя:\n\t\t\t\tparent::setAge($age); // в родителе выполняется проверка age &gt;= 18\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t\t\n\t\tpublic function setCourse($course)\n\t\t{\n\t\t\t$this-&gt;course = $course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tМы добились того, что хотели. Более того,\n\tтеперь метод <code class=\"code inline\">setAge</code> потомка не использует\n\tсвойство <code class=\"code inline\">age</code> напрямую. Это значит,\n\tчто в классе-родителе можно поменять его\n\tмодификатор доступа с <code class=\"code inline\">protected</code> обратно\n\tна <code class=\"code inline\">private</code>.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tМодифицируйте код класса <code class=\"code inline\">User</code> так,\n\t\tчтобы в методе <code class=\"code inline\">setName</code> выполнялась\n\t\tпроверка того, что длина имени более <code class=\"number inline\">3</code>-х\n\t\tсимволов.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в класс <code class=\"code inline\">Student</code> метод <code class=\"code inline\">setName</code>,\n\t\tв котором будет выполняться проверка того,\n\t\tчто длина имени более <code class=\"number inline\">3</code>-х символов\n\t\tи менее <code class=\"number inline\">10</code> символов. Пусть этот метод\n\t\tиспользует метод <code class=\"code inline\">setName</code> своего родителя,\n\t\tчтобы выполнить часть проверки.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/parent-constructor-overriding/","content":"\n\t\t\t\t<h1>Перезапись конструктора родителя в потомке</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас есть вот такой класс <code class=\"code inline\">User</code>,\n\tу которого свойства <code class=\"code inline\">name</code> и <code class=\"code inline\">age</code>\n\tзадаются в конструкторе и в дальнейшем доступны\n\tтолько для чтения (то есть приватные и имеют\n\tтолько геттеры, но не сеттеры):\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tОт этого класса наследует класс <code class=\"code inline\">Student</code>:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $course;\n\t\t\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКласс-потомок не имеет своего конструктора\n\t- это значит что при создании объекта класса\n\tсработает конструктор родителя:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student('john', 19); // сработает конструктор родителя\n\t\n\techo $student-&gt;getName(); // выведет 'john'\n\techo $student-&gt;getAge();  // выведет 19\n?&gt;</code>\n</div>\n<p>\n\tВсе замечательно, но есть проблема: мы бы\n\tхотели при создании объекта класса <code class=\"code inline\">Student</code>\n\tтретьим параметром передавать еще и курс, вот так:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student('john', 19, 2); // это пока не работает\n?&gt;</code>\n</div>\n<p>\n\tСамое простое, что можно сделать, это переопределить\n\tконструктор родителя своим конструктором,\n\tзабрав из родителя его код:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $course;\n\t\t\n\t\t// Конструктор объекта:\n\t\tpublic function __construct($name, $age, $course)\n\t\t{\n\t\t\t// Дублируем код конструктора родителя:\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t\t\n\t\t\t// Наш код:\n\t\t\t$this-&gt;course = $course;\n\t\t}\n\t\t\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПри этом мы в классе потомке обращаемся к\n\tприватным свойствам родителя <code class=\"code inline\">name</code>\n\tи <code class=\"code inline\">age</code>, что, конечно же, не будет работать\n\tтак, как нам нужно. Переделаем их на <code class=\"code inline\">protected</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprotected $name; // объявим свойство защищенным\n\t\tprotected $age;  // объявим свойство защищенным\n\t\t\n\t\t// Конструктор объекта:\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТеперь при создании студента третьим параметром\n\tмы можем передать и курс:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student('john', 19, 2); // теперь это работает\n\t\n\techo $student-&gt;getName();   // выведет 'john'\n\techo $student-&gt;getAge();    // выведет 19\n\techo $student-&gt;getCourse(); // выведет 2\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код реализуйте такой\n\t\tже класс <code class=\"code inline\">Student</code>, наследующий от <code class=\"code inline\">User</code>.\n\t</p>\n</div>\n\n<h2>Используем конструктор родителя</h2>\n<p>\n\tПонятно, что дублирование кода родителя в\n\tклассе потомке - это не очень хорошо. Давайте\n\tвместо дублирования кода в конструкторе потомка\n\tвызовем конструктор родителя.\n</p>\n<p>\n\tДля полной ясности распишу все по шагам.\n\tВот так выглядит конструктор класса <code class=\"code inline\">User</code>,\n\tон принимает два параметра <code class=\"code inline\">$name</code> и\n\t<code class=\"code inline\">$age</code> и записывает их в соответствующие\n\tсвойства:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Конструктор объекта класса User:\n\tpublic function __construct($name, $age)\n\t{\n\t\t$this-&gt;name = $name;\n\t\t$this-&gt;age  = $age;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВот конструктор класса <code class=\"code inline\">Student</code>, который\n\tмы хотим переписать:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Конструктор объекта класса Student:\n\tpublic function __construct($name, $age, $course)\n\t{\n\t\t// Этот код хотим заменить на вызов конструктора родителя:\n\t\t$this-&gt;name = $name;\n\t\t$this-&gt;age  = $age;\n\t\t\n\t\t// Наш код:\n\t\t$this-&gt;course = $course;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКонструктор родителя можно вызвать внутри\n\tпотомка с помощью <code class=\"code inline\">parent</code>. При этом\n\tконструктор родителя первым параметром ожидает\n\tимя, а вторым - возраст, и мы должны ему\n\tих передать, вот так:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Конструктор объекта класса Student:\n\tpublic function __construct($name, $age, $course)\n\t{\n\t\t// Вызовем конструктор родителя, передав ему два параметра:\n\t\tparent::__construct($name, $age);\n\t\t\t\n\t\t// Запишем свойство course:\n\t\t$this-&gt;course = $course;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tНапишем полный код класса <code class=\"code inline\">Student</code>:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $course;\n\t\t\n\t\t// Конструктор объекта:\n\t\tpublic function __construct($name, $age, $course)\n\t\t{\n\t\t\tparent::__construct($name, $age); // вызываем конструктор родителя\n\t\t\t$this-&gt;course = $course;\n\t\t}\n\t\t\n\t\tpublic function getCourse()\n\t\t{\n\t\t\treturn $this-&gt;course;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим, что все работает:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$student = new Student('john', 19, 2);\n\t\n\techo $student-&gt;getName();   // выведет 'john'\n\techo $student-&gt;getAge();    // выведет 19\n\techo $student-&gt;getCourse(); // выведет 2\n?&gt;</code>\n</div>\n<p>\n\tТак как класс <code class=\"code inline\">Student</code> теперь не обращается\n\tнапрямую к свойствам <code class=\"code inline\">name</code> и <code class=\"code inline\">age</code>\n\tродителя, можно их опять сделать приватными:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name; // объявим свойство приватным\n\t\tprivate $age;  // объявим свойство приватным\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age  = $age;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">User</code>, в котором будут\n\t\tследующие свойства только для чтения: <code class=\"code inline\">name</code>\n\t\tи <code class=\"code inline\">surname</code>. Начальные значения этих\n\t\tсвойств должны устанавливаться в конструкторе.\n\t\tСделайте также геттеры этих свойств.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tМодифицируйте предыдущую задачу так, чтобы\n\t\tтретьим параметром в конструктор передавалась\n\t\tдата рождения работника в формате <i>год-месяц-день</i>.\n\t\tЗапишите ее в свойство <code class=\"code inline\">birthday</code>. Сделайте геттер\n\t\tдля этого свойства.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tМодифицируйте предыдущую задачу так, чтобы\n\t\tбыл приватный метод <code class=\"code inline\">calculateAge</code>,\n\t\tкоторый параметром будет принимать дату рождения,\n\t\tа возвращать возраст с учетом того, был ли\n\t\tуже день рождения в этом году, или нет.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tМодифицируйте предыдущую задачу так, чтобы\n\t\tметод <code class=\"code inline\">calculateAge</code>\n\t\tвызывался в конструкторе объекта, рассчитывал\n\t\tвозраст пользователя и записывал его в приватное\n\t\tсвойство <code class=\"code inline\">age</code>. Сделайте геттер для\n\t\tэтого свойства.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code>, который будет\n\t\tнаследовать от класса <code class=\"code inline\">User</code>. Пусть\n\t\tновый класс имеет свойство <code class=\"code inline\">salary</code>,\n\t\tв котором будет хранится зарплата работника.\n\t\tЗарплата должна передаваться четвертым параметром\n\t\tв конструктор объекта. Сделайте также геттер\n\t\tдля этого свойства.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/passing-objects-by-reference/","content":"\n\t\t\t\t<h1>Передача объектов по ссылке</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас дан вот такой класс <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\tpublic $age;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age  = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть мы создаем объект этого класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 30);\n?&gt;</code>\n</div>\n<p>\n\tПредставьте теперь следующую ситуацию: вы\n\tхотите значение переменной <code class=\"code inline\">$user</code> присвоить\n\tкакой-нибудь другой переменной, например\n\t<code class=\"code inline\">$test</code>.\n</p>\n<p>\n\tЕсли речь шла не об объектах, а о <dfn>примитивах</dfn>,\n\tто есть о строках, числах, массивах и тп,\n\tто в переменную <code class=\"code inline\">$test</code> попала бы копия\n\tзначения переменной <code class=\"code inline\">$user</code>.\n</p>\n<p>\n\tЭто значит, что изменения любой из переменной\n\tв дальнейшем не меняли бы значение другой\n\tпеременной. Посмотрим на примере:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = 1;\n\t\n\t$test = $user; // в переменной $test теперь 1\n\t$test = 2;     // в переменной $test теперь 2, а в $user - по-прежнему 1\n?&gt;</code>\n</div>\n<p>\n\tС объектами все по-другому - при записи в\n\tдругую переменную объекты не копируются,\n\tа передаются <dfn>по ссылке</dfn>: это значит,\n\tчто обе эти переменные значением имеют один\n\tи тот же объект. Это имеет важное следствие:\n\tесли поменять какие-то свойства объекта с\n\tпомощью одной переменной, во второй переменной\n\tпоявятся эти же изменения:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 30);\n\t\n\t$test = $user; // и $test, и $user ссылаются на один и тот же объект\n\t$test-&gt;name = 'eric'; // поменяли переменную $test - но $user также поменялась!\n\t\n\t// Проверим - выведем свойство name из переменной $user:\n\techo $user-&gt;name; // выведет 'eric'!\n?&gt;</code>\n</div>\n<p>\n\tУчтите, что речь идет именно об объектах.\n\tЕсли вы в какую-то переменную запишите данные\n\tиз свойства объекта - они скопируются, а\n\tне передадутся по ссылке:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 30);\n\t\n\t$name = $user-&gt;name; // запишем в переменную $name текст 'john'\n\t$name = 'eric'; // поменяли переменную $name, но $user-&gt;name не поменялось\n\t\n\t// Проверим - выведем свойство name из переменной $user:\n\techo $user-&gt;name; // выведет 'john'\n?&gt;</code>\n</div>\n<p>\n\tЕсли перезаписать переменную с объектом на\n\tпримитив, то объект не исчезнет из другой\n\tпеременной:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 30);\n\t\n\t$test = $user; // и $test, и $user ссылаются на один и тот же объект\n\t$user = 123;   // теперь $test ссылается, а $user - нет\n?&gt;</code>\n</div>\n<p>\n\tОбъект существует в памяти компьютера до\n\tтех пор, пока на него ссылается хоть кто-нибудь.\n\tВ примере выше, если что-нибудь записать\n\tи в переменную <code class=\"code inline\">$user</code> - на наш объект\n\tбольше не будет ссылаться ни одна переменная\n\tи этот объект удалится из памяти.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Product</code>, в котором\n\t\tбудут следующие свойства: <code class=\"code inline\">name</code>, <code class=\"code inline\">price</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте объект класса <code class=\"code inline\">Product</code>, запишите\n\t\tего в переменную <code class=\"code inline\">$product1</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПрисвойте значение переменной <code class=\"code inline\">$product1</code>\n\t\tв переменную <code class=\"code inline\">$product2</code>. Проверьте\n\t\tто, что обе переменные ссылаются на один\n\t\tи тот же объект.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/using-objects-in-class/","content":"\n\t\t\t\t<h1>Использование классов внутри других классов</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tБывает такое, что мы хотели бы использовать\n\tметоды одного класса внутри другого, но не\n\tхотели бы наследовать от этого класса.\n</p>\n<p>\n\tПочему мы не хотим наследовать?\n</p>\n<p>\n\tВо-первых, используемый класс может являться\n\tвспомогательным и по логике нашего кода может\n\tне подходить на роль родителя.\n</p>\n<p>\n\tВо-вторых, мы можем захотеть использовать\n\tнесколько классов внутри другого класса,\n\tа с наследованием это не получится, ведь\n\tв PHP у класса может быть только один родитель.\n</p>\n<p>\n\tДавайте посмотрим на практическом примере.\n\tПусть у нас дан следующий класс <code class=\"code inline\">Arr</code>,\n\tв объект которого мы можем добавлять числа\n\tс помощью метода <code class=\"code inline\">add</code>:\n</p>\n<div class=\"block\" data-file=\"Arr.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\tprivate $nums = []; // массив чисел\n\t\t\n\t\t// Добавляем число в массив:\n\t\tpublic function add($num)\n\t\t{\n\t\t\t$this-&gt;nums[] = $num;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь добавим в наш класс метод,\n\tкоторый будет находить сумму квадратов элементов\n\tи прибавлять к ней сумму кубов элементов.\n</p>\n<p>\n\tПусть у нас уже существует класс <code class=\"code inline\">SumHelper</code>,\n\tимеющий методы для нахождения сумм элементов\n\tмассивов:\n</p>\n<div class=\"block\" data-file=\"SumHelper.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass SumHelper\n\t{\n\t\t// Сумма квадратов:\n\t\tpublic function getSum2($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 2);\n\t\t}\n\t\t\n\t\t// Сумма кубов:\n\t\tpublic function getSum3($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 3);\n\t\t}\n\t\t\n\t\t// Вспомогательная функция для нахождения суммы:\n\t\tprivate function getSum($arr, $power) {\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($arr as $elem) {\n\t\t\t\t$sum += pow($elem, $power);\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tЛогично будет не реализовывать нужные нам\n\tметоды еще раз в классе <code class=\"code inline\">Arr</code>, а воспользоваться\n\tметодами класса <code class=\"code inline\">SumHelper</code> внутри класса\n\t<code class=\"code inline\">Arr</code>.\n</p>\n<p>\n\tДля этого в классе <code class=\"code inline\">Arr</code> внутри конструктора\n\tсоздадим объект класса <code class=\"code inline\">SumHelper</code> и\n\tзапишем его в свойство <code class=\"code inline\">sumHelper</code>:\n</p>\n<div class=\"block\" data-file=\"Arr.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\tprivate $nums = []; // массив чисел\n\t\tprivate $sumHelper; // сюда запишется объект класса SumHelper\n\t\t\n\t\t// Конструктор класса:\n\t\tpublic function __construct()\n\t\t{\n\t\t\t// Запишем объект вспомогательного класса в свойство:\n\t\t\t$this-&gt;sumHelper = new SumHelper;\n\t\t}\n\t\t\n\t\t// Добавляем число в массив:\n\t\tpublic function add($num)\n\t\t{\n\t\t\t$this-&gt;nums[] = $num;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТеперь внутри <code class=\"code inline\">Arr</code> доступно свойство\n\t<code class=\"code inline\">$this->sumHelper</code>, в котором хранится\n\tобъект класса <code class=\"code inline\">SumHelper</code> с его публичными\n\tметодами и свойствами (если бы публичные\n\tсвойства были, сейчас их там нет, только\n\tпубличные методы).\n</p>\n<p>\n\tСоздадим теперь в классе <code class=\"code inline\">Arr</code> метод\n\t<code class=\"code inline\">getSum23</code>, который будет находить сумму\n\tквадратов элементов и прибавлять к ней сумму\n\tкубов элементов, используя методы класса\n\t<code class=\"code inline\">SumHelper</code>:\n</p>\n<div class=\"block\" data-file=\"Arr.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\tprivate $nums = [];\n\t\tprivate $sumHelper;\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;sumHelper = new SumHelper;\n\t\t}\n\t\t\n\t\t// Находим сумму квадратов и кубов элементов массива:\n\t\tpublic function getSum23()\n\t\t{\n\t\t\t// Для краткости запишем $this-&gt;nums в переменную:\n\t\t\t$nums = $this-&gt;nums;\n\t\t\t\n\t\t\t// Найдем описанную сумму:\n\t\t\treturn $this-&gt;sumHelper-&gt;getSum2($nums) + $this-&gt;sumHelper-&gt;getSum3($nums);\n\t\t}\n\t\t\n\t\tpublic function add($number)\n\t\t{\n\t\t\t$this-&gt;nums[] = $number;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте воспользуемся созданным классом <code class=\"code inline\">Arr</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr(); // создаем объект\n\t\n\t$arr-&gt;add(1); // добавляем в массив число 1\n\t$arr-&gt;add(2); // добавляем в массив число 2\n\t$arr-&gt;add(3); // добавляем в массив число 3\n\t\n\t// Находим сумму квадратов и кубов:\n\techo $arr-&gt;getSum23();\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно повторите описанные мною классы\n\t\t<code class=\"code inline\">Arr</code> и <code class=\"code inline\">SumHelper</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте класс <code class=\"code inline\">AvgHelper</code> с методом\n\t\t<code class=\"code inline\">getAvg</code>, который параметром будет принимать\n\t\tмассив и возвращать среднее арифметическое\n\t\tэтого массива (сумма элементов делить на\n\t\tколичество).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в класс <code class=\"code inline\">AvgHelper</code> еще и метод\n\t\t<code class=\"code inline\">getMeanSquare</code>, который параметром\n\t\tбудет принимать массив и возвращать среднее\n\t\tквадратичное этого массива (квадратный корень,\n\t\tизвлеченный из суммы квадратов элементов,\n\t\tделенной на количество).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в класс <code class=\"code inline\">Arr</code> метод <code class=\"code inline\">getAvgMeanSum</code>,\n\t\tкоторый будет находить сумму среднего арифметического\n\t\tи среднего квадратичного из массива <code class=\"code inline\">$this->nums</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/passing-objects-by-parameter/","content":"\n\t\t\t\t<h1>Передача объектов параметрами</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас дан вот такой класс <code class=\"code inline\">Employee</code>:\n</p>\n<div class=\"block\" data-file=\"Employee.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Employee\n\t{\n\t\tprivate $name;\n\t\tprivate $salary;\n\t\t\n\t\tpublic function __construct($name, $salary)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;salary = $salary;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getSalary()\n\t\t{\n\t\t\treturn $this-&gt;salary;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем еще и класс <code class=\"code inline\">EmployeesCollection</code>,\n\tкоторый будет хранить массив работников,\n\tто есть массив объектов класса <code class=\"code inline\">Employee</code>.\n</p>\n<p>\n\tПусть работники будут храниться в свойстве\n\t<code class=\"code inline\">employees</code>, а для добавления работников\n\tбудет существовать метод <code class=\"code inline\">add</code>. Этот\n\tметод параметром будет принимать объект класса\n\t<code class=\"code inline\">Employee</code> и записывать его в конец\n\tмассива <code class=\"code inline\">$this->employees</code>:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass EmployeesCollection\n\t{\n\t\tprivate $employees = []; // массив работников, по умолчанию пустой\n\t\t\n\t\t// Добавляем нового работника:\n\t\tpublic function add($employee)\n\t\t{\n\t\t\t$this-&gt;employees[] = $employee; // $employee - объект класса Employee\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте также добавим в наш класс метод <code class=\"code inline\">getTotalSalary</code>,\n\tкоторый будет находить суммарную зарплату\n\tвсех хранящихся работников:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass EmployeesCollection\n\t{\n\t\tprivate $employees = [];\n\t\t\n\t\tpublic function add($employee)\n\t\t{\n\t\t\t$this-&gt;employees[] = $employee;\n\t\t}\n\t\t\n\t\t// Находим суммарную зарплату:\n\t\tpublic function getTotalSalary()\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\t// Перебираем работников циклом:\n\t\t\tforeach ($this-&gt;employees as $employee) {\n\t\t\t\t$sum += $employee-&gt;getSalary(); // получаем з/п работника через метод getSalary()\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте проверим работу класса <code class=\"code inline\">EmployeesCollection</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$employeesCollection = new EmployeesCollection;\n\t\n\t$employeesCollection-&gt;add(new Employee('john', 100));\n\t$employeesCollection-&gt;add(new Employee('eric', 200));\n\t$employeesCollection-&gt;add(new Employee('kyle', 300));\n\t\n\techo $employeesCollection-&gt;getTotalSalary(); // выведет 600\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем наш класс <code class=\"code inline\">EmployeesCollection</code>\n\tболее жизненным и добавим метод получения\n\tвсех работников и метод подсчета:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass EmployeesCollection\n\t{\n\t\tprivate $employees = [];\n\t\t\n\t\t// Получаем всех работников в виде массива:\n\t\tpublic function get()\n\t\t{\n\t\t\treturn $this-&gt;employees;\n\t\t}\n\t\t\n\t\t// Подсчитываем количество хранимых работников:\n\t\tpublic function count()\n\t\t{\n\t\t\treturn count($this-&gt;employees);\n\t\t}\n\t\t\n\t\tpublic function add($employee)\n\t\t{\n\t\t\t$this-&gt;employees[] = $employee;\n\t\t}\n\t\t\n\t\tpublic function getTotalSalary()\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($this-&gt;employees as $employee) {\n\t\t\t\t$sum += $employee-&gt;getSalary();\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Product</code>, в котором\n\t\tбудут приватные свойства <code class=\"code inline\">name</code>, <code class=\"code inline\">price</code>\n\t\tи <code class=\"code inline\">quantity</code>. Пусть все эти свойства\n\t\tбудут доступны только для чтения.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в класс <code class=\"code inline\">Product</code> метод <code class=\"code inline\">getCost</code>,\n\t\tкоторый будет находить полную стоимость продукта\n\t\t(сумма умножить на количество).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Cart</code>. Данный класс\n\t\tбудет хранить список продуктов (объектов\n\t\tкласса <code class=\"code inline\">Product</code>) в виде массива. Пусть\n\t\tпродукты хранятся в свойстве <code class=\"code inline\">products</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте в классе <code class=\"code inline\">Cart</code> метод <code class=\"code inline\">add</code>\n\t\tдля добавления продуктов.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте в классе <code class=\"code inline\">Cart</code> метод <code class=\"code inline\">remove</code>\n\t\tдля удаления продуктов. Метод должен принимать\n\t\tпараметром название удаляемого продукта.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте в классе <code class=\"code inline\">Cart</code> метод <code class=\"code inline\">getTotalCost</code>,\n\t\tкоторый будет находить суммарную стоимость\n\t\tпродуктов.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте в классе <code class=\"code inline\">Cart</code> метод <code class=\"code inline\">getTotalQuantity</code>,\n\t\tкоторый будет находить суммарное количество\n\t\tпродуктов (то есть сумму свойств <code class=\"code inline\">quantity</code>\n\t\tвсех продуктов).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте в классе <code class=\"code inline\">Cart</code> метод <code class=\"code inline\">getAvgPrice</code>,\n\t\tкоторый будет находить среднюю стоимость\n\t\tпродуктов (суммарная стоимость делить на\n\t\tколичество всех продуктов).\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/objects-comparison/","content":"\n\t\t\t\t<h1>Сравнение объектов в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами научимся сравнивать объекты\n\tс помощью операторов <code class=\"code inline\">==</code> и <code class=\"code inline\">===</code>.\n</p>\n<p>\n\tВы должны уже знать, что для примитивов (то\n\tесть не объектов) оператор <code class=\"code inline\">==</code> сравнивает\n\tданные по значению без учета типа, а оператор\n\t<code class=\"code inline\">===</code> - учитывая тип:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tvar_dump(3 == 3);    // выведет true\n\tvar_dump(3 == '3');  // выведет true\n\t\n\tvar_dump(3 === 3);   // выведет true\n\tvar_dump(3 === '3'); // выведет false\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь посмотрим, как работает сравнение\n\tобъектов.\n</p>\n<p>\n\tПри использовании оператора <code class=\"code inline\">==</code> для\n\tсравнения двух объектов выполняется сравнение\n\tсвойств объектов: два объекта равны, если\n\tони имеют одинаковые свойства и их значения\n\t(значения свойств сравниваются через ==)\n\tи являются экземплярами одного и того же класса.\n</p>\n<p>\n\tПри сравнении через <code class=\"code inline\">===</code>, переменные,\n\tсодержащие объекты, считаются равными только\n\tтогда, когда они ссылаются на один и тот\n\tже экземпляр одного и того же класса.\n</p>\n<p>\n\tДавайте посмотрим на примере. Пусть у нас\n\tдан вот такой класс <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age  = $age;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСоздадим два объекта нашего класса с одинаковыми\n\tзначениями свойств и сравним созданные объекты:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('john', 30);\n\t$user2 = new User('john', 30);\n\t\n\tvar_dump($user1 == $user2); // выведет true\n?&gt;</code>\n</div>\n<p>\n\tПусть теперь значения свойств одинаковые,\n\tно у них разный тип:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('john', 30); // возраст - число\n\t$user2 = new User('john', '30'); // возраст - строка\n\t\n\tvar_dump($user1 == $user2); // выведет true\n?&gt;</code>\n</div>\n<p>\n\tПусть значения свойств разные:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('john', 30);\n\t$user2 = new User('john', 25);\n\t\n\tvar_dump($user1 == $user2); // выведет false\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь сравним два наших объекта\n\tчерез <code class=\"code inline\">===</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('john', 30);\n\t$user2 = new User('john', 30);\n\t\n\tvar_dump($user1 === $user2); // выведет false\n?&gt;</code>\n</div>\n<p>\n\tЧтобы две переменных с объектами действительно\n\tбыли равными при сравнении через <code class=\"code inline\">===</code>,\n\tони должны указывать на один и тот же объект.\n\tДавайте сделаем, чтобы это было так, и сравним\n\tпеременные:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('john', 30);\n\t$user2 = $user1; // передача объекта по ссылке\n\t\n\tvar_dump($user1 === $user2); // выведет true\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте функцию <code class=\"code inline\">compare</code>, которая\n\t\tпараметром будет принимать два объекта и\n\t\tвозвращать <code class=\"code inline\">true</code>, если они имеют одинаковые\n\t\tсвойства и значения являются экземплярами\n\t\tодного и того же класса, и <code class=\"code inline\">false</code>,\n\t\tесли это не так.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте функцию <code class=\"code inline\">compare</code>, которая\n\t\tпараметром будет принимать два объекта и\n\t\tвозвращать <code class=\"code inline\">true</code>, если переданные переменные\n\t\tссылаются на один и тот же объект, и <code class=\"code inline\">false</code>,\n\t\tесли на разные.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте функцию <code class=\"code inline\">compare</code>, которая\n\t\tпараметром будет принимать два объекта и\n\t\tсравнивать их.\n\t</p>\n\t<p>\n\t\tФункция должна возвращать <code class=\"number inline\">1</code>, если\n\t\tпереданные переменные ссылаются на один и\n\t\tтот же объект.\n\t</p>\n\t<p>\n\t\tФункция должна возвращать <code class=\"number inline\">0</code>, если\n\t\tобъекты разные, но одного и того же класса\n\t\tи с теми же свойствами и их значениями.\n\t</p>\n\t<p>\n\t\tФункция должна возвращать <code class=\"number inline\">-1</code> в противном\n\t\tслучае.\n\t</p>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tДавайте рассмотрим применение изученной теории.\n\tПусть у нас дан вот такой класс <code class=\"code inline\">Employee</code>:\n</p>\n<div class=\"block\" data-file=\"Employee.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Employee\n\t{\n\t\tprivate $name;\n\t\tprivate $salary;\n\t\t\n\t\tpublic function __construct($name, $salary)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;salary = $salary;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getSalary()\n\t\t{\n\t\t\treturn $this-&gt;salary;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть также дан такой класс <code class=\"code inline\">EmployeesCollection</code>\n\tдля хранения коллекции работников:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass EmployeesCollection\n\t{\n\t\tprivate $employees = []; // массив работников\n\t\t\n\t\t// Добавляем нового работника:\n\t\tpublic function add($newEmployee)\n\t\t{\n\t\t\t$this-&gt;employees[] = $newEmployee;\n\t\t}\n\t\t\n\t\t// Получаем всех работников в виде массива:\n\t\tpublic function get()\n\t\t{\n\t\t\treturn $this-&gt;employees;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем так, чтобы работник, который\n\tуже есть в нашем наборе, не добавлялся еще\n\tраз. Для этого сделаем вспомогательный метод\n\t<code class=\"code inline\">exists</code>, который будет принимать объект\n\tс новым работником и проверять его наличие\n\tв массиве <code class=\"code inline\">$this->employees</code>:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tprivate function exists($newEmployee)\n\t{\n\t\tforeach ($this-&gt;employees as $employee) {\n\t\t\tif ($employee == $newEmployee) { // сравниваем через ==\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте применим новый метод в нашем классе:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass EmployeesCollection\n\t{\n\t\tprivate $employees = [];\n\t\t\n\t\tpublic function add($newEmployee)\n\t\t{\n\t\t\t// Если такого работника нет - то добавляем:\n\t\t\tif (!$this-&gt;exists($newEmployee)) {\n\t\t\t\t$this-&gt;employees[] = $newEmployee;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function get()\n\t\t{\n\t\t\treturn $this-&gt;employees;\n\t\t}\n\t\t\n\t\tprivate function exists($newEmployee)\n\t\t{\n\t\t\tforeach ($this-&gt;employees as $employee) {\n\t\t\t\tif ($employee == $newEmployee) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте проверим работу нашего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$employeesCollection = new EmployeesCollection;\n\t\n\t$employeesCollection-&gt;add(new Employee('john', 100));\n\t$employeesCollection-&gt;add(new Employee('john', 100)); // второго такого же не добавит\n\t\n\tvar_dump($employeesCollection-&gt;get()); // убедимся в этом\n?&gt;</code>\n</div>\n<p>\n\tВ общем-то, мы получили устраивающий нас\n\tкод. Но давайте попробуем поиграться с ним:\n\tпоменяем при сравнении двойное равно на тройное:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tprivate function exists($newEmployee)\n\t{\n\t\tforeach ($this-&gt;products as $product) {\n\t\t\tif ($product === $newEmployee) { // сравниваем через ===\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТеперь при попытке добавить нового работника\n\tс такими же значениями свойств он будет добавляться:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$employeesCollection = new EmployeesCollection;\n\t\n\t$employeesCollection-&gt;add(new Employee('john', 100));\n\t$employeesCollection-&gt;add(new Employee('john', 100)); // добавит\n\t\n\tvar_dump($employeesCollection-&gt;get());\n?&gt;</code>\n</div>\n<p>\n\tНо если попытаться добавить тот же объект,\n\tто добавления не произойдет:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$employeesCollection = new EmployeesCollection;\n\t\n\t$employee = new Employee('john', 100);\n\t\n\t$employeesCollection-&gt;add($employee);\n\t$employeesCollection-&gt;add($employee); // не добавит, тк тот же объект\n\t\n\tvar_dump($employeesCollection-&gt;get());\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте мой код класса <code class=\"code inline\">Employee</code>,\n\t\tзатем самостоятельно реализуйте описанный\n\t\tкласс <code class=\"code inline\">EmployeesCollection</code>, проверьте\n\t\tего работу.\n\t</p>\n</div>\n\n<h2>Функция in_array</h2>\n<p>\n\tНа самом деле код метода <code class=\"code inline\">exists</code> можно\n\tзаменить стандартной PHP функцией <code class=\"code inline\">in_array</code>.\n\tНужно только знать, как она выполняет сравнение\n\t- по двойному равно или по тройному.\n</p>\n<p>\n\tИз документации следует, что эта функция\n\tимеет третий необязательный параметр. Если\n\tон не установлен или равен <code class=\"code inline\">false</code> -\n\tфункция сравнивает по двойному равно, а равен\n\t<code class=\"code inline\">true</code> - то по тройному.\n</p>\n<p>\n\tДавайте упростим код класса при условии сравнения\n\tобъектов через двойное равно:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass EmployeesCollection\n\t{\n\t\tprivate $employees = [];\n\t\t\n\t\tpublic function add($newEmployee)\n\t\t{\n\t\t\tif (!in_array($newEmployee, $this-&gt;employees, false)) {\n\t\t\t\t$this-&gt;employees[] = $newEmployee;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function get()\n\t\t{\n\t\t\treturn $this-&gt;employees;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tА теперь при условии сравнения на тройное равно:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass EmployeesCollection\n\t{\n\t\tprivate $employees = [];\n\t\t\n\t\tpublic function add($newEmployee)\n\t\t{\n\t\t\t// Эквивалентно методу exists с ===\n\t\t\tif (!in_array($newEmployee, $this-&gt;employees, true)) {\n\t\t\t\t$this-&gt;employees[] = $newEmployee;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function get()\n\t\t{\n\t\t\treturn $this-&gt;employees;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tУпростите ваш класс <code class=\"code inline\">EmployeesCollection</code>\n\t\tс использованием функции <code class=\"code inline\">in_array</code>,\n\t\tпроверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/operator-instanceof/","content":"\n\t\t\t\t<h1>Определение принадлежности объекта к классу</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами изучим оператор <code class=\"code inline\">instanceof</code>.\n\tДанный оператор используется для определения\n\tтого, является ли текущий объект экземпляром\n\tуказанного класса.\n</p>\n<p>\n\tДавайте посмотрим на примере. Пусть у нас\n\tданы какие-то два класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Первый класс:\n\tclass Class1\n\t{\n\t\t\n\t}\n\t\n\t// Второй класс:\n\tclass Class2\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСоздадим объект первого класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$obj = new Class1;\n?&gt;</code>\n</div>\n<p>\n\tПроверим принадлежность объекта из переменной\n\t<code class=\"code inline\">$obj</code> первому классу и второму:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет true, тк объект принадлежит классу Class1:\n\tvar_dump($obj instanceof Class1);\n\t\n\t// Выведет false, тк объект НЕ принадлежит классу Class2:\n\tvar_dump($obj instanceof Class2);\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code> с публичными\n\t\tсвойствами <code class=\"code inline\">name</code> (имя) и <code class=\"code inline\">salary</code>\n\t\t(зарплата).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Student</code> с публичными\n\t\tсвойствами <code class=\"code inline\">name</code> (имя) и <code class=\"code inline\">scholarship</code>\n\t\t(стипендия).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте по <code class=\"number inline\">3</code> объекта каждого класса\n\t\tи в произвольном порядке запишите их в массив\n\t\t<code class=\"code inline\">$arr</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПереберите циклом массив <code class=\"code inline\">$arr</code> и выведите\n\t\tна экран столбец имен всех работников.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tАналогичным образом выведите на экран столбец\n\t\tимен всех студентов.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПереберите циклом массив <code class=\"code inline\">$arr</code> и с\n\t\tего помощью найдите сумму зарплат работников\n\t\tи сумму стипендий студентов. После цикла\n\t\tвыведите эти два числа на экран.\n\t</p>\n</div>\n\n<h2>Оператор instanceof и наследование</h2>\n<p>\n\tПусть теперь у нас есть родительский класс\n\tи дочерний:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Родительский класс:\n\tclass ParentClass\n\t{\n\t\t\n\t}\n\t\n\t// Дочерний класс:\n\tclass ChildClass extends ParentClass\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСоздадим объект дочернего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$obj = new ChildClass;\n?&gt;</code>\n</div>\n<p>\n\tПроверим теперь с помощью <code class=\"code inline\">instanceof</code>,\n\tпринадлежит ли наш объект классу <code class=\"code inline\">ParentClass</code>\n\tи классу <code class=\"code inline\">ChildClass</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tvar_dump($obj instanceof ChildClass);  // выведет true\n\tvar_dump($obj instanceof ParentClass); // тоже выведет true\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите из примера - оператор <code class=\"code inline\">instanceof</code>\n\tне делает различия при проверки между родительскими\n\tи дочерними классами.\n</p>\n<p>\n\tНе путайтесь - если объект будет действительно\n\tродительского класса то, конечно же, проверка\n\tна принадлежность к дочернему классу вернет\n\t<code class=\"code inline\">false</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$obj = new ParentClass; // объект родительского класса\n\t\n\tvar_dump($obj instanceof ParentClass); // выведет true\n\tvar_dump($obj instanceof ChildClass); // выведет false\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">User</code> с публичным свойствами\n\t\t<code class=\"code inline\">name</code> и <code class=\"code inline\">surname</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code>, который будет\n\t\tнаследовать от класса <code class=\"code inline\">User</code> и добавлять\n\t\tсвойство <code class=\"code inline\">salary</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">City</code> с публичными свойствами\n\t\t<code class=\"code inline\">name</code> и <code class=\"code inline\">population</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте <code class=\"number inline\">3</code> объекта класса <code class=\"code inline\">User</code>,\n\t\t<code class=\"number inline\">3</code> объекта класса <code class=\"code inline\">Employee</code>,\n\t\t<code class=\"number inline\">3</code> объекта класса <code class=\"code inline\">City</code>, и в\n\t\tпроизвольном порядке запишите их в массив\n\t\t<code class=\"code inline\">$arr</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПереберите циклом массив <code class=\"code inline\">$arr</code> и выведите\n\t\tна экран столбец свойств <code class=\"code inline\">name</code> тех\n\t\tобъектов, которые принадлежат классу <code class=\"code inline\">User</code>\n\t\tили потомку этого класса.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПереберите циклом массив <code class=\"code inline\">$arr</code> и выведите\n\t\tна экран столбец свойств <code class=\"code inline\">name</code> тех\n\t\tобъектов, которые не принадлежат классу <code class=\"code inline\">User</code>\n\t\tили потомку этого класса.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПереберите циклом массив <code class=\"code inline\">$arr</code> и выведите\n\t\tна экран столбец свойств <code class=\"code inline\">name</code> тех\n\t\tобъектов, которые принадлежат именно классу\n\t\t<code class=\"code inline\">User</code>, то есть не классу <code class=\"code inline\">City</code>\n\t\tи не классу <code class=\"code inline\">Employee</code>.\n\t</p>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tДавайте рассмотрим применение оператора <code class=\"code inline\">instanceof</code>\n\tна достаточно сложном примере. Пусть у нас\n\tесть вот такой класс для работников:\n</p>\n<div class=\"block\" data-file=\"Employee.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Employee\n\t{\n\t\tprivate $name;\n\t\tprivate $salary;\n\t\t\n\t\tpublic function __construct($name, $salary)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;salary = $salary;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getSalary()\n\t\t{\n\t\t\treturn $this-&gt;salary;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть также есть такой класс для студентов:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student\n\t{\n\t\tprivate $name;\n\t\tprivate $scholarship; // стипендия\n\t\t\n\t\tpublic function __construct($name, $scholarship)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;scholarship = $scholarship;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getScholarship()\n\t\t{\n\t\t\treturn $this-&gt;scholarship;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, и работник, и студент имеют\n\tимя и какой-то доход: у работника это зарплата,\n\tа у студента - стипендия.\n</p>\n<p>\n\tПусть теперь мы хотим сделать класс <code class=\"code inline\">UsersCollection</code>,\n\tпредназначенный для хранения работников и\n\tстудентов. Работников мы будем хранить в\n\tсвойстве <code class=\"code inline\">employees</code>, а студентов -\n\tв свойстве <code class=\"code inline\">students</code>:\n</p>\n<div class=\"block\" data-file=\"UsersCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass UsersCollection\n\t{\n\t\tprivate $employees = []; // массив работников\n\t\tprivate $students = []; // массив студентов\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь реализуем единый метод <code class=\"code inline\">add</code>\n\tдля добавления и работников, и студентов.\n\tЭтот метод параметром будет принимать объект\n\tи, если это работник - добавлять его в массив\n\tработников, а если студент - в массив студентов.\n\tПример того, как мы будем пользоваться методом\n\tнашим методом после его реализации:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$usersCollection = new UsersCollection;\n\t\n\t$usersCollection-&gt;add(new Employee('john', 200)); // попадет к работникам\n\t$usersCollection-&gt;add(new Student('eric', 100));  // попадет к студентам\n?&gt;</code>\n</div>\n<p>\n\tИтак, давайте реализуем описанный метод <code class=\"code inline\">add</code>.\n\tЗдесь нам и поможет изученный нами оператор\n\t<code class=\"code inline\">instanceof</code>:\n</p>\n<div class=\"block\" data-file=\"UsersCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass UsersCollection\n\t{\n\t\tprivate $employees = []; // массив работников\n\t\tprivate $students = [];  // массив студентов\n\t\t\n\t\t// Добавление в массивы:\n\t\tpublic function add($user)\n\t\t{\n\t\t\t// Если передан объект класса Employee:\n\t\t\tif ($user instanceof Employee) {\n\t\t\t\t$this-&gt;employees[] = $user; // добавляем к работникам\n\t\t\t}\n\t\t\t\n\t\t\t// Если передан объект класса Student:\n\t\t\tif ($user instanceof Student) {\n\t\t\t\t$this-&gt;students[] = $user; // добавляем к студентам\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте также реализуем методы для нахождения\n\tсуммарной зарплаты и суммарной стипендии:\n</p>\n<div class=\"block\" data-file=\"UsersCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass UsersCollection\n\t{\n\t\tprivate $employees = [];\n\t\tprivate $students = [];\n\t\t\n\t\tpublic function add($user)\n\t\t{\n\t\t\tif ($user instanceof Employee) {\n\t\t\t\t$this-&gt;employees[] = $user;\n\t\t\t}\n\t\t\t\n\t\t\tif ($user instanceof Student) {\n\t\t\t\t$this-&gt;students[] = $user;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Получаем суммарную зарплату:\n\t\tpublic function getTotalSalary()\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($this-&gt;employees as $employee) {\n\t\t\t\t$sum += $employee-&gt;getSalary();\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t\t\n\t\t// Получаем суммарную стипендию:\n\t\tpublic function getTotalScholarship()\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($this-&gt;students as $student) {\n\t\t\t\t$sum += $student-&gt;getScholarship();\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tРеализуем также метод, который будет находить\n\tобщую сумму платежей и работникам, и студентам:\n</p>\n<div class=\"block\" data-file=\"UsersCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass UsersCollection\n\t{\n\t\tprivate $employees = [];\n\t\tprivate $students = [];\n\t\t\n\t\tpublic function add($user)\n\t\t{\n\t\t\tif ($user instanceof Employee) {\n\t\t\t\t$this-&gt;employees[] = $user;\n\t\t\t}\n\t\t\t\n\t\t\tif ($user instanceof Student) {\n\t\t\t\t$this-&gt;students[] = $user;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function getTotalSalary()\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($this-&gt;employees as $employee) {\n\t\t\t\t$sum += $employee-&gt;getSalary();\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t\t\n\t\tpublic function getTotalScholarship()\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($this-&gt;students as $student) {\n\t\t\t\t$sum += $student-&gt;getScholarship();\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t\t\n\t\t// Получаем общую сумму платежей и работникам, и студентам:\n\t\tpublic function getTotalPayment()\n\t\t{\n\t\t\treturn $this-&gt;getTotalScholarship() + $this-&gt;getTotalSalary();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нашего класса:\n</p>\n<div class=\"block\" data-file=\"UsersCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$usersCollection = new UsersCollection;\n\t\n\t$usersCollection-&gt;add(new Student('kyle', 100));\n\t$usersCollection-&gt;add(new Student('luis', 200));\n\t\n\t$usersCollection-&gt;add(new Employee('john', 300));\n\t$usersCollection-&gt;add(new Employee('eric', 400));\n\t\n\t// Получим полную сумму стипендий:\n\techo $usersCollection-&gt;getTotalScholarship();\n\t\n\t// Получим полную сумму зарплат:\n\techo $usersCollection-&gt;getTotalSalary();\n\t\n\t// Получим полную сумму платежей:\n\techo $usersCollection-&gt;getTotalPayment();\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте мой код классов <code class=\"code inline\">Employee</code>\n\t\tи <code class=\"code inline\">Student</code> и самостоятельно не подсматривая\n\t\tв мой код реализуйте такой же класс <code class=\"code inline\">UsersCollection</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/types-control/","content":"\n\t\t\t\t<h1>Контроль типов при работе с объектами</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас дан вот такой класс <code class=\"code inline\">Employee</code>:\n</p>\n<div class=\"block\" data-file=\"Employee.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Employee\n\t{\n\t\tprivate $name;\n\t\tprivate $salary;\n\t\t\n\t\tpublic function __construct($name, $salary)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;salary = $salary;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getSalary()\n\t\t{\n\t\t\treturn $this-&gt;salary;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТакже пусть дан класс <code class=\"code inline\">EmployeesCollection</code>\n\tдля хранения коллекции работников:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass EmployeesCollection\n\t{\n\t\tprivate $employees = []; // массив работников\n\t\t\n\t\t// Добавляет работника в набор\n\t\tpublic function add($employee) // параметр - объект класса Employee\n\t\t{\n\t\t\t$this-&gt;employees[] = $employee; // добавим объект в набор\n\t\t}\n\t\t\n\t\tpublic function getTotalSalary()\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($this-&gt;employees as $employee) {\n\t\t\t\t$sum += $employee-&gt;getSalary();\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tРассмотрим внимательно метод <code class=\"code inline\">add</code> класса\n\t<code class=\"code inline\">EmployeesCollection</code>: в нем параметром\n\tпередается объект класса <code class=\"code inline\">Employee</code>.\n\tОднако программисту, читающему наш код, сходу\n\tтяжело будет понять, что параметром метода\n\t<code class=\"code inline\">add</code> должен служить именно объект и\n\tименно класса <code class=\"code inline\">Employee</code>.\n</p>\n<p>\n\tДа, мы можем оставить комментарий в нашем\n\tкоде, чтобы прояснить ситуацию, но это все\n\tравно не убережет программиста от ошибок,\n\tесли он попытается передать, к примеру, объект\n\tкакого-нибудь другого класса или вообще массив.\n</p>\n<p>\n\tБыло бы круто указать тип передаваемого параметра\n\tпрямо в описании функции. Ранее в учебнике\n\tмы с вами уже разбирали подобную возможность\n\tдля примитивов.\n</p>\n<p>\n\tМожно также явно задать и тип параметра,\n\tв который будет передаваться объект - мы\n\tможем точно сказать, объект какого класса\n\tтам ожидается.\n</p>\n<p>\n\tДля этого перед именем переменной параметра\n\tследует написать имя ожидаемого класса, в\n\tнашем случае <code class=\"code inline\">Employee</code>.\n</p>\n<p>\n\tДавайте переделаем наш метод <code class=\"code inline\">add</code>:\n</p>\n<div class=\"block\" data-file=\"EmployeesCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass EmployeeCollection\n\t{\n\t\tprivate $employees = [];\n\t\t\n\t\t// Явно укажем тип параметра:\n\t\tpublic function add(Employee $employee)\n\t\t{\n\t\t\t$this-&gt;employees[] = $employee;\n\t\t}\n\t\t\n\t\tpublic function getTotalSalary()\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($this-&gt;employees as $employee) {\n\t\t\t\t$sum += $employee-&gt;getSalary();\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Post</code> (<span class=\"translate-ru\">должность</span>),\n\t\tв котором будут следующие свойства, доступные\n\t\tтолько для чтения: <code class=\"code inline\">name</code> и <code class=\"code inline\">salary</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте несколько объектов класса <code class=\"code inline\">Post</code>:\n\t\tпрограммист, менеджер водитель.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code>, в котором\n\t\tбудут следующие свойства: <code class=\"code inline\">name</code> и <code class=\"code inline\">surname</code>.\n\t\tПусть начальные значения этих свойств будут\n\t\tпередаваться параметром в конструктор.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте геттеры и сеттеры для свойств <code class=\"code inline\">name</code>\n\t\tи <code class=\"code inline\">surname</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть теперь третьим параметром конструктора\n\t\tбудет передаваться должность работника, представляющая\n\t\tсобой объект класса <code class=\"code inline\">Post</code>. Укажите\n\t\tтип этого параметра в явном виде.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте так, чтобы должность работника (то\n\t\tесть переданный объект с должностью) записывалась\n\t\tв свойство <code class=\"code inline\">post</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте объект класса <code class=\"code inline\">Employee</code> с\n\t\tдолжностью программист. При его создании\n\t\tиспользуйте один из объектов класса <code class=\"code inline\">Post</code>,\n\t\tсозданный нами ранее.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыведите на экран имя, фамилию, должность\n\t\tи зарплату созданного работника.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте в классе <code class=\"code inline\">Employee</code> метод\n\t\t<code class=\"code inline\">changePost</code>, который будет изменять\n\t\tдолжность работника на другую. Метод должен\n\t\tпринимать параметром объект класса <code class=\"code inline\">Post</code>.\n\t\tУкажите в методе тип принимаемого параметра\n\t\tв явном виде.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/static-methods/","content":"\n\t\t\t\t<h1>Статические методы в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПри работе с классами можно делать методы,\n\tкоторые для своего вызова не требуют создания\n\tобъекта. Такие методы называются <dfn>статическими</dfn>.\n\tЧтобы объявить метод статическим, нужно после\n\tмодификатора доступа написать ключевое слово\n\t<code class=\"code inline\">static</code>:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\t// Статический метод:\n\t\tpublic static function method()\n\t\t{\n\t\t\treturn '!!!';\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tЧтобы обратиться к статическому методу, нужно\n\tнаписать имя класса, потом два двоеточия\n\tи имя метода, объект класса при этом создавать\n\tне надо, вот так:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo Test::method(); // выведет '!!!'\n?&gt;</code>\n</div>\n\n<h2>Пример</h2>\n<p>\n\tДавайте рассмотрим статические методы на\n\tболее практическом примере. Пусть у нас дан\n\tвот такой математический класс <code class=\"code inline\">Math</code>\n\t(пока без статических методов):\n</p>\n<div class=\"block\" data-file=\"Math.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Math\n\t{\n\t\t// Находит сумму:\n\t\tpublic function getSum($a, $b)\n\t\t{\n\t\t\treturn $a + $b;\n\t\t}\n\t\t\n\t\t// Находит произведение:\n\t\tpublic function getProduct($a, $b)\n\t\t{\n\t\t\treturn $a * $b;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте воспользуемся нашим классом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$math = new Math; // создаем объект класса\n\techo $math-&gt;getSum(1, 2) + $math-&gt;getProduct(3, 4); // используем методы\n?&gt;</code>\n</div>\n<p>\n\tНаш класс <code class=\"code inline\">Math</code> представляет собой\n\tпросто набор методов и, фактически, нам нужен\n\tтолько один объект этого класса. В таком\n\tслучае удобно объявить методы класса статическими\n\tи вообще не создавать объект этого класса,\n\tа сразу использовать его методы. Сделаем это:\n</p>\n<div class=\"block\" data-file=\"Math.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Math\n\t{\n\t\tpublic static function getSum($a, $b)\n\t\t{\n\t\t\treturn $a + $b;\n\t\t}\n\t\t\n\t\tpublic static function getProduct($a, $b)\n\t\t{\n\t\t\treturn $a * $b;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВоспользуемся методами нашего класса без\n\tсоздания объекта класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo Math::getSum(1, 2) + Math::getProduct(3, 4);\n?&gt;</code>\n</div>\n\n<h2>Статические методы внутри класса</h2>\n<p>\n\tЕсли вы хотите использовать статические методы\n\tвнутри класса, то к ним следует обращаться\n\tне через <code class=\"code inline\">$this-></code>, а с помощью <code class=\"code inline\">self::</code>.\n</p>\n<p>\n\tДля примера добавим в наш класс <code class=\"code inline\">Math</code>\n\tметод <code class=\"code inline\">getDoubleSum</code>, который будет\n\tнаходить удвоенную сумму чисел. Используем\n\tвнутри нового метода уже существующий метод\n\t<code class=\"code inline\">getSum</code>:\n</p>\n<div class=\"block\" data-file=\"Math.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Math\n\t{\n\t\t// Найдем удвоенную сумму:\n\t\tpublic static function getDoubleSum($a, $b)\n\t\t{\n\t\t\treturn 2 * self::getSum($a, $b); // используем другой метод\n\t\t}\n\t\t\n\t\tpublic static function getSum($a, $b)\n\t\t{\n\t\t\treturn $a + $b;\n\t\t}\n\t\t\n\t\tpublic static function getProduct($a, $b)\n\t\t{\n\t\t\treturn $a * $b;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВоспользуемся новым методом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo Math::getDoubleSum(1, 2);\n?&gt;</code>\n</div>\n\n<h2>Практика</h2>\n<p>\n\tПусть у нас дан вот такой класс <code class=\"code inline\">ArraySumHelper</code>,\n\tкоторый мы рассматривали в одном из предыдущих\n\tуроков:\n</p>\n<div class=\"block\" data-file=\"ArraySumHelper.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass ArraySumHelper\n\t{\n\t\tpublic function getSum1($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 1);\n\t\t}\n\t\t\n\t\tpublic function getSum2($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 2);\n\t\t}\n\t\t\n\t\tpublic function getSum3($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 3);\n\t\t}\n\t\t\n\t\tpublic function getSum4($arr)\n\t\t{\n\t\t\treturn $this-&gt;getSum($arr, 4);\n\t\t}\n\t\t\n\t\tprivate function getSum($arr, $power) {\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($arr as $elem) {\n\t\t\t\t$sum += pow($elem, $power);\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПеределайте методы класса <code class=\"code inline\">ArraySumHelper</code>\n\t\tна статические.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть дан массив с числами. Найдите с помощью\n\t\tкласса <code class=\"code inline\">ArraySumHelper</code> сумму квадратов\n\t\tэлементов этого массива.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/static-properties/","content":"\n\t\t\t\t<h1>Статические свойства в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tКроме статических методов можно также делать\n\tи статические свойства. Такие свойства также\n\tобъявляются с помощью ключевого слова <code class=\"code inline\">static</code>:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic static $property; // статическое свойство\n\t}\n?&gt;</code>\n</div>\n<p>\n\tМожно что-то записать в статическое свойство\n\tи прочитать из него. При этом имя свойства\n\tуказывается вместе с долларом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tTest::$property = 'test';\n\techo Test::$property; // выведет 'test'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Num</code>, у которого будут\n\t\tдва публичных статических свойства: <code class=\"code inline\">num1</code>\n\t\tи <code class=\"code inline\">num2</code>. Запишите в первое свойство\n\t\tчисло <code class=\"number inline\">2</code>, а во второе - число <code class=\"number inline\">3</code>.\n\t\tВыведите сумму значений свойств на экран.\n\t</p>\n</div>\n\n<h2>Статическое свойство внутри класса</h2>\n<p>\n\tМожно также обращаться к статическим свойствам\n\tвнутри самого класса, используя <code class=\"code inline\">self::</code>,\n\tсмотрите пример:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\t// Приватное статическое свойство:\n\t\tprivate static $property;\n\t\t\n\t\t// Статический метод для задания значения свойства:\n\t\tpublic static function setProperty($value)\n\t\t{\n\t\t\tself::$property = $value; // записываем данные в наше static свойство\n\t\t}\n\t\t\n\t\t// Статический метод для получения значения свойства:\n\t\tpublic static function getProperty()\n\t\t{\n\t\t\treturn self::$property; // прочитываем записанные данные\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВоспользуемся нашим классом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tTest::setProperty('test'); // запишем данные в свойство\n\techo Test::getProperty(); // выведем на экран\n?&gt;</code>\n</div>\n<p>\n\tМожно также задать начальное значение свойства:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\t// Начальное значение свойства:\n\t\tprivate static $property = 'test';\n\t\t\n\t\tpublic static function getProperty()\n\t\t{\n\t\t\treturn self::$property;\n\t\t}\n\t}\n\t\n\techo Test::getProperty(); // выведет 'test'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Num</code>, у которого будут\n\t\tдва приватны статических свойства: <code class=\"code inline\">num1</code>\n\t\tи <code class=\"code inline\">num2</code>. Пусть по умолчанию в свойстве\n\t\t<code class=\"code inline\">num1</code> хранится число <code class=\"number inline\">2</code>, а в\n\t\tсвойстве <code class=\"code inline\">num2</code> - число <code class=\"number inline\">3</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте в классе <code class=\"code inline\">Num</code> метод <code class=\"code inline\">getSum</code>,\n\t\tкоторый будет выводить на экран сумму значений\n\t\tсвойств <code class=\"code inline\">num1</code> и <code class=\"code inline\">num2</code>.\n\t</p>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tПусть у нас есть класс <code class=\"code inline\">Geometry</code> для\n\tработы с геометрическими фигурами. В этом\n\tклассе есть методы для определения площади\n\tкруга и длины окружности:\n</p>\n<div class=\"block\" data-file=\"Geometry.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Geometry\n\t{\n\t\t// Площадь круга:\n\t\tpublic static function getCircleSquare($radius)\n\t\t{\n\t\t\treturn 3.14 * $radius * $radius;\n\t\t}\n\t\t\n\t\t// Длина окружности:\n\t\tpublic static function getCircleСircuit($radius)\n\t\t{\n\t\t\treturn 2 * 3.14 * $radius;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, в обоих методах используется\n\tчисло Пи, равное <code class=\"number inline\">3.14</code>. Было бы удобно\n\tвынести это число в статическое свойство\n\tкласса - в этом случае значение числа Пи\n\tбудет задаваться в одном месте и мы легко\n\tсможем поменять его в случае необходимости\n\t(например, написать больше знаков в дробной\n\tчасти).\n</p>\n<p>\n\tДавайте сделаем это:\n</p>\n<div class=\"block\" data-file=\"Geometry.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Geometry\n\t{\n\t\tprivate static $pi = 3.14; // вынесем Пи в свойство\n\t\t\n\t\tpublic static function getCircleSquare($radius)\n\t\t{\n\t\t\treturn self::$pi * $radius * $radius;\n\t\t}\n\t\t\n\t\tpublic static function getCircleСircuit($radius)\n\t\t{\n\t\t\treturn 2 * self::$pi * $radius;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в наш класс <code class=\"code inline\">Geometry</code> метод,\n\t\tкоторый будет находить объем шара по радиусу.\n\t\tС помощью этого метода выведите на экран\n\t\tобъем шара с радиусом <code class=\"number inline\">10</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/object-with-static-properties-and-methods/","content":"\n\t\t\t\t<h1>Объект со статическими свойствами и методами</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВы уже знаете, что статические свойства и\n\tметоды можно использовать, не создавая объект\n\tкласса. На самом деле, однако, класс может\n\tсодержать как статические свойства и методы,\n\tтак и обычные.\n</p>\n<p>\n\tДавайте посмотрим, как с этим работать и\n\tкакие преимущества это дает. Пусть у нас\n\tесть класс <code class=\"code inline\">Test</code> одновременно и со\n\tстатическим свойством, и с обычным:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic static $staticProperty; // публичное статическое свойство\n\t\tpublic $usualProperty; // обычное свойство\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте, к примеру, поработаем с его обычным\n\tсвойством:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test; // создаем объект класса\n\t\n\t$test-&gt;usualProperty = 'usual'; // записываем значение\n\techo $test-&gt;usualProperty; // выведет 'usual'\n?&gt;</code>\n</div>\n<p>\n\tА теперь используем статическое свойство,\n\tне создавая объект этого класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tTest::$staticProperty = 'static'; // записываем значение\n\techo Test::$staticProperty; // выведет 'static'\n?&gt;</code>\n</div>\n<p>\n\tНа самом деле, если у нас есть переменная\n\tс объектом класса, то у этой переменной также\n\tбудет доступно статическое свойство:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test; // создаем объект класса\n\t\n\t$test::$staticProperty = 'static'; // записываем значение\n\techo $test::$staticProperty; // выведет 'static'\n?&gt;</code>\n</div>\n<p>\n\tРазницы нет - мы к одному и тому же статическому\n\tсвойству можем обращаться и так, и так. Вот\n\tпример, иллюстрирующий это:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Записываем значение еще ДО создания объекта:\n\tTest::$staticProperty = 'static';\n\t\n\t// Cоздаем объект класса:\n\t$test = new Test;\n\t\n\t// Выводим статическое свойство:\n\techo $test::$staticProperty; // выведет 'static'\n?&gt;</code>\n</div>\n<p>\n\tВот еще пример:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Cоздаем объект класса:\n\t$test = new Test;\n\t\n\t// Записываем значение в статическое свойство:\n\t$test::$staticProperty  = 'static';\n\t\n\t// Выводим значение, обратившись к классу:\n\techo Test::$staticProperty; // выведет 'static'\n\t\n\t// Выводим значение, обратившись к объекту класса:\n\techo $test::$staticProperty; // выведет 'static'\n?&gt;</code>\n</div>\n\n<h2>Несколько объектов</h2>\n<p>\n\tСтатические свойства принадлежат не какому-то\n\tобъекту класса, а самому классу, хотя объекты\n\tкласса и имеют доступ к этим свойствам.\n</p>\n<p>\n\tНа практике это означает то, что если у нас\n\tесть несколько объектов класса - статические\n\tсвойства у них будут общие. То есть, если\n\tв одном объекте поменять значение статического\n\tсвойства - изменения произойдут во всех объектах.\n</p>\n<p>\n\tДавайте посмотрим на примере:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test1 = new Test; // первый объект\n\t$test2 = new Test; // второй объект\n\t\n\t$test1::$staticProperty = 'static'; // запишем значение, используя первый объект\n\t\n\techo $test1::$staticProperty; // выведет 'static'\n\techo $test2::$staticProperty; // также выведет 'static'\n?&gt;</code>\n</div>\n\n<h2>Статические методы и $this</h2>\n<p>\n\tПусть у нас есть класс <code class=\"code inline\">Test</code> с двумя\n\tсвойствами, статическим и обычным:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic static $staticProperty = 'static'; // статическое свойство\n\t\tpublic $usualProperty = 'usual'; // обычное свойство\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте выведем значения этих свойств в обычном\n\tметоде <code class=\"code inline\">method</code>:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic static $staticProperty = 'static'; // статическое свойство\n\t\tpublic $usualProperty = 'usual'; // обычное свойство\n\t\t\n\t\t// Обычный метод:\n\t\tpublic function method()\n\t\t{\n\t\t\tvar_dump(self::$staticProperty); // выведет 'static'\n\t\t\tvar_dump($this-&gt;usualProperty);  // выведет 'usual'\n\t\t}\n\t}\n\t\n\t$test = new Test;\n\t$test-&gt;method(); // обычный метод - вызываем через -&gt;\n?&gt;</code>\n</div>\n<p>\n\tИз примера видно, что в обычном методе доступны\n\tкак статические, так и обычные свойства (и\n\tметоды). Пусть теперь наш метод <code class=\"code inline\">method</code>\n\tбудет статическим. В этом случае он сможет\n\tобратиться с статическим методом и свойствам,\n\tно к обычным - нет.\n</p>\n<p>\n\tПочему: потому что внутри статических методов\n\tнедоступен <code class=\"code inline\">$this</code>. Это происходит из-за\n\tтого, что статические методы могут вызываться\n\tвне контекста объекта, просто обращаясь к\n\tимени класса.\n</p>\n<p>\n\tА ведь <code class=\"code inline\">$this</code> внутри класса как раз-таки\n\tссылается на объект этого класса. Нет объекта\n\t- <code class=\"code inline\">$this</code> ни на что не ссылается. Убедимся\n\tв этом: переделаем наш метод на статический\n\t- теперь обращение к обычному свойству внутри\n\tнашего метода будет выдавать ошибку:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic static $staticProperty = 'static'; // статическое свойство\n\t\tpublic $usualProperty = 'usual'; // обычное свойство\n\t\t\n\t\t// Переделали на статический метод:\n\t\tpublic static function method()\n\t\t{\n\t\t\tvar_dump(self::$staticProperty); // выведет 'static'\n\t\t\tvar_dump($this-&gt;usualProperty);  // выдаст ошибку\n\t\t}\n\t}\n\t\n\t$test = new Test;\n\t$test::method(); // статический метод - вызываем через ::\n?&gt;</code>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tПусть у нас есть вот такой класс <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $name;\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем так, чтобы этот класс подсчитывал\n\tколичество своих объектов. Для этого сделаем\n\tстатическое свойство <code class=\"code inline\">count</code>. Изначально\n\tзапишем в него значение <code class=\"number inline\">0</code>, а при создании\n\tкаждого нового объекта будем увеличивать\n\tэто значение на <code class=\"number inline\">1</code>.\n</p>\n<p>\n\tБудем увеличивать значение нашего счетчика\n\tв конструкторе объекта:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic static $count = 0; // счетчик объектов\n\t\tpublic $name;\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t\n\t\t\t// Увеличиваем счетчик при создании объекта:\n\t\t\tself::$count++;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим, что все работает:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('user1'); // создаем первый объект класса\n\techo User::$count; //выведет 1\n\t\n\t$user2 = new User('user2'); // создаем второй объект класса\n\techo User::$count; //выведет 2\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код реализуйте такой\n\t\tже класс <code class=\"code inline\">User</code>, подсчитывающий количество\n\t\tсвоих объектов.\n\t</p>\n</div>\n\n<h2>Улучшим наш код</h2>\n<p>\n\tНе очень хорошо то, что наш счетчик публичный\n\t- его случайно можно изменить снаружи класса.\n\tДавайте сделаем его доступным только для\n\tчтения. Для этого объявим его приватным и\n\tсделаем для него статический метод-геттер\n\t<code class=\"code inline\">getCount</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate static $count = 0;\n\t\tpublic $name;\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t\n\t\t\t// Увеличиваем счетчик при создании объекта:\n\t\t\tself::$count++;\n\t\t}\n\t\t\n\t\t// Метод, возвращающий значение счетчика:\n\t\tpublic static function getCount()\n\t\t{\n\t\t\t// Выводим значение счетчика:\n\t\t\treturn self::$count;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user1 = new User('user1'); // создаем первый объект класса\n\techo User::getCount(); //выведет 1\n\t\n\t$user2 = new User('user2'); // создаем второй объект класса\n\techo User::getCount(); //выведет 2\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно переделайте код вашего класса\n\t\t<code class=\"code inline\">User</code> в соответствии с теоретической\n\t\tчастью урока.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class-constants/","content":"\n\t\t\t\t<h1>Константы классов в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами разберем <dfn>константы</dfn>\n\tклассов. Константы по сути являются свойствами,\n\tзначения которых нельзя изменить. Неизменяемые\n\tсвойства нужны для того, чтобы хранить какие-то\n\tзначения, которые являются постоянными и\n\tне должны быть случайно изменены.\n</p>\n<p>\n\tЧтобы создать константу, ее нужно объявить\n\tчерез ключевое слово <code class=\"code inline\">const</code>, затем\n\tнаписать имя константы без доллара и обязательно\n\tсразу же задать ее значение:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tconst constant = 'test'; // задаем константу\n\t}\n?&gt;</code>\n</div>\n<p>\n\tОбщепринято имена констант писать большими\n\tбуквами, то есть не <code class=\"code inline\">constant</code>, а <code class=\"code inline\">CONSTANT</code>.\n\tЭто делается для того, чтобы визуально легко\n\tбыло отличать константы в коде.\n</p>\n<p>\n\tДавайте поправим наш класс:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\t// Задаем константу:\n\t\tconst CONSTANT = 'test';\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь рассмотрим, как прочитать\n\tзначения константы. Здесь следует сказать\n\tто, что константы класса больше похожи не\n\tна обычные свойства, а на статические.\n</p>\n<p>\n\tЭто значит, что константы класса задаются\n\tодин раз для всего класса, а не отдельно\n\tдля каждого объекта этого класса.\n</p>\n<p>\n\tПоэтому обращение к константам происходит\n\tпочти так же, как и для статических свойств:\n\tпишем имя класса, два двоеточия и название\n\tконстанты без доллара перед именем:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo Test::CONSTANT; // выведет 'test'\n?&gt;</code>\n</div>\n<p>\n\tКак уже упоминалось выше, значения констант\n\tможно прочитывать, но не записывать. Попытка\n\tчто-то записать в нее выдаст ошибку:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tTest::CONSTANT = 'test'; // выдаст ошибку\n?&gt;</code>\n</div>\n\n<h2>Обращение к константам внутри класса</h2>\n<p>\n\tВнутри класса также можно обратится к константе\n\tчерез <code class=\"code inline\">::self</code>, вот так:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tconst CONSTANT = 'test';\n\t\t\n\t\tfunction getConstant() {\n\t\t\treturn self::CONSTANT;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВоспользуемся нашим методом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test;\n\techo $test-&gt;getConstant(); // выведет 'test'\n?&gt;</code>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tДавайте сделаем класс <code class=\"code inline\">Circle</code>, с помощью\n\tкоторого можно будет найти площадь круга\n\tи длину окружности. Для работы с кругом нам\n\tпонадобится число Пи, равное <code class=\"number inline\">3.14</code>.\n\tЛогично будет для хранения этого числа использовать\n\tконстанту, чтобы случайно где-нибудь в коде\n\tнаше число Пи вдруг не поменялось.\n</p>\n<p>\n\tВот частичная реализация нашего класса:\n</p>\n<div class=\"block\" data-file=\"Circle.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Circle\n\t{\n\t\tconst PI = 3.14; // запишем число ПИ в константу\n\t\tprivate $radius; // радиус круга\n\t\t\n\t\tpublic function __construct($radius)\n\t\t{\n\t\t\t$this-&gt;radius = $radius;\n\t\t}\n\t\t\n\t\t// Найдем площадь:\n\t\tpublic function getSquare()\n\t\t{\n\t\t\t// Пи умножить на квадрат радиуса\n\t\t}\n\t\t\n\t\t// Найдем длину окружности:\n\t\tpublic function getCircuit()\n\t\t{\n\t\t\t// 2 Пи умножить на радиус\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте предложенный класс <code class=\"code inline\">Circle</code>\n\t\tсамостоятельно.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tС помощью написанного класса <code class=\"code inline\">Circle</code>\n\t\tнайдите длину окружности и площадь круга\n\t\tс радиусом <code class=\"number inline\">10</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/functions/","content":"\n\t\t\t\t<h1>Функции для работы с классами и объектами</h1>\n\t\t\t\t<div class=\"content\">\n<h2>Функция get_class</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-class.php\"><code class=\"code inline\">get_class</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте объект какого-нибудь класса. Примените\n\t\tк объекту функцию <code class=\"code inline\">get_class</code> и узнайте\n\t\tимя класса, которому принадлежит объект.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте два класса: <code class=\"code inline\">Test1</code> и <code class=\"code inline\">Test2</code>.\n\t\tПусть оба класса имеют свойство <code class=\"code inline\">name</code>.\n\t\tСоздайте некоторое количество объектов этих\n\t\tклассов и запишите в массив <code class=\"code inline\">$arr</code> в\n\t\tпроизвольном порядке. Переберите этот массив\n\t\tциклом и для каждого объекта выведите значение\n\t\tего свойства <code class=\"code inline\">name</code> и имя класса, которому\n\t\tпринадлежит объект.\n\t</p>\n</div>\n\n<h2>Функция get_class_methods</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-class-methods.php\"><code class=\"code inline\">get_class_methods</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Test</code> с методами <code class=\"code inline\">method1</code>,\n\t\t<code class=\"code inline\">method2</code> и <code class=\"code inline\">method3</code>. С помощью\n\t\tфункции <code class=\"code inline\">get_class_methods</code> получите\n\t\tмассив названий методов класса <code class=\"code inline\">Test</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте объект класса <code class=\"code inline\">Test</code>, запишите\n\t\tего в переменную <code class=\"code inline\">$test</code>. С помощью\n\t\tфункции <code class=\"code inline\">get_class_methods</code> получите\n\t\tмассив названий методов объекта. Переберите\n\t\tего циклом и в цикле вызовите каждый метод\n\t\tкласса, используя объект <code class=\"code inline\">$test</code>. Переберите\n\t\tэтот массив циклом и в этом цикле вызовите\n\t\tкаждый метод объекта.\n\t</p>\n</div>\n\n<h2>Функция get_class_vars</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-class-vars.php\"><code class=\"code inline\">get_class_vars</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Test</code> с публичными свойствами\n\t\t<code class=\"code inline\">prop1</code> и <code class=\"code inline\">prop2</code>, а также с приватными\n\t\tсвойствами <code class=\"code inline\">prop3</code> и <code class=\"code inline\">prop4</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВызовите функцию <code class=\"code inline\">get_class_vars</code> снаружи\n\t\tкласса <code class=\"code inline\">Test</code>. Выведите массив доступных\n\t\tсвойств.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВызовите функцию <code class=\"code inline\">get_class_vars</code> внутри\n\t\tкласса <code class=\"code inline\">Test</code> (например, в конструкторе).\n\t\tВыведите массив доступных свойств.\n\t</p>\n</div>\n\n<h2>Функция get_object_vars</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-object-vars.php\"><code class=\"code inline\">get_object_vars</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Test</code> с публичными свойствами\n\t\t<code class=\"code inline\">prop1</code> и <code class=\"code inline\">prop2</code>, а также с приватными\n\t\tсвойствами <code class=\"code inline\">prop3</code> и <code class=\"code inline\">prop4</code>. Создайте\n\t\tобъект этого класса. С помощью функции <code class=\"code inline\">get_object_vars</code>\n\t\tполучите массив свойств созданного объекта.\n\t</p>\n</div>\n\n<h2>Функция class_exists</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.class-exists.php\"><code class=\"code inline\">class_exists</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас есть класс <code class=\"code inline\">Test1</code> и нет\n\t\tкласса <code class=\"code inline\">Test2</code>. Проверьте, что выведет\n\t\tфункция <code class=\"code inline\">class_exists</code> для класса <code class=\"code inline\">Test1</code>\n\t\tи для класса <code class=\"code inline\">Test2</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть GET параметром в адресную строку передается\n\t\tназвание класса. Проверьте, существует ли\n\t\tтакой класс. Выведите соответствующее сообщение\n\t\tна экран.\n\t</p>\n</div>\n\n<h2>Функция method_exists</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.method-exists.php\"><code class=\"code inline\">method_exists</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Test</code> с методом <code class=\"code inline\">method1</code>\n\t\tи без метода <code class=\"code inline\">method2</code>. Проверьте, что\n\t\tвыведет функция <code class=\"code inline\">method_exists</code> для\n\t\tметода <code class=\"code inline\">method1</code> и для метода <code class=\"code inline\">method2</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть GET параметрами в адресную строку передаются\n\t\tназвание класса и его метод. Проверьте, существует\n\t\tли такой класс. Если существует - проверьте\n\t\tсуществование переданного метода. Если и\n\t\tметод существует - создайте объект данного\n\t\tкласса, вызовите указанный метод и выведите\n\t\tрезультат его работы на экран.\n\t</p>\n</div>\n\n<h2>Функция property_exists</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.property-exists.php\"><code class=\"code inline\">property_exists</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Test</code> со свойством <code class=\"code inline\">prop1</code>\n\t\tи без свойства <code class=\"code inline\">prop2</code>. Проверьте, что\n\t\tвыведет функция <code class=\"code inline\">property_exists</code> для\n\t\tсвойства <code class=\"code inline\">prop1</code> и для свойства <code class=\"code inline\">prop2</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДан массив со свойствами класса. Дан также\n\t\tкласс, имеющий часть из этих свойств. Переберите\n\t\tэтот массив циклом, для каждого свойства\n\t\tпроверьте, существует ли оно в классе и,\n\t\tесли существует, выведите на экран значение\n\t\tэтого свойства.\n\t</p>\n</div>\n\n<h2>Функция get_parent_class</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-parent-class.php\"><code class=\"code inline\">get_parent_class</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">ChildClass</code> наследующий\n\t\tот <code class=\"code inline\">ParentClass</code>. С помощью функции\n\t\t<code class=\"code inline\">get_parent_class</code> выведите на экран\n\t\tродителя класса <code class=\"code inline\">ParentClass</code>.\n\t</p>\n</div>\n\n<h2>Функции is_subclass_of</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.is-subclass-of.php\"><code class=\"code inline\">is_subclass_of</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">ChildClass</code> наследующий\n\t\tот <code class=\"code inline\">ParentClass</code>, который в свою очередь\n\t\tнаследует от <code class=\"code inline\">GrandParentClass</code>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tС помощью функции <code class=\"code inline\">is_subclass_of</code> проверьте,\n\t\tявляется ли класс <code class=\"code inline\">ChildClass</code> потомком\n\t\t<code class=\"code inline\">GrandParentClass</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tС помощью функции <code class=\"code inline\">is_subclass_of</code> проверьте,\n\t\tявляется ли класс <code class=\"code inline\">ParentClass</code> потомком\n\t\t<code class=\"code inline\">GrandParentClass</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tС помощью функции <code class=\"code inline\">is_subclass_of</code> проверьте,\n\t\tявляется ли класс <code class=\"code inline\">ChildClass</code> потомком\n\t\t<code class=\"code inline\">ParentClass</code>.\n\t</p>\n</div>\n\n<h2>Функция is_a</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.is-a.php\"><code class=\"code inline\">is_a</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">ChildClass</code> наследующий\n\t\tот <code class=\"code inline\">ParentClass</code>. Создайте объект класса\n\t\t<code class=\"code inline\">ChildClass</code>, запишите его в переменную\n\t\t<code class=\"code inline\">$obj</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tС помощью функции <code class=\"code inline\">is_a</code> проверьте,\n\t\tпринадлежит ли объект <code class=\"code inline\">$obj</code> классу\n\t\t<code class=\"code inline\">ChildClass</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tС помощью функции <code class=\"code inline\">is_a</code> проверьте,\n\t\tпринадлежит ли объект <code class=\"code inline\">$obj</code> классу\n\t\t<code class=\"code inline\">ParentClass</code>.\n\t</p>\n</div>\n\n<h2>Функция get_declared_classes</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-declared-classes.php\"><code class=\"code inline\">get_declared_classes</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыведите на экран список всех объявленных классов.\n\t</p>\n</div>\n\n<!--\n\n<h2>Функция interface_exists</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.interface-exists.php\"><code class=\"code inline\">interface_exists</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас есть интерфейс <code class=\"code inline\">iTest1</code>\n\t\tи нет интерфейса <code class=\"code inline\">iTest2</code>.\n\t</p>\n\t<p>\n\t\tПроверьте, что выведет функция <code class=\"code inline\">interface_exists</code>\n\t\tдля интерфейса <code class=\"code inline\">iTest1</code> и для интерфейса\n\t\t<code class=\"code inline\">iTest2</code>.\n\t</p>\n</div>\n\n<h2>Функция get_declared_interfaces</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-declared-interfaces.php\"><code class=\"code inline\">get_declared_interfaces</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыведите на экран список всех объявленных\n\t\tинтерфейсов.\n\t</p>\n</div>\n\n<h2>Функция get_declared_traits</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-declared-traits.php\"><code class=\"code inline\">get_declared_traits</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыведите на экран список всех объявленных трейтов.\n\t</p>\n</div>\n\n\n<h2>Функция trait_exists</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.trait-exists.php\"><code class=\"code inline\">trait_exists</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас есть трейт <code class=\"code inline\">Trait1</code> и нет\n\t\tтрейта <code class=\"code inline\">Trait2</code>.\n\t</p>\n\t<p>\n\t\tПроверьте, что выведет функция <code class=\"code inline\">trait_exists</code>\n\t\tдля трейта <code class=\"code inline\">Trait1</code> и для трейта <code class=\"code inline\">Trait2</code>.\n\t</p>\n</div>\n\n-->\n</div>\t\t\t"},{"url":"/ru/php/book/oop/polymorphism/","content":"\n\t\t\t\t<h1>Полиморфизм в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСмотрите следующую статью <a href=\"https://habr.com/post/37576\">на\n\tхабре</a>.\n</p>\n<!--\nПолиморфизм - это следствие наследования.\nЭто свойство унаследованных классов иметь одинаковые методы,\nкоторые будут работать по-разному в контексте объектов.\nНапример, у нас есть класс фигура и классы квадрат, треугольник и\nтрапеция - унаследованные от фигуры. Каждая фигура содержит\nфункционал для вычисления площади, но у каждой фигуры он свой.\n\nhttps://habr.com/post/37610/\n-->\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в теорию расскажите своими\n\t\tсловами о том, как вы поняли значения понятия\n\t\t\"полиморфизм\".\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/abstract-classes/","content":"\n\t\t\t\t<h1>Абстрактные классы в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у вас есть класс <code class=\"code inline\">User</code>, а от\n\tнего наследуют классы <code class=\"code inline\">Employee</code> и <code class=\"code inline\">Student</code>.\n</p>\n<p>\n\tПри этом предполагается, что вы будете создавать\n\tобъекты классов <code class=\"code inline\">Employee</code> и <code class=\"code inline\">Student</code>,\n\tно объекты класса <code class=\"code inline\">User</code> - не будете,\n\tтак как этот класс используется только для\n\tгруппировки общих свойств и методов своих\n\tнаследников.\n</p>\n<p>\n\tВ этом случае можно принудительно запретить\n\tсоздавать объекты класса <code class=\"code inline\">User</code>, чтобы\n\tвы или другой программист где-нибудь их случайно\n\tне создали.\n</p>\n<p>\n\tДля этого существуют так называемые <dfn>абстрактные</dfn>\n\tклассы. Абстрактные классы представляют собой\n\tклассы, предназначенные для наследования\n\tот них. При этом объекты таких классов нельзя\n\tсоздать.\n</p>\n<p>\n\tДля того, чтобы объявить класс абстрактным,\n\tнужно при его объявлении написать ключевое\n\tслово <code class=\"code inline\">abstract</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tabstract class User\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tИтак, давайте напишем реализацию абстрактного\n\tкласса <code class=\"code inline\">User</code>. Пусть у него будет приватное\n\tсвойство <code class=\"code inline\">name</code>, а также геттеры и сеттеры\n\tдля него:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tabstract class User\n\t{\n\t\tprivate $name;\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function setName($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПопытка создать объект класса <code class=\"code inline\">User</code>\n\tвызовет ошибку:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User; // выдаст ошибку\n?&gt;</code>\n</div>\n<p>\n\tА вот унаследовать от нашего класса будет\n\tможно. Сделаем класс <code class=\"code inline\">Employee</code>, который\n\tбудет наследовать от нашего абстрактного\n\tкласса <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"Employee.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Employee extends User\n\t{\n\t\tprivate $salary;\n\t\t\n\t\tpublic function getSalary()\n\t\t{\n\t\t\treturn $this-&gt;salary;\n\t\t}\n\t\t\n\t\tpublic function setSalary($salary)\n\t\t{\n\t\t\t$this-&gt;salary = $salary;\n\t\t}\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСоздадим объект класса <code class=\"code inline\">Employee</code> -\n\tвсе будет работать:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$employee = new Employee;\n\t$employee-&gt;setName('john');  // метод родителя, т.е. класса User\n\t$employee-&gt;setSalary(1000);  // свой метод, т.е. класса Employee\n\t\n\techo $employee-&gt;getName();   // выведет 'john'\n\techo $employee-&gt;getSalary(); // выведет 1000\n?&gt;</code>\n</div>\n<p>\n\tАналогично можно создать объект класса <code class=\"code inline\">Student</code>,\n\tнаследующий от <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $scholarship;\n\t\t\n\t\tpublic function getScholarship()\n\t\t{\n\t\t\treturn $this-&gt;scholarship;\n\t\t}\n\t\t\n\t\tpublic function setScholarship($scholarship)\n\t\t{\n\t\t\t$this-&gt;scholarship = $scholarship;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно, не подсматривая в мой код,\n\t\tреализуйте такой же абстрактный класс <code class=\"code inline\">User</code>,\n\t\tа также классы <code class=\"code inline\">Employee</code> и <code class=\"code inline\">Student</code>,\n\t\tнаследующие от него.\n\t</p>\n</div>\n\n<h2>Абстрактные методы</h2>\n<p>\n\tАбстрактные классы также могут содержать\n\tабстрактные методы. Такие методы не должны\n\tиметь реализации, а нужны для того, чтобы\n\tуказать, что такие методы должны быть у потомков.\n\tА собственно <i>реализация таких методов\n\t- уже задача потомков</i>.\n</p>\n<p>\n\tДля того, чтобы объявить метод абстрактным,\n\tпри его объявлении следует написать ключевое\n\tслово <code class=\"code inline\">abstract</code>.\n</p>\n<p>\n\tДавайте попробуем на практике. Пусть предполагается,\n\tчто все потомки класса <code class=\"code inline\">User</code> должны\n\tиметь метод <code class=\"code inline\">increaseRevenue</code> (<span class=\"translate-ru\">увеличить\n\tдоход</span>).\n</p>\n<p>\n\tЭтот метод должен брать текущий доход пользователя\n\tи увеличивать его на некоторую величину,\n\tпереданную параметром.\n</p>\n<p>\n\tСам класс <code class=\"code inline\">User</code> не знает, какой именно\n\tдоход будет получать наследник - ведь у работника\n\tэто зарплата, а у студента - стипендия. Поэтому\n\tкаждый потомок будет реализовывать этот метод\n\tпо-своему.\n</p>\n<p>\n\tФишка тут в том, что абстрактный метод класса\n\t<code class=\"code inline\">User</code> заставляет программиста реализовывать\n\tэтот метод в потомках, иначе PHP выдаст ошибку.\n\tТаким образом вы, или другой программист,\n\tработающий с вашим кодом, никак не сможете\n\tзабыть реализовать нужный метод в потомке.\n</p>\n<p>\n\tИтак, давайте попробуем на практике. Добавим\n\tабстрактный метод <code class=\"code inline\">increaseRevenue</code>\n\tв класс <code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tabstract class User\n\t{\n\t\tprivate $name;\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function setName($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\t// Абстрактный метод без тела:\n\t\tabstract public function increaseRevenue($value);\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть наш класс <code class=\"code inline\">Employee</code> пока останется\n\tбез изменений. В этом случае, даже если не\n\tсоздавать объект класса <code class=\"code inline\">Employee</code>,\n\tа просто запустить код, в котором определяются\n\tнаши классы, - PHP выдаст ошибку.\n</p>\n<p>\n\tДавайте теперь напишем реализацию метода\n\t<code class=\"code inline\">increaseRevenue</code> в классе <code class=\"code inline\">Employee</code>:\n</p>\n<div class=\"block\" data-file=\"Employee.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Employee extends User\n\t{\n\t\tprivate $salary;\n\t\t\n\t\tpublic function getSalary()\n\t\t{\n\t\t\treturn $this-&gt;salary;\n\t\t}\n\t\t\n\t\tpublic function setSalary($salary)\n\t\t{\n\t\t\t$this-&gt;salary = $salary;\n\t\t}\n\t\t\n\t\t// Напишем реализацию метода:\n\t\tpublic function increaseRevenue($value)\n\t\t{\n\t\t\t$this-&gt;salary = $this-&gt;salary + $value;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нашего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$employee = new Employee;\n\t$employee-&gt;setName('john');      // установим имя\n\t$employee-&gt;setSalary(1000);      // установим зарплату\n\t$employee-&gt;increaseRevenue(100); // увеличим зарплату\n\t\n\techo $employee-&gt;getSalary();     // выведет 1100\n?&gt;</code>\n</div>\n<p>\n\tРеализуем метод <code class=\"code inline\">increaseRevenue</code> и\n\tв классе <code class=\"code inline\">Student</code>. Только теперь наш\n\tметод будет увеличивать уже стипендию:\n</p>\n<div class=\"block\" data-file=\"Student.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Student extends User\n\t{\n\t\tprivate $scholarship; // стипендия\n\t\t\n\t\tpublic function getScholarship()\n\t\t{\n\t\t\treturn $this-&gt;scholarship;\n\t\t}\n\t\t\n\t\tpublic function setScholarship($scholarship)\n\t\t{\n\t\t\t$this-&gt;scholarship = $scholarship;\n\t\t}\n\t\t\n\t\t// Метод увеличивает стипендию:\n\t\tpublic function increaseRevenue($value)\n\t\t{\n\t\t\t$this-&gt;scholarship = $this-&gt;scholarship + $value;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в ваш класс <code class=\"code inline\">User</code> такой же\n\t\tабстрактный метод <code class=\"code inline\">increaseRevenue</code>.\n\t\tНапишите реализацию этого метода в классах\n\t\t<code class=\"code inline\">Employee</code> и <code class=\"code inline\">Student</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте также в ваш класс <code class=\"code inline\">User</code> абстрактный\n\t\tметод <code class=\"code inline\">decreaseRevenue</code> (<span class=\"translate-ru\">уменьшить\n\t\tзарплату</span>). Напишите реализацию этого\n\t\tметода в классах <code class=\"code inline\">Employee</code> и <code class=\"code inline\">Student</code>.\n\t</p>\n</div>\n\n<h2>Некоторые замечания</h2>\n<p>\n\tПри наследовании от абстрактного класса,\n\tвсе методы, помеченные абстрактными в родительском\n\tклассе, должны быть определены в дочернем классе.\n</p>\n<p>\n\tПри этом область видимости этих методов должна\n\tсовпадать или быть менее строгой. Что значит\n\tменее строгой: например, если абстрактный\n\tметод объявлен как <code class=\"code inline\">protected</code>, то реализация\n\tэтого метода должна быть <code class=\"code inline\">protected</code>\n\tили <code class=\"code inline\">public</code>, но не <code class=\"code inline\">private</code>.\n</p>\n<p>\n\tОбъявления методов также должны совпадать:\n\tколичество обязательных параметром должно\n\tбыть одинаковым. Однако класс-потомок может\n\tдобавлять необязательные параметры, которые\n\tне были указаны при объявлении метода в родителе.\n</p>\n\n<h2>Практика</h2>\n<p>\n\tПусть нам необходимо работать с геометрическими\n\tфигурами, например, с квадратами, прямоугольниками,\n\tтреугольниками и так далее. Пусть каждая\n\tфигура будет описываться своим классом, при\n\tэтом мы хотим сделать так, чтобы каждый класс\n\tимел метод для вычисления площади и метод\n\tдля вычисления периметра фигуры.\n</p>\n<p>\n\tДавайте сделаем для этого абстрактный класс\n\t<code class=\"code inline\">Figure</code> с двумя абстрактными методами\n\t<code class=\"code inline\">getSquare</code> и <code class=\"code inline\">getPerimeter</code>.\n</p>\n<p>\n\tПочему класс <code class=\"code inline\">Figure</code> абстрактный: потому\n\tчто он не описывает реально существующую\n\tгеометрическую фигуру и, соответственно,\n\tобъект этого класса мы не будем создавать.\n</p>\n<p>\n\tПочему методы <code class=\"code inline\">getSquare</code> и <code class=\"code inline\">getPerimeter</code>\n\tабстрактные: потому что каждая фигура имеет\n\tсвой алгоритм вычисления площади и периметра\n\tи, соответственно, класс <code class=\"code inline\">Figure</code> не\n\tможет написать реализацию этих методов.\n</p>\n<p>\n\tЗачем нам вообще нужен класс <code class=\"code inline\">Figure</code>:\n\tчтобы наследовать от него и таким образом\n\tзаставить всех наследников реализовать указанные\n\tметоды.\n</p>\n<p>\n\tИтак, напишем реализацию класса <code class=\"code inline\">Figure</code>:\n</p>\n<div class=\"block\" data-file=\"Figure.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tabstract class Figure\n\t{\n\t\tabstract public function getSquare();\n\t\tabstract public function getPerimeter();\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть теперь мы хотим создать класс <code class=\"code inline\">Quadrate</code>\n\tдля описания геометрической фигуры квадрат.\n\tКак известно, у квадрата все стороны равны,\n\tпоэтому для описания квадрата нам нужно задать\n\tтолько его ширину.\n</p>\n<p>\n\tДавайте для этого сделаем приватное свойство\n\t<code class=\"code inline\">$a</code>, значение которого будет задаваться\n\tв конструкторе класса:\n</p>\n<div class=\"block\" data-file=\"Quadrate.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Quadrate\n\t{\n\t\tprivate $a;\n\t\t\n\t\tpublic function __construct($a)\n\t\t{\n\t\t\t$this-&gt;a = $a;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь унаследуем наш класс <code class=\"code inline\">Quadrate</code>\n\tот класса <code class=\"code inline\">Figure</code>:\n</p>\n<div class=\"block\" data-file=\"Quadrate.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Quadrate extends Figure\n\t{\n\t\tprivate $a;\n\t\t\n\t\tpublic function __construct($a)\n\t\t{\n\t\t\t$this-&gt;a = $a;\n\t\t}\n\t}\n\t\n\t/*\n\t\tКод класса не рабочий\n\t\tи будет выдавать ошибку,\n\t\tтак как мы не написали\n\t\tреализацию методов родителя.\n\t*/\n?&gt;</code>\n</div>\n<p>\n\tСейчас наша реализация класса <code class=\"code inline\">Quadrate</code>\n\tне рабочая, так как мы не написали реализацию\n\tабстрактных методов родителя.\n</p>\n<p>\n\tДавайте сделаем это:\n</p>\n<div class=\"block\" data-file=\"Quadrate.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Quadrate extends Figure\n\t{\n\t\tprivate $a;\n\t\t\n\t\tpublic function __construct($a)\n\t\t{\n\t\t\t$this-&gt;a = $a;\n\t\t}\n\t\t\n\t\tpublic function getSquare()\n\t\t{\n\t\t\treturn $this-&gt;a * $this-&gt;a;\n\t\t}\n\t\t\n\t\tpublic function getPerimeter()\n\t\t{\n\t\t\treturn 4 * $this-&gt;a;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте создадим квадрат со стороной <code class=\"number inline\">2</code>\n\tи найдем его площадь и периметр:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$quadrate = new Quadrate(2);\n\techo $quadrate-&gt;getSquare();    // выведет 4\n\techo $quadrate-&gt;getPerimeter(); // выведет 8\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте аналогичный класс <code class=\"code inline\">Rectangle</code>\n\t\t(<span class=\"translate-ru\">прямоугольник</span>), у которого будет\n\t\tдва приватных свойства: <code class=\"code inline\">$a</code> для ширины\n\t\tи <code class=\"code inline\">$b</code> для длины. Данный класс также\n\t\tдолжен наследовать от класса <code class=\"code inline\">Figure</code>\n\t\tи реализовывать его методы.\n\t</p>\n</div>\n\n<h2>Усложним</h2>\n<p>\n\tСейчас все методы класса <code class=\"code inline\">Figure</code> -\n\tабстрактные. Это, конечно же, не обязательно.\n\tПусть наш класс имеет еще и метод <code class=\"code inline\">getRatio</code>,\n\tкоторый будет находить отношение площади\n\tк периметру (то есть одно делить на второе).\n</p>\n<p>\n\tЭтот метод уже будет не абстрактный, а иметь\n\tреализацию, и все потомки смогут воспользоваться\n\tэтим методом.\n</p>\n<p>\n\tПочему мы можем написать реализацию этого\n\tметода прямо в классе <code class=\"code inline\">Figure</code>: потому\n\tчто этот метод будет одинаковым для всех потомков.\n</p>\n<p>\n\tИтак, добавим наш метод:\n</p>\n<div class=\"block\" data-file=\"Figure.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tabstract class Figure\n\t{\n\t\tabstract public function getSquare();\n\t\tabstract public function getPerimeter();\n\t\t\n\t\t// Метод для вычисления отношения площади к периметру:\n\t\tpublic function getRatio()\n\t\t{\n\t\t\treturn $this-&gt;getSquare() / $this-&gt;getPerimeter();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tОбратите внимание на следующее: хотя методы\n\t<code class=\"code inline\">getSquare</code> и <code class=\"code inline\">getPerimeter</code> абстрактные\n\tи не имеют реализации, мы их все равно можем\n\tиспользовать в своем методе <code class=\"code inline\">getRatio</code>,\n\tхотя реализация этих методов появится только\n\tв потомках.\n</p>\n<p>\n\tПрименим наш метод:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$quadrate = new Quadrate(2);\n\techo $quadrate-&gt;getSquare();    // выведет 4\n\techo $quadrate-&gt;getPerimeter(); // выведет 8\n\t\n\techo $quadrate-&gt;getRatio();     // выведет 0.5\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в класс <code class=\"code inline\">Figure</code> метод <code class=\"code inline\">getSquarePerimeterSum</code>,\n\t\tкоторый будет находить сумму площади и периметра.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/intro/","content":"\n\t\t\t\t<h1>Интерфейсы в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tКак вы уже знаете, абстрактные классы представляют\n\tсобой набор методов для своих потомков. Часть\n\tэтих методов может быть реализована в самом\n\tклассе, а часть методов может быть объявлена\n\tабстрактными и требовать реализации в дочерних\n\tклассах.\n</p>\n<p>\n\tПредставим себе ситуацию, когда ваш абстрактный\n\tкласс представляет собой только набор абстрактных\n\tпубличных методов, не добавляя методы с реализацией.\n</p>\n<p>\n\tФактически ваш родительский класс описывает\n\t<dfn>интерфейс</dfn> потомков, то есть набор\n\tих публичных методов, обязательных для реализации.\n</p>\n<p>\n\tЗачем нам такое нужно: чтобы при программировании\n\tсовершать меньше ошибок - описав все необходимые\n\tметоды в классе-родителе, мы можем быть уверенны\n\tв том, что все потомки их действительно реализуют.\n</p>\n<p>\n\tКогда это поможет: пусть мы создадим наш\n\tкласс-родитель и несколько потомков к нему.\n\tЕсли потом через некоторое время, например,\n\tчерез месяц, мы решим создать еще одного\n\tпотомка, наверняка мы уже забудем детали\n\tнашего кода и вполне можем забыть написать\n\tреализацию какого-нибудь метода в новом потомке.\n\tОднако сам PHP не позволит потерять метод\n\t- и просто выдаст ошибку.\n</p>\n<p>\n\tТо же самое касается другого программиста,\n\tработающего с вашим проектом. Пусть код класса-родителя\n\tписали вы, а затем ваш коллега решил создать\n\tеще одного потомка. У вашего коллеги также\n\tне получится потерять парочку методов.\n</p>\n<p>\n\tЕсть, однако, проблема: фактически мы сделали\n\tнаш класс-родитель для того, чтобы писать\n\tв нем абстрактные публичные методы, но мы\n\tсами или наш коллега имеем возможность случайно\n\tдобавить в этот класс не публичный метод\n\tили не абстрактный.\n</p>\n<p>\n\tПусть мы хотим физически запретить делать\n\tв родителе иные методы, кроме абстрактных\n\tпубличных. В PHP для этого вместо абстрактных\n\tклассов можно использовать <dfn>интерфейсы</dfn>.\n</p>\n<p>\n\tИнтерфейсы представляют собой классы, у которых\n\tвсе методы являются публичными и не имеющими\n\tреализации. Код методов должны реализовывать\n\tклассы-потомки интерфейсов.\n</p>\n<p>\n\tИнтерфейсы объявляются так же, как и обычные\n\tклассы, но используя ключевое слово <code class=\"code inline\">interface</code>\n\tвместо слова <code class=\"code inline\">class</code>.\n</p>\n<p>\n\tДля наследования от интерфейсов используется\n\tнемного другая терминология: говорят, что\n\tклассы не наследуют от интерфейсов, а <dfn>реализуют</dfn>\n\tих. Соответственно вместо слова <code class=\"code inline\">extends</code>\n\tследует использовать ключевое слово <code class=\"code inline\">implements</code>.\n</p>\n<div class=\"notice\">\n\t<p>\n\t\tНельзя создать объект интерфейса. Все методы\n\t\tинтерфейса должны быть объявлены как <code class=\"code inline\">public</code>\n\t\tи не должны иметь реализации. У интерфейса\n\t\tмогут быть только методы, но не свойства.\n\t\tНельзя также сделать интерфейс и класс с\n\t\tодним и тем же названием.\n\t</p>\n</div>\n\n<h2>Попробуем на практике</h2>\n<p>\n\tДавайте попробуем на практике. Решим задачу\n\tна фигуры из предыдущего рока, но уже используя\n\tинтерфейсы, а не абстрактные классы.\n</p>\n<p>\n\tИтак, теперь у нас дан интерфейс <code class=\"code inline\">Figure</code>:\n</p>\n<div class=\"block\" data-file=\"Figure.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface Figure\n\t{\n\t\tpublic function getSquare();\n\t\tpublic function getPerimeter();\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте напишем класс <code class=\"code inline\">Quadrate</code>, который\n\tбудет реализовывать методы этого интерфейса:\n</p>\n<div class=\"block\" data-file=\"Quadrate.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Quadrate implements Figure\n\t{\n\t\tprivate $a;\n\t\t\n\t\tpublic function __construct($a)\n\t\t{\n\t\t\t$this-&gt;a = $a;\n\t\t}\n\t\t\n\t\tpublic function getSquare()\n\t\t{\n\t\t\treturn $this-&gt;a * $this-&gt;a;\n\t\t}\n\t\t\n\t\tpublic function getPerimeter()\n\t\t{\n\t\t\treturn 4 * $this-&gt;a;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак это работает: если забыть реализовать\n\tкакой-нибудь метод, описанный в интерфейсе,\n\tPHP выдаст нам фатальную ошибку. Давайте\n\tреализуем также класс <code class=\"code inline\">Rectangle</code>:\n</p>\n<div class=\"block\" data-file=\"Rectangle.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Rectangle implements Figure\n\t{\n\t\tprivate $a;\n\t\tprivate $b;\n\t\t\n\t\tpublic function __construct($a, $b)\n\t\t{\n\t\t\t$this-&gt;a = $a;\n\t\t\t$this-&gt;b = $b;\n\t\t}\n\t\t\n\t\tpublic function getSquare()\n\t\t{\n\t\t\treturn $this-&gt;a * $this-&gt;b;\n\t\t}\n\t\t\n\t\tpublic function getPerimeter()\n\t\t{\n\t\t\treturn 2 * ($this-&gt;a + $this-&gt;b);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Disk</code> (<span class=\"translate-ru\">круг</span>),\n\t\tреализующий интерфейс <code class=\"code inline\">Figure</code>.\n\t</p>\n</div>\n\n<h2>Замечание</h2>\n<p>\n\tКак уже было написано выше, не может быть\n\tинтерфейса и класса с одинаковым названием.\n\tЭто создает некоторые проблемы с придумыванием\n\tназваний. Например, мы хотим сделать класс\n\t<code class=\"code inline\">User</code>, реализующий интерфейс <code class=\"code inline\">User</code>.\n\tКак мы видим, у нас конфликт имен. Для его\n\tразрешения, нужно или класс назвать по-другому,\n\tили интерфейс.\n</p>\n<p>\n\tОбщепринято в таком случае название интерфейса\n\tначать с маленькой буквы <code class=\"code inline\">i</code>, чтобы\n\tпоказать, что это интерфейс, а не класс.\n\tТо есть в нашем случае мы сделаем интерфейс\n\t<code class=\"code inline\">iUser</code>, а реализовывать его будет класс\n\t<code class=\"code inline\">User</code>. Такой подход мы иногда будем\n\tприменять в следующих уроках.\n</p>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/applying/","content":"\n\t\t\t\t<h1>Применение интерфейсов в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tИтак, мы уже выяснили, что интерфейсы хороший\n\tспособ контролировать то, что реализованы\n\tвсе необходимые методы класса.\n</p>\n<p>\n\tДавайте рассмотрим еще один, более практический,\n\tпример. Пусть у нас есть класс, который будет\n\tхранить в себе массив объектов-фигур:\n</p>\n<div class=\"block\" data-file=\"FiguresCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass FiguresCollection\n\t{\n\t\tprivate $figures = []; // массив для фигур\n\t}\n?&gt;</code>\n</div>\n<p>\n\tРеализуем в нашем классе метод <code class=\"code inline\">addFigure</code>\n\tдля добавления объектов в коллекцию:\n</p>\n<div class=\"block\" data-file=\"FiguresCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass FiguresCollection\n\t{\n\t\tprivate $figures = [];\n\t\t\n\t\t// Параметром передается объект с фигурой:\n\t\tpublic function addFigure($figure)\n\t\t{\n\t\t\t$this-&gt;figures[] = $figure;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tОчевидно, что мы рассчитываем на то, что\n\tпараметром метода <code class=\"code inline\">addFigure</code> будет\n\tпередаваться объект с фигурой. Однако за\n\tэтим нет никакого контроля!\n</p>\n<p>\n\tДавайте используем подсказку для типов и\n\tявно укажем тип объектов как <code class=\"code inline\">Figure</code>:\n</p>\n<div class=\"block\" data-file=\"FiguresCollection.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass FiguresCollection\n\t{\n\t\tprivate $figures = [];\n\t\t\n\t\tpublic function addFigure(Figure $figure)\n\t\t{\n\t\t\t$this-&gt;figures[] = $figure;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте разберемся с тем, что мы сделали.\n</p>\n<p>\n\tЕсли бы <code class=\"code inline\">Figure</code> был реально существующим\n\tклассом то в параметр метода мы смогли бы\n\tпередать объекты этого класса, а также и\n\tего наследников.\n</p>\n<p>\n\tУ нас, однако, <code class=\"code inline\">Figure</code> - это интерфейс.\n\tВ таком случае подсказка обозначает то, что\n\tпараметром метода могут быть переданы только\n\tобъекты класса, реализующих наш интерфейс.\n</p>\n<p>\n\tДавайте попробуем создать объект нашего класса\n\tи добавить в него фигуры:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$figuresCollection = new FiguresCollection;\n\t\n\t// Добавим парочку квадратов:\n\t$figuresCollection-&gt;add(new Quadrate(2));\n\t$figuresCollection-&gt;add(new Quadrate(3));\n\t\n\t// Добавим парочку прямоугольников:\n\t$figuresCollection-&gt;add(new Rectangle(2, 3));\n\t$figuresCollection-&gt;add(new Rectangle(3, 4));\n?&gt;</code>\n</div>\n<p>\n\tПопытка добавить объект какого-либо другого\n\tкласса приведет к ошибке:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$figuresCollection = new FiguresCollection;\n\t\n\tclass Test {}; // какой-то другой класс\n\t$figuresCollection-&gt;add(new Test); // выдаст ошибку\n?&gt;</code>\n</div>\n<p>\n\tЧто на практике дает нам такой контроль:\n\tтак как все фигуры, добавленные в коллекцию,\n\tреализуют интерфейс <code class=\"code inline\">Figure</code>, мы можем\n\tбыть уверены, что у каждой из них будет метод\n\t<code class=\"code inline\">getSquare</code> и метод <code class=\"code inline\">getPerimeter</code>.\n</p>\n<p>\n\tВозможно в дальнейшем кроме квадрата и прямоугольника\n\tпоявится, например, еще и треугольник. В\n\tэтом случае и у треугольника также будут\n\tметоды <code class=\"code inline\">getSquare</code> и <code class=\"code inline\">getPerimeter</code>.\n</p>\n<p>\n\tНа практике это дает нам следующее: мы можем\n\tв классе <code class=\"code inline\">FiguresCollection</code> сделать,\n\tк примеру, метод <code class=\"code inline\">getTotalSquare</code>, находящий\n\tполную площадь фигур коллекции. В этом методе\n\tмы будем перебирать циклом массив фигур и\n\tу каждой фигуры вызывать метод <code class=\"code inline\">getSquare</code>.\n</p>\n<p>\n\tТак как каждая фигура реализует интерфейс\n\t<code class=\"code inline\">Figure</code>, мы можем быть на <code class=\"unit inline\">100%</code>\n\tуверены в том, что у каждой фигуры будет\n\tэтот метод <code class=\"code inline\">getSquare</code>.\n</p>\n<p>\n\tИтак, вот реализация метода:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass FiguresCollection\n\t{\n\t\tprivate $figures = [];\n\t\t\n\t\tpublic function addFigure(Figure $figure)\n\t\t{\n\t\t\t$this-&gt;figures[] = $figure;\n\t\t}\n\t\t\n\t\t// Найдем полную площадь:\n\t\tpublic function getTotalSquare()\n\t\t{\n\t\t\t$sum = 0;\n\t\t\t\n\t\t\tforeach ($this-&gt;figures as $figure) {\n\t\t\t\t$sum += $figure-&gt;getSquare(); // используем метод getSquare\n\t\t\t}\n\t\t\t\n\t\t\treturn $sum;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код реализуйте такой\n\t\tже класс <code class=\"code inline\">FiguresCollection</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в класс <code class=\"code inline\">FiguresCollection</code>\n\t\tметод <code class=\"code inline\">getTotalPerimeter</code> для нахождения\n\t\tсуммарного периметра всех фигур.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/parameters/","content":"\n\t\t\t\t<h1>Параметры в методах интерфейсов в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПри описании методов в интерфейсах необходимо\n\tуказывать не только имена самих методов,\n\tно и принимаемые ими параметры.\n</p>\n<p>\n\tДавайте посмотрим на примере. Пусть у нас\n\tдан интерфейс <code class=\"code inline\">iMath</code>, описывающий класс\n\tдля математических операций сложения, вычитания,\n\tумножения и деления. Пусть этот интерфейс\n\tбудет выглядеть так:\n</p>\n<div class=\"block\" data-file=\"iMath.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iMath\n\t{\n\t\tpublic function sum();      // сложить\n\t\tpublic function subtract(); // вычесть\n\t\tpublic function multiply(); // умножить\n\t\tpublic function divide();   // поделить\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСейчас методы нашего интерфейса не принимают\n\tникаких параметров. И на самом деле методы\n\tкласса, который будет реализовывать этот\n\tинтерфейс, также не должны будут принимать\n\tпараметров, иначе будет ошибка.\n</p>\n<p>\n\tДавайте укажем параметры методов в нашем\n\tинтерфейсе:\n</p>\n<div class=\"block\" data-file=\"iMath.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iMath\n\t{\n\t\tpublic function sum($a, $b);      // сложить\n\t\tpublic function subtract($a, $b); // вычесть\n\t\tpublic function multiply($a, $b); // умножить\n\t\tpublic function divide($a, $b);   // поделить\n\t}\n?&gt;</code>\n</div>\n<p>\n\tНапишем теперь реализацию нашего интерфейса:\n</p>\n<div class=\"block\" data-file=\"Math.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Math implements iMath\n\t{\n\t\tpublic function sum($a, $b)\n\t\t{\n\t\t\treturn $a + $b;\n\t\t}\n\t\t\n\t\tpublic function subtract($a, $b)\n\t\t{\n\t\t\treturn $a - $b;\n\t\t}\n\t\t\n\t\tpublic function multiply($a, $b)\n\t\t{\n\t\t\treturn $a * $b;\n\t\t}\n\t\t\n\t\tpublic function divide($a, $b)\n\t\t{\n\t\t\treturn $a / $b;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tЕсли попытаться в нашем классе задать другое\n\tколичество параметров - у нас это просто\n\tне получится: PHP выдаст ошибку. Таким образом\n\tмы не сможем ни случайно забыть какой-то\n\tпараметр, ни случайно добавить лишний.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tПусть у нас дан такой интерфейс <code class=\"code inline\">iUser</code>:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iUser\n\t{\n\t\tpublic function setName($name); // установить имя\n\t\tpublic function getName();      // получить имя\n\t\tpublic function setAge($age);   // установить возраст\n\t\tpublic function getAge();       // получить возраст\n\t}\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">User</code>, который будет\n\t\tреализовывать данный интерфейс.\n\t</p>\n</div>\n\n<!--\n<h2>Тип параметров</h2>\n<p>\n\tПри указании параметров можно также явно\n\tзадать их тип. Укажем, к примеру, что все\n\tпараметры наших методов будут иметь тип <code class=\"code inline\">float</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iMath\n\t{\n\t\tpublic function sum(float $a, float $b); // сложить\n\t\tpublic function subtract(float $a, float $b); // вычесть\n\t\tpublic function multiply(float $a, float $b); // умножить\n\t\tpublic function divide(float $a, float $b); // поделить\n\t}\n?&gt;</code>\n</div>\n<p>\n\tУказав типы параметров в интерфейсе мы обяжем\n\tкласс, реализующий этот интерфейс, также\n\tуказать такой же тип параметров - в противном\n\tслучае PHP выдаст фатальную ошибку.\n</p>\n<p>\n\tУкажем тип параметров в нашем классе <code class=\"code inline\">Math</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Math implements iMath\n\t{\n\t\tpublic function sum(float $a, float $b)\n\t\t{\n\t\t\treturn $a + $b;\n\t\t}\n\t\t\n\t\tpublic function subtract(float $a, float $b)\n\t\t{\n\t\t\treturn $a - $b;\n\t\t}\n\t\t\n\t\tpublic function multiply(float $a, float $b)\n\t\t{\n\t\t\treturn $a * $b;\n\t\t}\n\t\t\n\t\tpublic function divide(float $a, float $b)\n\t\t{\n\t\t\treturn $a / $b;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n-->\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/constructor-declaring/","content":"\n\t\t\t\t<h1>Объявление конструктора в интерфейсе</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ интерфейсе также можно объявить конструктор\n\tкласса. Посмотрим на примере. Пусть мы решили\n\tсделать класс <code class=\"code inline\">Rectangle</code>, в котором\n\tбудут методы для нахождения площади, периметра,\n\tа также конструктор, принимающий два параметра.\n\tДавайте опишем наш класс с помощью интерфейса:\n</p>\n<div class=\"block\" data-file=\"iRectangle.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iRectangle\n\t{\n\t\tpublic function __construct($a, $b); // конструктор с двумя параметрами\n\t\tpublic function getSquare();\n\t\tpublic function getPerimeter();\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте напишем реализацию нашего интерфейса\n\t<code class=\"code inline\">iRectangle</code>:\n</p>\n<div class=\"block\" data-file=\"Rectangle.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Rectangle implements iRectangle\n\t{\n\t\tprivate $a;\n\t\tprivate $b;\n\t\t\n\t\tpublic function __construct($a, $b)\n\t\t{\n\t\t\t$this-&gt;a = $a;\n\t\t\t$this-&gt;b = $b;\n\t\t}\n\t\t\n\t\tpublic function getSquare()\n\t\t{\n\t\t\treturn $this-&gt;a * $this-&gt;b;\n\t\t}\n\t\t\n\t\tpublic function getPerimeter()\n\t\t{\n\t\t\treturn 2 * ($this-&gt;a + $this-&gt;b);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tЧто нам дало объявление конструктора в интерфейсе?\n\tВо-первых, мы не забудем реализовать конструктор\n\tв классе. Во-вторых, интерфейс явно указывает,\n\tчто конструктор класса должен принимать два\n\tпараметра: ни больше, ни меньше. Это также\n\tпредохранит нас от случайной ошибки.\n</p>\n<p>\n\tПочему мы создали отдельный интерфейс <code class=\"code inline\">iRectangle</code>,\n\tа не добавили конструктор в интерфейс <code class=\"code inline\">Figure</code>?\n\tПотому что все фигуры имеют разное количество\n\tсторон и, соответственно, разное количество\n\tпараметров в конструкторе. Поэтому нам пришлось\n\tсоздать отдельный, более точный интерфейс\n\tконкретно для прямоугольников.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tСделайте интерфейс <code class=\"code inline\">iCube</code>, который\n\t\tбудет описывать фигуру Куб. Пусть ваш интерфейс\n\t\tописывает конструктор, параметром принимающий\n\t\tсторону куба, а также методы для получения\n\t\tобъема куба и площади поверхности.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Cube</code>, реализующий интерфейс\n\t\t<code class=\"code inline\">iCube</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте интерфейс <code class=\"code inline\">iUser</code>, который\n\t\tбудет описывать юзера. Предполагается, что\n\t\tу юзера будет имя и возраст и эти поля будут\n\t\tпередаваться параметрами конструктора. Пусть\n\t\tваш интерфейс также задает то, что у юзера\n\t\tбудут геттеры (но не сеттеры) для имени и\n\t\tвозраста.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">User</code>, реализующий интерфейс\n\t\t<code class=\"code inline\">iUser</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/inheritance-from-interface/","content":"\n\t\t\t\t<h1>Наследование интерфейсов друг от друга</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tИнтерфейсы, так же, как и классы, могут наследовать\n\tдруг от друга с помощью оператора <code class=\"code inline\">extends</code>.\n\tДавайте посмотрим на примере. Пусть у нас\n\tесть такой интерфейс из прошлого урока:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iRectangle\n\t{\n\t\tpublic function __construct($a, $b);\n\t\tpublic function getSquare();\n\t\tpublic function getPerimeter();\n\t}\n?&gt;</code>\n</div>\n<p>\n\tОднако у нас уже есть интерфейс <code class=\"code inline\">iFigure</code>,\n\tописывающий часть методов нашего интерфейса:\n</p>\n<div class=\"block\" data-file=\"iFigure.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iFigure\n\t{\n\t\tpublic function getSquare();\n\t\tpublic function getPerimeter();\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем так, чтобы интерфейс <code class=\"code inline\">iRectangle</code>\n\tнаследовал методы интерфейса <code class=\"code inline\">iFigure</code>:\n</p>\n<div class=\"block\" data-file=\"iRectangle.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iRectangle extends iFigure\n\t{\n\t\tpublic function __construct($a, $b);\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте интерфейс <code class=\"code inline\">iUser</code> с методами\n\t\t<code class=\"code inline\">getName</code>, <code class=\"code inline\">setName</code>, <code class=\"code inline\">getAge</code>,\n\t\t<code class=\"code inline\">setAge</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте интерфейс <code class=\"code inline\">iEmployee</code>, наследующий\n\t\tот интерфейса <code class=\"code inline\">iUser</code> и добавляющий\n\t\tв него методы <code class=\"code inline\">getSalary</code> и <code class=\"code inline\">setSalary</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Employee</code>, реализующий\n\t\tинтерфейс <code class=\"code inline\">iEmployee</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/instanceof/","content":"\n\t\t\t\t<h1>Интерфейсы и instanceof в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tС помощью <code class=\"code inline\">instanceof</code> можно проверять,\n\tреализует какой-то класс заданный интерфейс\n\tили нет. Посмотрим на примере. Пусть у нас\n\tесть вот такой класс:\n</p>\n<div class=\"block\" data-file=\"Quadrate.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Quadrate implements iFigure\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСоздадим объект этого класса и проверим его\n\tоператором <code class=\"code inline\">instanceof</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$quadrate = new Quadrate;\n\t\n\tvar_dump($quadrate instanceof Quadrate); // выведет true\n\tvar_dump($quadrate instanceof Figure);   // выведет true\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте интерфейс <code class=\"code inline\">Figure3d</code> (<span class=\"translate-ru\">трехмерная\n\t\tфигура</span>), который будет иметь метод <code class=\"code inline\">getVolume</code>\n\t\t(<span class=\"translate-ru\">получить объем</span>) и метод <code class=\"code inline\">getSurfaceSquare</code>\n\t\t(<span class=\"translate-ru\">получить площадь поверхности</span>).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Cube</code>, который будет\n\t\tреализовывать интерфейс <code class=\"code inline\">Figure3d</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте несколько объектов класса <code class=\"code inline\">Quadrate</code>,\n\t\tнесколько объектов класса <code class=\"code inline\">Rectangle</code>\n\t\tи несколько объектов класса <code class=\"code inline\">Cube</code>.\n\t\tЗапишите их в массив <code class=\"code inline\">$arr</code> в случайном\n\t\tпорядке.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПереберите циклом массив <code class=\"code inline\">$arr</code> и выведите\n\t\tна экран только площади объектов реализующих\n\t\tинтерфейс <code class=\"code inline\">iFigure</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПереберите циклом массив <code class=\"code inline\">$arr</code> и выведите\n\t\tдля плоских фигур их площади, а для объемных\n\t\t- площади их поверхности.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/several-interfaces-implementation/","content":"\n\t\t\t\t<h1>Несколько интерфейсов в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ PHP нет множественного наследования - каждый\n\tкласс может иметь только одного родителя.\n\tС интерфейсами дело, однако, обстоит по другому:\n\tкаждый класс может реализовывать любое количество\n\tинтерфейсов. Для этого имена интерфейсов\n\tнужно перечислить через запятую после ключевого\n\tслова <code class=\"code inline\">implements</code>.\n</p>\n<p>\n\tВ этом проявляется еще одно отличие интерфейсов\n\tот абстрактных классов - можно реализовывать\n\tмного интерфейсов, но унаследовать несколько\n\tабстрактных классов нельзя.\n</p>\n<p>\n\tДавайте попробуем на практике. Пусть кроме\n\tинтерфейса <code class=\"code inline\">iFigure</code> у нас также есть\n\tинтерфейс <code class=\"code inline\">iTetragon</code> (<span class=\"translate-ru\">четырехугольник</span>).\n\tМетоды этого интерфейса будут реализовывать\n\tклассы <code class=\"code inline\">Quadrate</code> и <code class=\"code inline\">Rectangle</code>,\n\tтак как у них <code class=\"number inline\">4</code> стороны, но не класс\n\t<code class=\"code inline\">Disk</code>.\n</p>\n<p>\n\tПусть интерфейс <code class=\"code inline\">iTetragon</code> описывает\n\tгеттеры для всех четырех сторон четырехугольника:\n</p>\n<div class=\"block\" data-file=\"iTetragon.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iTetragon\n\t{\n\t\tpublic function getA();\n\t\tpublic function getB();\n\t\tpublic function getC();\n\t\tpublic function getD();\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть также у нас есть интерфейс <code class=\"code inline\">iFigure</code>,\n\tкоторый мы уже делали ранее:\n</p>\n<div class=\"block\" data-file=\"iFigure.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iFigure\n\t{\n\t\tpublic function getSquare();\n\t\tpublic function getPerimeter();\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСделаем так, чтобы класс <code class=\"code inline\">Quadrate</code>\n\tреализовывал два интерфейса. Для этого перечислим\n\tоба интерфейса через запятую после ключевого\n\tслова <code class=\"code inline\">implements</code>:\n</p>\n<div class=\"block\" data-file=\"Quadrate.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Quadrate implements iFigure, iTetragon\n\t{\n\t\t// тут будет реализация\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДоработаем теперь наш класс <code class=\"code inline\">Quadrate</code>,\n\tчтобы он реализовывал интерфейс <code class=\"code inline\">iTetragon</code>.\n\tПонятно, что наш квадрат является вырожденным\n\tслучаем четырехугольника, ведь у квадрата\n\tвсе стороны равны. Поэтому все новые методы\n\tбудут возвращать одно и тоже - ширину квадрата:\n</p>\n<div class=\"block\" data-file=\"Quadrate.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Quadrate implements iFigure, iTetragon\n\t{\n\t\tprivate $a;\n\t\t\n\t\tpublic function __construct($a)\n\t\t{\n\t\t\t$this-&gt;a = $a;\n\t\t}\n\t\t\n\t\tpublic function getA()\n\t\t{\n\t\t\treturn $this-&gt;a;\n\t\t}\n\t\t\n\t\tpublic function getB()\n\t\t{\n\t\t\treturn $this-&gt;a;\n\t\t}\n\t\t\n\t\tpublic function getC()\n\t\t{\n\t\t\treturn $this-&gt;a;\n\t\t}\n\t\t\n\t\tpublic function getD()\n\t\t{\n\t\t\treturn $this-&gt;a;\n\t\t}\n\t\t\n\t\tpublic function getSquare()\n\t\t{\n\t\t\treturn $this-&gt;a * $this-&gt;a;\n\t\t}\n\t\t\n\t\tpublic function getPerimeter()\n\t\t{\n\t\t\treturn 4 * $this-&gt;a;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tОчевидно, что в прямоугольнике уже не все\n\tстороны одинаковы, а только противоположные.\n\tВ этом случае новые методы станут немного\n\tотличаться. Ну, и в какой-нибудь трапеции\n\tвообще все <code class=\"number inline\">4</code> стороны будут разные.\n</p>\n<p>\n\tОднако, не имеет значения, что за фигуру\n\tмы будем рассматривать - важно, что все эти\n\tфигуры будут иметь описанные методы (пусть\n\tнекоторые фигуры и вырожденные) и работать\n\tоднотипно.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tСделайте так, чтобы класс <code class=\"code inline\">Rectangle</code>\n\t\tтакже реализовывал два интерфейса: и <code class=\"code inline\">iFigure</code>,\n\t\tи <code class=\"code inline\">iTetragon</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте интерфейс <code class=\"code inline\">iCircle</code> с методами\n\t\t<code class=\"code inline\">getRadius</code> и <code class=\"code inline\">getDiameter</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте так, чтобы класс <code class=\"code inline\">Disk</code> также\n\t\tреализовывал два интерфейса: и <code class=\"code inline\">iFigure</code>,\n\t\tи <code class=\"code inline\">iCircle</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/inheritance-and-implementation/","content":"\n\t\t\t\t<h1>Наследование от класса и реализация интерфейса</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tКласс может наследовать от другого класса\n\tи при этом реализовывать какой-то интерфейс.\n\tРассмотрим на практическом примере.\n</p>\n<p>\n\tПусть мы хотим сделать класс <code class=\"code inline\">Programmer</code>,\n\tу которого будет имя, зарплата и список языков,\n\tкоторые знает программист.\n</p>\n<p>\n\tПока наше описание класса весьма расплывчато:\n\tда, в классе будет имя, зарплата, языки -\n\tно какие методы будут в нашем классе?\n</p>\n<p>\n\tДавайте более точно опишем наш класс с помощью\n\tинтерфейса <code class=\"code inline\">iProgrammer</code>:\n</p>\n<div class=\"block\" data-file=\"iProgrammer.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iProgrammer\n\t{\n\t\tpublic function __construct($name, $salary);\n\t\tpublic function getName();\n\t\tpublic function getSalary();\n\t\tpublic function getLangs();\n\t\tpublic function addLang($lang);\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть мы покопались в уже реализованных нами\n\tклассах и, оказывается, у нас уже есть похожий\n\tкласс <code class=\"code inline\">Employee</code>. Он реализует не все\n\tметоды класса <code class=\"code inline\">Programmer</code>, но часть.\n\tВот код уже существующего у нас класса:\n</p>\n<div class=\"block\" data-file=\"Employee.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Employee\n\t{\n\t\tprivate $name;\n\t\tprivate $salary;\n\t\t\n\t\tpublic function __construct($name, $salary)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;salary = $salary;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getSalary()\n\t\t{\n\t\t\treturn $this-&gt;salary;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tЛогично в нашем случае сделать так, чтобы\n\tнаш новый класс <code class=\"code inline\">Programmer</code> унаследовал\n\tчасть необходимых себе методов от класса\n\t<code class=\"code inline\">Employee</code> (а часть мы потом реализуем\n\tуже в самом новом классе):\n</p>\n<div class=\"block\" data-file=\"Programmer.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Programmer extends Employee\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПри этом нам известно, что класс <code class=\"code inline\">Pogrammer</code>\n\tдолжен реализовывать интерфейс <code class=\"code inline\">iProgrammer</code>:\n</p>\n<div class=\"block\" data-file=\"Programmer.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Programmer implements iProgrammer\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте совместим наследование от класса\n\t<code class=\"code inline\">Employee</code> и реализацию интерфейса <code class=\"code inline\">iProgrammer</code>:\n</p>\n<div class=\"block\" data-file=\"Programmer.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Programmer extends Employee implements iProgrammer\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПолучится, что наш класс <code class=\"code inline\">Pogrammer</code>\n\tунаследует от класса <code class=\"code inline\">Employee</code> методы\n\t<code class=\"code inline\">__construct</code>, <code class=\"code inline\">getName</code> и <code class=\"code inline\">getSalary</code>,\n\tа методы <code class=\"code inline\">addLang</code> и <code class=\"code inline\">getLangs</code>\n\tнам придется реализовать:\n</p>\n<div class=\"block\" data-file=\"Programmer.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Programmer extends Employee implements iProgrammer\n\t{\n\t\tpublic function addLang($lang)\n\t\t{\n\t\t\t// реализация\n\t\t}\n\t\t\n\t\tpublic function getLangs()\n\t\t{\n\t\t\t// реализация\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tИнтерфейсу <code class=\"code inline\">iProgrammer</code> все равно,\n\tродные методы у класса или унаследованные\n\t- главное, чтобы все описанные методы были\n\tреализованы.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте код моего класса <code class=\"code inline\">Employee</code>\n\t\tи код интерфейса <code class=\"code inline\">iProgrammer</code>. Не копируйте\n\t\tмою заготовку класса <code class=\"code inline\">Programmer</code> -\n\t\tне подсматривая в мой код реализуйте этот\n\t\tкласс самостоятельно.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/constants/","content":"\n\t\t\t\t<h1>Константы в интерфейсе в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tИнтерфейсы не могут содержать свойства классов,\n\tно могут содержать константы. Константы интерфейсов\n\tработают точно так же, как и константы классов,\n\tза исключением того, что они не могут быть\n\tпереопределены наследующим классом или интерфейсом.\n</p>\n<p>\n\tДля примера сделаем интерфейс <code class=\"code inline\">iSphere</code>,\n\tкоторый будет описывать класс для работы\n\tс шаром. В этом шаре нам надо будет найти\n\tобъем и площадь поверхности. Для этого нам\n\tпотребуется число Пи. Зададим его как константу\n\tнашего интерфейса:\n</p>\n<div class=\"block\" data-file=\"iSphere.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iSphere\n\t{\n\t\tconst PI = 3.14; // число ПИ как константа\n\t\t\n\t\t// Конструктор шара:\n\t\tpublic function __construct($radius);\n\t\t\n\t\t// Метод для нахождения объема шара:\n\t\tpublic function getVolume();\n\t\t\n\t\t// Метод для нахождения площади поверхности шара:\n\t\tpublic function getSquare();\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Sphere</code>, который будет\n\t\tреализовывать интерфейс <code class=\"code inline\">iSphere</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/interfaces/functions/","content":"\n\t\t\t\t<h1>Функции для работы с интерфейсами в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<h2>Функция interface_exists</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.interface-exists.php\"><code class=\"code inline\">interface_exists</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас есть интерфейс <code class=\"code inline\">iTest1</code>\n\t\tи нет интерфейса <code class=\"code inline\">iTest2</code>.\n\t</p>\n\t<p>\n\t\tПроверьте, что выведет функция <code class=\"code inline\">interface_exists</code>\n\t\tдля интерфейса <code class=\"code inline\">iTest1</code> и для интерфейса\n\t\t<code class=\"code inline\">iTest2</code>.\n\t</p>\n</div>\n\n<h2>Функция get_declared_interfaces</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-declared-interfaces.php\"><code class=\"code inline\">get_declared_interfaces</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыведите на экран список всех объявленных\n\t\tинтерфейсов.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/traits/intro/","content":"\n\t\t\t\t<h1>Работа с трейтами в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tКак вы уже знаете, в PHP нельзя наследовать\n\tот нескольких классов сразу, только от одного.\n\tРанее мы уже проходили решение этой проблемы:\n\tвместо наследования использовать объекты\n\tодних классов внутри других.\n</p>\n<p>\n\tВ PHP есть и другой способ. Он заключается\n\tв использовании <dfn>трейтов</dfn>. Трейт представляет\n\tсобой набор свойств и методов, которые можно\n\tвключить в другой класс. При этом свойства\n\tи методы трейта будут восприниматься классом\n\tбудто свои.\n</p>\n<p>\n\tСинтаксис трейта такой же как и у класса,\n\tза исключением того, что имя трейта нужно\n\tобъявлять с помощью ключевого слова <code class=\"code inline\">trait</code>.\n</p>\n<p>\n\tЭкземпляр трейта нельзя создать - трейты\n\tпредназначены только для подключения к другим\n\tклассам. Само подключение осуществляется\n\tс помощью команды <code class=\"code inline\">use</code>, после которой\n\tчерез пробел указывается имя подключаемого\n\tтрейта. Данная команда пишется в начале класса.\n</p>\n<p>\n\tДавайте посмотрим применение трейтов на практическом\n\tпримере. Пусть у нас дан вот такой трейт\n\t<code class=\"code inline\">Helper</code>, содержащий приватные свойства\n\t<code class=\"code inline\">name</code> и <code class=\"code inline\">age</code>, а также их геттеры:\n</p>\n<div class=\"block\" data-file=\"Helper.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait Helper\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть у нас также есть вот такой класс <code class=\"code inline\">User</code>,\n\tв конструкторе которого задаются свойства\n\t<code class=\"code inline\">name</code> и <code class=\"code inline\">age</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь добавим геттеры для свойств\n\tнашего класса <code class=\"code inline\">User</code>. Только не будем\n\tих записывать в самом классе, а просто подключим\n\tтрейт <code class=\"code inline\">Helper</code>, в котором эти методы\n\tуже реализованы:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tuse Helper; // подключаем трейт\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПосле подключения трейта в нашем классе появятся\n\tметоды и свойства этого трейта. При этом\n\tобращаться мы к ним будем будто к методам\n\tи свойствам самого класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 30);\n\techo $user-&gt;getName(); // выведет 'john'\n\techo $user-&gt;getAge();  // выведет 30\n?&gt;</code>\n</div>\n<p>\n\tДля того, чтобы продемонстрировать преимущества\n\tтрейтов, давайте сделаем еще один класс <code class=\"code inline\">City</code>\n\t(город). У города также будет имя и возраст,\n\tоднако, логично, что город и юзер не могут\n\tнаследовать от одного родителя, так представляют\n\tсобой немного разные сущности, пусть и имеющие\n\tпохожие методы.\n</p>\n<p>\n\tПоэтому воспользуемся созданным нами трейтом\n\t<code class=\"code inline\">Helper</code> и в классе <code class=\"code inline\">City</code>:\n</p>\n<div class=\"block\" data-file=\"City.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass City\n\t{\n\t\tuse Helper;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нашего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$city = new City('Minsk', 1000);\n\techo $city-&gt;getName(); // выведет 'Minsk'\n\techo $city-&gt;getAge();  // выведет 1000\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте класс <code class=\"code inline\">Country</code> со свойствами\n\t\t<code class=\"code inline\">name</code>, <code class=\"code inline\">age</code>, <code class=\"code inline\">population</code>\n\t\tи геттерами для них. Пусть наш класс для\n\t\tсокращения своего кода использует уже созданный\n\t\tнами трейт <code class=\"code inline\">Helper</code>.\n\t</p>\n</div>\n\n<h2>Несколько трейтов</h2>\n<p>\n\tВ классе можно использовать не один, а несколько\n\tтрейтов. В этом и проявляется их преимущество\n\tперед наследованием. Нужные для использования\n\tв классе трейты можно указать через запятую\n\tпосле ключевого слова <code class=\"code inline\">use</code>.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tСделайте <code class=\"number inline\">3</code> трейта с названиями <code class=\"code inline\">Trait1</code>,\n\t\t<code class=\"code inline\">Trait2</code> и <code class=\"code inline\">Trait3</code>. Пусть в первом\n\t\tтрейте будет метод <code class=\"code inline\">method1</code>, возвращающий\n\t\t<code class=\"number inline\">1</code>, во втором трейте - метод <code class=\"code inline\">method2</code>,\n\t\tвозвращающий <code class=\"number inline\">2</code>, а в третьем трейте\n\t\t- метод <code class=\"code inline\">method3</code>, возвращающий <code class=\"number inline\">3</code>.\n\t\tПусть все эти методы будут приватными.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Test</code>, использующий\n\t\tвсе три созданных нами трейта. Сделайте в\n\t\tэтом классе публичный метод <code class=\"code inline\">getSum</code>,\n\t\tвозвращающий сумму результатов методов подключенных\n\t\tтрейтов.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/traits/methods-conflicts/","content":"\n\t\t\t\t<h1>Разрешение конфликтов в трейтах</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tТак как один класс может использовать несколько\n\tтрейтов, то нас может поджидать проблема,\n\tвозникающая тогда, когда два трейта имеют\n\tодноименные методы.\n</p>\n<p>\n\tВ этом случае PHP выдаст фатальную ошибку.\n\tЧтобы поправить ситуацию, нужно будет разрешить\n\tконфликт имен явным образом. Как это делается\n\t- посмотрим на практике.\n</p>\n<p>\n\tПусть у нас есть два трейта с одинаковым\n\tметодом <code class=\"code inline\">method</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait Trait1\n\t{\n\t\tprivate function method()\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\t\n\ttrait Trait2\n\t{\n\t\tprivate function method()\n\t\t{\n\t\t\treturn 2;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть у нас также есть класс <code class=\"code inline\">Test</code>,\n\tиспользующий оба наших трейта. Если просто\n\tподключить оба трейта к нашему классу, то\n\tPHP выдаст ошибку, так как у трейтов есть\n\tсовпадающий методы:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Данный код выдаст ошибку!\n\tclass Test\n\t{\n\t\tuse Trait1, Trait2; // подключаем трейты\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте разрешим (в данном контексте это\n\tслово значит <i>разрулим</i>) конфликт имен\n\tнаших трейтов. Для этого существует специальный\n\tоператор <code class=\"code inline\">insteadof</code> (переводится <span class=\"translate-ru\">вместо\n\tчего-то</span>). С помощью этого оператора\n\tбудем использовать метод <code class=\"code inline\">method</code> трейта\n\t<code class=\"code inline\">Trait1</code> вместо такого же метода трейта\n\t<code class=\"code inline\">Trait2</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tuse Trait1, Trait2 {\n\t\t\tTrait1::method insteadof Trait2;\n\t\t}\n\t}\n\t\n\tnew Test;\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, синтаксис тут следующий: вначале\n\tимя трейта, потом два двоеточия, потом имя\n\tметода, потом наш оператор <code class=\"code inline\">insteadof</code>\n\tи имя второго трейта.\n</p>\n<p>\n\tДавайте проверим:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tuse Trait1, Trait2 {\n\t\t\tTrait1::method insteadof Trait2;\n\t\t}\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\techo $this-&gt;method(); // выведет 1, тк это метод первого трейта\n\t\t}\n\t}\n\t\n\tnew Test;\n?&gt;</code>\n</div>\n<p>\n\tИтак, в нашем классе мы сказали, что если\n\tиспользуется метод <code class=\"code inline\">method</code>, то следует\n\tбрать его из первого трейта. Можно и наоборот\n\t- взять метод второго трейта:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tuse Trait1, Trait2 {\n\t\t\tTrait2::method insteadof Trait1;\n\t\t}\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\techo $this-&gt;method(); // выведет 2, тк это метод второго трейта\n\t\t}\n\t}\n\t\n\tnew Test;\n?&gt;</code>\n</div>\n<p>\n\tВ любом случае, если мы указываем использовать\n\tметод одного трейта, то метод второго трейта\n\tоказывается недоступным. Можно использовать\n\tи метод второго трейта, переименовав его\n\tчерез ключевое слово <code class=\"code inline\">as</code>, вот так:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tuse Trait1, Trait2 {\n\t\t\tTrait1::method insteadof Trait2; // берем метод из первого трейта\n\t\t\tTrait2::method as method2; // метод второго трейта будет доступен как method2\n\t\t}\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\techo $this-&gt;method() + $this-&gt;method2(); // выведет 3\n\t\t}\n\t}\n\t\n\tnew Test;\n?&gt;</code>\n</div>\n<p>\n\tПри желании можно переименовать и метод первого\n\tтрейта:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tuse Trait1, Trait2 {\n\t\t\tTrait1::method insteadof Trait2;\n\t\t\tTrait1::method as method1; // метод первого трейта будет доступен как method1\n\t\t\tTrait2::method as method2; // метод второго трейта будет доступен как method2\n\t\t}\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\techo $this-&gt;method1() + $this-&gt;method2(); // выведет 3\n\t\t}\n\t}\n\t\n\tnew Test;\n?&gt;</code>\n</div>\n<p>\n\tИспользовать ключевое слово <code class=\"code inline\">as</code> без\n\tопределения главного метода через <code class=\"code inline\">insteadof</code>\n\tнельзя, это выдаст ошибку:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Данный класс выдаст ошибку:\n\tclass Test\n\t{\n\t\tuse Trait1, Trait2 {\n\t\t\tTrait1::method as method1;\n\t\t\tTrait2::method as method2;\n\t\t}\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\techo $this-&gt;method1() + $this-&gt;method2();\n\t\t}\n\t}\n\t\n\tnew Test;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте <code class=\"number inline\">3</code> трейта с названиями <code class=\"code inline\">Trait1</code>,\n\t\t<code class=\"code inline\">Trait2</code> и <code class=\"code inline\">Trait3</code>. Пусть в первом\n\t\tтрейте будет метод <code class=\"code inline\">method</code>, возвращающий\n\t\t<code class=\"number inline\">1</code>, во втором трейте - одноименный\n\t\tметод, возвращающий <code class=\"number inline\">2</code>, а в третьем\n\t\tтрейте - одноименный метод, возвращающий <code class=\"number inline\">3</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Test</code>, использующий\n\t\tвсе три созданных нами трейта. Сделайте в\n\t\tэтом классе метод <code class=\"code inline\">getSum</code>, возвращающий\n\t\tсумму результатов методов подключенных трейтов.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/traits/access-modifiers/","content":"\n\t\t\t\t<h1>Модификаторы доступа и трейты</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСледует обратить ваше внимание на то, что\n\tиспользование трейтов - это не наследование.\n\tПри наследовании приватные методы\n\tи свойства не наследуются.\n</p>\n<p>\n\tВ трейтах же все наоборот: в использующем\n\tтрейт классе будут доступны как публичные,\n\tтак и приватные методы и свойства класса.\n</p>\n<p>\n\tПосмотрим на примере:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait TestTrait\n\t{\n\t\t// Приватный метод:\n\t\tprivate function method()\n\t\t{\n\t\t\treturn '!!!';\n\t\t}\n\t}\n\t\n\tclass Test\n\t{\n\t\tuse TestTrait; // подключаем трейт\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\t// Используем приватный метод трейта:\n\t\t\techo $this-&gt;method(); // выведет '!!!'\n\t\t}\n\t}\n\t\n\tnew Test;\n?&gt;</code>\n</div>\n\n<h2>Изменения прав доступа к методам трейта</h2>\n<p>\n\tВнутри трейта можно использовать любой модификатор\n\tдоступа для методов (то есть public, private\n\tили protected). При необходимости, однако,\n\tв самом классе можно этот модификатор поменять\n\tна другой. Для этого в теле <code class=\"code inline\">use</code> после\n\tключевого слова <code class=\"code inline\">as</code> нужно указать новый\n\tмодификатор.\n</p>\n<p>\n\tПосмотрим на примере:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait TestTrait\n\t{\n\t\t// Приватный метод:\n\t\tprivate function method()\n\t\t{\n\t\t\treturn '!!!';\n\t\t}\n\t}\n\t\n\tclass Test\n\t{\n\t\tuse TestTrait {\n\t\t\tTestTrait::method as public; // меняем метод на публичный\n\t\t}\n\t}\n\t\n\t$test = new Test;\n\techo $test-&gt;method(); // выведет '!!!'\n?&gt;</code>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/traits/methods-priority/","content":"\n\t\t\t\t<h1>Приоритет методов</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tЕсли в классе и в трейте есть одноименный\n\tметод, то метод класса переопределит метод трейта:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait TestTrait\n\t{\n\t\t// Метод с именем method:\n\t\tpublic function method()\n\t\t{\n\t\t\treturn 'trait';\n\t\t}\n\t}\n\t\n\tclass TestClass\n\t{\n\t\tuse TestTrait;\n\t\t\n\t\t// Такой же метод с именем method:\n\t\tpublic function method()\n\t\t{\n\t\t\treturn 'test';\n\t\t}\n\t}\n\t\n\t$test = new TestClass;\n\techo $test-&gt;method(); // выведет 'test' - сработал метод самого класса\n?&gt;</code>\n</div>\n<p>\n\tЕсли же сам класс не имеет такого метода,\n\tно имеется конфликт имен методов трейта и\n\tметодов родительского класса, то методы трейта\n\tимеют приоритет:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait TestTrait\n\t{\n\t\t// Метод с именем method:\n\t\tpublic function method()\n\t\t{\n\t\t\treturn 'trait';\n\t\t}\n\t}\n\t\n\t// Родительский класс:\n\tclass ParentClass\n\t{\n\t\t// Метод с именем method:\n\t\tpublic function method()\n\t\t{\n\t\t\treturn 'parent';\n\t\t}\n\t}\n\t\n\t// Класс наследует метод method от родительского:\n\tclass TestClass extends ParentClass\n\t{\n\t\tuse TestTrait;\n\t}\n\t\n\t$test = new TestClass;\n\techo $test-&gt;method(); // выведет 'trait', тк трейт имеет приоритет\n?&gt;</code>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/traits/abstract-methods/","content":"\n\t\t\t\t<h1>Абстрактные методы трейтов</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ трейтах можно некоторые методы объявлять\n\tабстрактными. В этом случае класс, использующий\n\tэтот трейт, обязан будет реализовать такой\n\tметод. При этом абстрактные методы трейта\n\tне могут быть приватными.\n</p>\n<p>\n\tДавайте посмотрим на примере. Пусть у нас\n\tесть вот такой трейт:\n</p>\n<div class=\"block\" data-file=\"TestTrait.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait TestTrait\n\t{\n\t\tpublic function method1()\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tabstract public function method2();\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть наш трейт используется классом <code class=\"code inline\">Test</code>.\n\tНаличие в трейте абстрактного метода обяжет\n\tпрограммиста реализовать его в классе, иначе\n\tбудет ошибка PHP.\n</p>\n<p>\n\tДавайте сделаем класс <code class=\"code inline\">Test</code> месте с\n\tметодом <code class=\"code inline\">method2</code>:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tuse TestTrait; // используем трейт\n\t\t\n\t\t// Реализуем абстрактный метод:\n\t\tpublic function method2()\n\t\t{\n\t\t\treturn 2;\n\t\t}\n\t}\n\t\n\tnew Test;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте код моего трейта <code class=\"code inline\">TestTrait</code>\n\t\tи код моего класса <code class=\"code inline\">Test</code>. Удалите из\n\t\tкласса метод <code class=\"code inline\">method2</code>. Убедитесь в\n\t\tтом, что отсутствие его реализации приведет\n\t\tк ошибке PHP.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/traits/using-traits-in-trait/","content":"\n\t\t\t\t<h1>Использование трейтов в трейтах</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tТрейты, подобно классам, также могут использовать\n\tдругие трейты. Давайте посмотрим на примере.\n\tПусть у нас есть вот такой трейт с двумя методами:\n</p>\n<div class=\"block\" data-file=\"Trait1.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait Trait1\n\t{\n\t\tprivate function method1()\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tprivate function method2()\n\t\t{\n\t\t\treturn 2;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть у нас также есть еще один трейт:\n</p>\n<div class=\"block\" data-file=\"Trait2.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait Trait2\n\t{\n\t\tprivate function method3()\n\t\t{\n\t\t\treturn 3;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте к трейту <code class=\"code inline\">Trait2</code> подключим\n\tтрейт <code class=\"code inline\">Trait1</code>:\n</p>\n<div class=\"block\" data-file=\"Trait3.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\ttrait Trait2\n\t{\n\t\tuse Trait1; // используем первый трейт\n\t\t\n\t\tprivate function method3()\n\t\t{\n\t\t\treturn 3;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПосле такого подключения получится, что <code class=\"code inline\">Trait2</code>\n\tкроме своих методов будет иметь еще и методы\n\tтрейта <code class=\"code inline\">Trait1</code>. Проверим это: сделаем\n\tкласс <code class=\"code inline\">Test</code>, подключим к нему трейт\n\t<code class=\"code inline\">Trait2</code> и убедимся, что в нашем классе\n\tпоявятся методы как первого трейта, так и второго:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tuse Trait2; // подключаем второй трейт\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\techo $this-&gt;method1(); // метод первого трейта\n\t\t\techo $this-&gt;method2(); // метод первого трейта\n\t\t\techo $this-&gt;method3(); // метод второго трейта\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно сделайте такие же трейты,\n\t\tкак у меня и подключите их к классу <code class=\"code inline\">Test</code>.\n\t\tСделайте в этом классе метод <code class=\"code inline\">getSum</code>,\n\t\tвозвращающий сумму результатов методов подключенных\n\t\tтрейтов.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/traits/functions/","content":"\n\t\t\t\t<h1>Функции для работы трейтами в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<h2>Функция trait_exists</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.trait-exists.php\"><code class=\"code inline\">trait_exists</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас есть трейт <code class=\"code inline\">Trait1</code> и нет\n\t\tтрейта <code class=\"code inline\">Trait2</code>. Проверьте, что выведет\n\t\tфункция <code class=\"code inline\">trait_exists</code> для трейта <code class=\"code inline\">Trait1</code>\n\t\tи для трейта <code class=\"code inline\">Trait2</code>.\n\t</p>\n</div>\n\n<h2>Функция get_declared_traits</h2>\n<div class=\"ref\">\n\t<p>\n\t\t<a href=\"http://php.net/manual/ru/function.get-declared-traits.php\"><code class=\"code inline\">get_declared_traits</code></a>\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВыведите на экран список всех объявленных трейтов.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/magic/toString/","content":"\n\t\t\t\t<h1>Магический метод toString в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tМетоды PHP, начинающиеся с двойного подчеркивания\n\t<code class=\"code inline\">__</code>, называются <dfn>магическим</dfn>.\n\tМагия таких методов состоит в том, что они\n\tмогут вызываться при совершении какого-то\n\tдействия автоматически.\n</p>\n<p>\n\tПервый магический метод, который мы с вами\n\tизучим, называется <code class=\"code inline\">__toString</code>. Он\n\tвызывается при попытке приведения экземпляра\n\tкласса к строке. Давайте разберемся, что\n\tэто значит. Пусть у нас дан вот такой класс\n\t<code class=\"code inline\">User</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте создадим объект этого класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 25);\n?&gt;</code>\n</div>\n<p>\n\tА теперь попытаемся вывести созданный объект\n\tчерез <code class=\"code inline\">echo</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 25);\n\techo $user;\n?&gt;</code>\n</div>\n<p>\n\tПопытка сделать вывод объекта через <code class=\"code inline\">echo</code>\n\tи есть преобразование к строке. В данном\n\tслучае PHP выдаст ошибку, так как просто\n\tтак объекты в строку не преобразуются.\n</p>\n<p>\n\tДля того, чтобы убрать ошибку, мы должны\n\tв явном виде сказать PHP, что делать при\n\tпопытке преобразовать объект в строку. Для\n\tэтого и существует магический метод <code class=\"code inline\">__toString</code>.\n</p>\n<p>\n\tЕсли в коде нашего класса сделать такой метод,\n\tто результат этого метода (то есть то, что\n\tон вернет через <code class=\"code inline\">return</code>) и будет строковым\n\tпредставлением объекта.\n</p>\n<p>\n\tПусть мы хотим, чтобы при попытке вывести\n\tобъект через <code class=\"code inline\">echo</code>, выводилось имя\n\tюзера. Значит сделаем метод <code class=\"code inline\">__toString</code>\n\tи вернем в нем значение свойства <code class=\"code inline\">name</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t\t\n\t\t// Реализуем указанный метод:\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User('john', 25);\n\techo $user; // выведет 'john' - все работает!\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">User</code>, в котором будут\n\t\tследующие свойства - <code class=\"code inline\">name</code>, <code class=\"code inline\">surname</code>,\n\t\t<code class=\"code inline\">patronymic</code>. Сделайте так, чтобы при\n\t\tвыводе объекта через <code class=\"code inline\">echo</code> на экран\n\t\tвыводилось ФИО пользователя.\n\t</p>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tПусть у нас есть вот такой класс, с помощью\n\tкоторого можно добавлять элементы в массив\n\tи находить их сумму:\n</p>\n<div class=\"block\" data-file=\"Arr.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\tprivate $numbers = [];\n\t\t\n\t\tpublic function add($num)\n\t\t{\n\t\t\t$this-&gt;numbers[] = $num;\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tpublic function getSum()\n\t\t{\n\t\t\treturn array_sum($this-&gt;numbers);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте вспомним, как мы пользовались этим\n\tклассом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr;\n\techo $arr-&gt;add(1)-&gt;add(2)-&gt;add(3)-&gt;getSum(); // выведет 6\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, у нас будет цепочка методов\n\t<code class=\"code inline\">add</code>, а последним методом мы всегда\n\tдолжны вызвать <code class=\"code inline\">getSum</code>, чтобы получить\n\tсумму.\n</p>\n<p>\n\tДавайте сделаем так, чтобы этот метод не\n\tнужно было писать, если мы выводим результат\n\tчерез <code class=\"code inline\">echo</code>. Для этого нам и пригодится\n\tизученный метод <code class=\"code inline\">__toString</code>.\n</p>\n<p>\n\tЕсть, однако, один нюанс, мы сейчас рассмотрим.\n\tПусть наша реализация метода <code class=\"code inline\">__toString</code>\n\tбудет такой:\n</p>\n<div class=\"block\" data-file=\"Arr.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function __toString()\n\t{\n\t\treturn array_sum($this-&gt;numbers);\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДанный код выдаст ошибку, так как <code class=\"code inline\">__toString</code>\n\tобязательно должен вернуть строку, а результатом\n\t<code class=\"code inline\">array_sum</code> будет число.\n</p>\n<p>\n\tИсправим проблему, принудительно преобразовав\n\tрезультат в строку:\n</p>\n<div class=\"block\" data-file=\"Arr.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function __toString()\n\t{\n\t\treturn (string) array_sum($this-&gt;numbers);\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПрименим изменения:\n</p>\n<div class=\"block\" data-file=\"Arr.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Arr\n\t{\n\t\tprivate $numbers = [];\n\t\t\n\t\tpublic function add($num)\n\t\t{\n\t\t\t$this-&gt;numbers[] = $num;\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn (string) array_sum($this-&gt;numbers);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$arr = new Arr;\n\techo $arr-&gt;add(1)-&gt;add(2)-&gt;add(3); // выведет '6'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе подсматривая в мой код, реализуйте такой\n\t\tже класс <code class=\"code inline\">Arr</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/magic/get/","content":"\n\t\t\t\t<h1>Магический метод get</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСледующий магический метод, который мы с\n\tвами разберем, называется <code class=\"code inline\">__get</code>. Этот\n\tметод срабатывает при попытке прочитать значение\n\tприватного или защищенного свойства.\n</p>\n<p>\n\tЕсли реализовать метод <code class=\"code inline\">__get</code> в каком-нибудь\n\tклассе, то все обращения к несуществующим\n\tили скрытым свойствам будут обрабатываться\n\tэтим методом.\n</p>\n<p>\n\tПри этом PHP автоматически будет передавать\n\tимя запрошенного свойства в первый параметр\n\tэтого метода, а возвращаемое этим методом\n\tзначение будет воспринято как значение свойства,\n\tк которому произошло обращение.\n</p>\n<p>\n\tСкорее всего пока не очень понятно, как это\n\tработает, поэтому давайте посмотрим на практическом\n\tпримере. Пусть у нас есть вот такой класс\n\t<code class=\"code inline\">Test</code> с приватным и публичным свойствами:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic $prop1 = 1; // публичное свойство\n\t\tprivate $prop2 = 2; // приватное свойство\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте добавим в наш класс магический метод\n\t<code class=\"code inline\">__get</code>, который для начала будет просто\n\tвозвращать имя свойства, к которому произошло\n\tобращение:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tpublic $prop1 = 1;\n\t\tprivate $prop2 = 2;\n\t\t\n\t\tpublic function __get($property)\n\t\t{\n\t\t\treturn $property; // просто вернем имя свойства\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте проверим работу созданного магического\n\tметода. Обратимся к трем типам свойств: к\n\tпубличному свойству, к приватному и к несуществующему:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test;\n\t\n\t// Обращаемся к публичному свойству:\n\techo $test-&gt;prop1; // выведет 1 - то есть значение свойства\n\t\n\t// Обращаемся к приватному свойству:\n\techo $test-&gt;prop2; // выведет 'prop2' - имя свойства\n\t\n\t// Обращаемся к несуществующему свойству:\n\techo $test-&gt;prop3; // выведет 'prop3' - имя свойства\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, наш магический метод реагирует\n\tна обращение к приватным и несуществующим\n\tсвойствам, но игнорирует обращение к публичным\n\t- они работают так, как и работали раньше.\n</p>\n\n<h2>Применение: свойства только для чтения</h2>\n<p>\n\tПусть теперь в нашем классе все свойства\n\tприватные:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tprivate $prop1 = 1;\n\t\tprivate $prop2 = 2;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем так, чтобы эти свойства во\n\tвнешнем мире были доступны только для чтения.\n\tРанее мы такое уже делали, создавая геттеры\n\tдля каждого свойства и не создавая сеттеры.\n</p>\n<p>\n\tДавайте теперь для решения этой задачи воспользуемся\n\tмагическим методом <code class=\"code inline\">__get</code>. Будем возвращать\n\tв нем значение запрошенного свойства. Как\n\tэто сделать: имя запрошенного свойства попадает\n\tв параметр метода <code class=\"code inline\">__get</code>, в нашем случае\n\t<code class=\"code inline\">$property</code>.\n</p>\n<p>\n\tЭто значит, что мы можем прочитать свойство,\n\tимя которого хранится в переменной, вот так:\n\t<code class=\"code inline\">$this->$property</code> (имя свойства будет\n\tпеременной, то есть с долларом вначале, мы\n\tэто проходили в предыдущих уроках).\n</p>\n<p>\n\tДавайте сделаем описанный метод <code class=\"code inline\">__get</code>:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tprivate $prop1 = 1;\n\t\tprivate $prop2 = 2;\n\t\t\n\t\tpublic function __get($property)\n\t\t{\n\t\t\treturn $this-&gt;$property;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВоспользуемся им для чтения свойств:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test;\n\t\n\techo $test-&gt;prop1; // выведет 1\n\techo $test-&gt;prop2; // выведет 2\n?&gt;</code>\n</div>\n<p>\n\tПопытка записать что-то в свойство приведет\n\tк ошибке:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test;\n\t$test-&gt;prop1 = 2; // выдаст ошибку\n?&gt;</code>\n</div>\n<p>\n\tЭто именно то, что нам нужно: свойство можно\n\tпрочитывать, но нельзя записывать.\n</p>\n<p>\n\tПопытка прочитать несуществующее свойство\n\tвыдаст ошибку:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test;\n\techo $test-&gt;prop3; // выдаст ошибку\n?&gt;</code>\n</div>\n<p>\n\tОбратите также внимание на следующий нюанс:\n\tкогда мы делали свойства только для чтения\n\tстарым способом, то для того, чтобы прочитать\n\tсвойство, мы использовали метод-геттер.\n</p>\n<p>\n\tВ новом способе мы будем обращаться именно\n\tк свойствам, будто они публичные. Но записать\n\tв них не сможем, будто они приватные.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tПусть дан вот такой класс <code class=\"code inline\">User</code>, свойства\n\t\tкоторого доступны только для чтения с помощью\n\t\tгеттеров:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function __construct($name, $age)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;age = $age;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t}\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tПеределайте код этого класса так, чтобы вместо\n\t\tгеттеров использовался магический метод <code class=\"code inline\">__get</code>.\n\t</p>\n</div>\n\n<h2>Несуществующее свойство</h2>\n<p>\n\tВ примере выше мы применяли магию метода\n\t<code class=\"code inline\">__get</code> для отлавливания обращения к\n\tприватным свойствам. На самом деле этот метод\n\tтакже может быть полезен для отлавливания\n\tобращений к несуществующим свойствам.\n</p>\n<p>\n\tПосмотрим на практическом примере. Пусть\n\tу нас есть класс <code class=\"code inline\">User</code> с фамилией,\n\tименем и отчеством, являющимися публичными\n\tсвойствами:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $surname;\n\t\tpublic $name;\n\t\tpublic $patronymic;\n\t}\n\t\n\t$user = new User;\n\t\n\t$user-&gt;surname = 'Иванов';\n\t$user-&gt;name = 'Иван';\n\t$user-&gt;patronymic = 'Иванович';\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем так, чтобы объект класса\n\tвел себя так, будто у него также есть свойство\n\t<code class=\"code inline\">fullname</code>, выводящее ФИО юзера:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User;\n\t\n\t$user-&gt;surname = 'Иванов';\n\t$user-&gt;name = 'Иван';\n\t$user-&gt;patronymic = 'Иванович';\n\t\n\t// Выведет 'Иванов Иван Иванович':\n\techo $user-&gt;fullname; // это пока не работает, является нашей целью\n?&gt;</code>\n</div>\n<p>\n\tИспользуем для этого наш магический метод\n\t<code class=\"code inline\">__get</code>:\n</p>\n<div class=\"block\" data-file=\"User.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tpublic $surname;\n\t\tpublic $name;\n\t\tpublic $patronymic;\n\t\t\n\t\t// Используем метод-перехватчик:\n\t\tpublic function __get($property)\n\t\t{\n\t\t\t// Если идет обращение к свойству fullname:\n\t\t\tif ($property == 'fullname') {\n\t\t\t\treturn $this-&gt;surname . ' ' . $this-&gt;name . ' ' . $this-&gt;patronymic;\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = new User;\n\t\n\t$user-&gt;surname = 'Иванов';\n\t$user-&gt;name = 'Иван';\n\t$user-&gt;patronymic = 'Иванович';\n\t\n\techo $user-&gt;fullname; // выведет 'Иванов Иван Иванович'\n?&gt;</code>\n</div>\n<p>\n\tПолучается, что с помощью <code class=\"code inline\">__get</code> мы\n\tсоздали в классе виртуальное свойство: в\n\tклассе его нет, но прочитать его можно.\n</p>\n<p>\n\tКстати, записать в такое свойство будет нельзя,\n\tтак как в реальности его не существует в\n\tнашем классе. То есть это свойство только\n\tдля чтения.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tСделайте класс <code class=\"code inline\">Date</code> с публичными свойствами\n\t\t<code class=\"code inline\">year</code>, <code class=\"code inline\">month</code> и <code class=\"code inline\">day</code>.\n\t</p>\n\t<p>\n\t\tС помощью магии сделайте свойство <code class=\"code inline\">weekDay</code>,\n\t\tкоторое будет возвращать день недели, соответствующий\n\t\tдате.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/magic/set/","content":"\n\t\t\t\t<h1>Магический метод set</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tМагический метод <code class=\"code inline\">__set</code> вызывается\n\tпри попытке изменить значение несуществующего\n\tили скрытого свойства. В качестве параметров\n\tон принимает имя свойства и значение, которое\n\tему пытаются присвоить.\n</p>\n<p>\n\tДавайте посмотрим на практическом примере.\n\tПусть у нас дан вот такой класс <code class=\"code inline\">Test</code>:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tprivate $prop1;\n\t\tprivate $prop2;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем в этом классе магический\n\tметод <code class=\"code inline\">__set</code>, который с помощью функции\n\t<code class=\"code inline\">var_dump</code> будет выводить имя свойства,\n\tк которому произошло обращение, и значение,\n\tкоторое этому свойству пытаются установить:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tprivate $prop1;\n\t\tprivate $prop2;\n\t\t\n\t\tpublic function __set($property, $value)\n\t\t{\n\t\t\tvar_dump($property . ' ' .$value);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нашего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test;\n\t$test-&gt;prop = 'value'; // var_dump метода __set выведет 'prop value'\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь будем устанавливать значение\n\tсвойству, имя которого хранится в переменной\n\t<code class=\"code inline\">$property</code>:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tprivate $prop1;\n\t\tprivate $prop2;\n\t\t\n\t\tpublic function __set($property, $value)\n\t\t{\n\t\t\t$this-&gt;$property = $value; // устанавливаем значение\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТеперь мы сможем записывать в приватные свойства\n\tснаружи класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test;\n\t\n\t$test-&gt;prop1 = 1; // запишем 1\n\t$test-&gt;prop2 = 2; // запишем 2\n?&gt;</code>\n</div>\n<p>\n\tЗаписывать мы можем, однако, проверить, записалось\n\tли туда что-то - нет, так как свойства приватные.\n</p>\n<p>\n\tМожно сделать геттер для этих свойств или\n\tпросто воспользоваться магическим методом\n\t<code class=\"code inline\">__get</code>. Воспользуемся вторым вариантом:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tprivate $prop1;\n\t\tprivate $prop2;\n\t\t\n\t\tpublic function __set($property, $value)\n\t\t{\n\t\t\t$this-&gt;$property = $value;\n\t\t}\n\t\t\n\t\t// Магический геттер свойств:\n\t\tpublic function __get($property)\n\t\t{\n\t\t\treturn $this-&gt;$property;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВот теперь мы можем проверить работу нашего\n\tкласса. Проверим:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test;\n\t\n\t$test-&gt;prop1 = 1; // запишем 1\n\t$test-&gt;prop2 = 2; // запишем 2\n\t\n\techo $test-&gt;prop1; // выведет 1\n\techo $test-&gt;prop2; // выведет 2\n?&gt;</code>\n</div>\n<p>\n\tНа самом деле, конечно же, не стоит разрешать\n\tвсем подряд записывать в приватные свойства,\n\tиначе пропадает суть этих приватных свойств\n\t(проще сделать их публичными и все).\n</p>\n<p>\n\tПоэтому данный метод следует применять только\n\tтогда, когда в этом действительно есть необходимость.\n\tНиже мы еще рассмотрим примеры удачного применения.\n</p>\n\n<h2>Несуществующее свойство</h2>\n<p>\n\tДавайте попробуем записать данные в несуществующее\n\tсвойство - это будет работать:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$test = new Test;\n\t\n\t$test-&gt;prop3 = 3; // запишем 3\n\techo $test-&gt;prop3; // выведет 3\n?&gt;</code>\n</div>\n<p>\n\tПусть мы не хотим разрешать записывать в\n\tнесуществующие свойства. И, вообще, хотим\n\tразрешить запись только в свойства <code class=\"code inline\">prop1</code>\n\tи <code class=\"code inline\">prop2</code>.\n</p>\n<p>\n\tЭто легко сделать - достаточно в методе <code class=\"code inline\">__set</code>\n\tдобавить соответствующее условие:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tprivate $prop1;\n\t\tprivate $prop2;\n\t\t\n\t\tpublic function __set($property, $value)\n\t\t{\n\t\t\t// Напишем условие:\n\t\t\tif ($property == 'prop1' or $property == 'prop2') {\n\t\t\t\t$this-&gt;$property = $value;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function __get($property)\n\t\t{\n\t\t\treturn $this-&gt;$property;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tЕсли таких свойств будет много, то не очень\n\tудобно перечислять их все в условии.\n</p>\n<p>\n\tДавайте запишем разрешенные для записи свойства\n\tв массив и будем проверять наличие свойства\n\tв этом массиве с помощью функции <code class=\"code inline\">in_array</code>:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tprivate $prop1;\n\t\tprivate $prop2;\n\t\t\n\t\tpublic function __set($property, $value)\n\t\t{\n\t\t\t$properties = ['prop1', 'prop2']; // разрешенные свойства\n\t\t\t\n\t\t\tif (in_array($property, $properties)) {\n\t\t\t\t$this-&gt;$property = $value;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function __get($property)\n\t\t{\n\t\t\treturn $this-&gt;$property;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Проверка при записи</h2>\n<p>\n\tДавайте будем проверять значения свойств\n\tна соответствие определенному условию:\n</p>\n<div class=\"block\" data-file=\"Test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Test\n\t{\n\t\tprivate $prop1;\n\t\tprivate $prop2;\n\t\t\n\t\tpublic function __set($property, $value)\n\t\t{\n\t\t\tswitch($property) {\n\t\t\t\tcase 'prop1':\n\t\t\t\t\t// Если prop1 от 0 до 10:\n\t\t\t\t\tif ($value &gt; 0 and $value &lt; 10) {\n\t\t\t\t\t\t$this-&gt;$property = $value;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 'prop2':\n\t\t\t\t\t// Если prop2 от 10 до 20:\n\t\t\t\t\tif ($value &gt; 10 and $value &lt; 20) {\n\t\t\t\t\t\t$this-&gt;$property = $value;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Такого свойства нет\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function __get($property)\n\t\t{\n\t\t\treturn $this-&gt;$property;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tПрактическое применение метода <code class=\"code inline\">__set</code>\n\tвы изучите самостоятельно, решив вот такую задачу:\n</p>\n<div class=\"task\">\n\t<p>\n\t\tПусть дан вот такой класс <code class=\"code inline\">User</code> с геттерами\n\t\tи сеттерами свойств:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass User\n\t{\n\t\tprivate $name;\n\t\tprivate $age;\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function setName($name)\n\t\t{\n\t\t\tif ($name != '') { // проверяем имя на непустоту\n\t\t\t\t$this-&gt;name = $name;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function getAge()\n\t\t{\n\t\t\treturn $this-&gt;age;\n\t\t}\n\t\t\n\t\tpublic function setAge($age)\n\t\t{\n\t\t\tif ($age &gt;= 0 and $age &lt;= 70) { // проверяем возраст\n\t\t\t\t$this-&gt;age = $age;\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tПеределайте код этого класса так, чтобы вместо\n\t\tгеттеров и сеттеров использовались магический\n\t\tметоды <code class=\"code inline\">__get</code> и <code class=\"code inline\">__set</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Date/","content":"\n\t\t\t\t<h1>Класс Date в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tНачиная с данного урока мы с вами будем применять\n\tизученную теорию по ООП на практических примерах,\n\tсоздавая различные классы.\n</p>\n<p>\n\tДавайте для разминки сделаем класс для работы\n\tс датой. Пусть этот класс параметром конструктора\n\tпринимает дату в формате <i>год-месяц-день</i>\n\tи имеет следующие методы:\n</p>\n<div class=\"block\" data-file=\"Date.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Date\n\t{\n\t\tpublic function __construct($date = null)\n\t\t{\n\t\t\t// если дата не передана - пусть берется текущая\n\t\t}\n\t\t\n\t\tpublic function getDay()\n\t\t{\n\t\t\t// возвращает день\n\t\t}\n\t\t\n\t\tpublic function getMonth($lang = null)\n\t\t{\n\t\t\t// возвращает месяц\n\t\t\t\n\t\t\t// переменная $lang может принимать значение ru или en\n\t\t\t// если эта не пуста - пусть месяц будет словом на заданном языке\n\t\t}\n\t\t\n\t\tpublic function getYear()\n\t\t{\n\t\t\t// возвращает год\n\t\t}\n\t\t\n\t\tpublic function getWeekDay($lang = null)\n\t\t{\n\t\t\t// возвращает день недели\n\t\t\t\n\t\t\t// переменная $lang может принимать значение ru или en\n\t\t\t// если эта не пуста - пусть день будет словом на заданном языке\n\t\t}\n\t\t\n\t\tpublic function addDay($value)\n\t\t{\n\t\t\t// добавляет значение $value к дню\n\t\t}\n\t\t\n\t\tpublic function subDay($value)\n\t\t{\n\t\t\t// отнимает значение $value от дня\n\t\t}\n\t\t\n\t\tpublic function addMonth($value)\n\t\t{\n\t\t\t// добавляет значение $value к месяцу\n\t\t}\n\t\t\n\t\tpublic function subMonth($value)\n\t\t{\n\t\t\t// отнимает значение $value от месяца\n\t\t}\n\t\t\n\t\tpublic function addYear($value)\n\t\t{\n\t\t\t// добавляет значение $value к году\n\t\t}\n\t\t\n\t\tpublic function subYear($value)\n\t\t{\n\t\t\t// отнимает значение $value от года\n\t\t}\n\t\t\n\t\tpublic function format($format)\n\t\t{\n\t\t\t// выведет дату в указанном формате\n\t\t\t// формат пусть будет такой же, как в функции date\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\t// выведет дату в формате 'год-месяц-день'\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте посмотрим, как мы будем пользоваться\n\tнашим классом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$date = new Date('2025-12-31');\n\t\n\techo $date-&gt;getYear();  // выведет '2025'\n\techo $date-&gt;getMonth(); // выведет '12'\n\techo $date-&gt;getDay();   // выведет '31'\n\t\n\techo $date-&gt;getWeekDay();     // выведет '3'\n\techo $date-&gt;getWeekDay('ru'); // выведет 'среда'\n\techo $date-&gt;getWeekDay('en'); // выведет 'wednesday'\n?&gt;</code>\n</div>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Date('2025-12-31'))-&gt;addYear(1); // '2026-12-31'\n\techo (new Date('2025-12-31'))-&gt;addDay(1);  // '2026-01-01'\n\t\n\techo (new Date('2025-12-31'))-&gt;subDay(3)-&gt;addYear(1); // '2026-12-28'\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">Date</code>. Проверьте\n\t\tего работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Interval/","content":"\n\t\t\t\t<h1>Класс Interval в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте реализуем класс, который будет находить\n\tразницу между двумя датами. Пусть конструктор\n\tэтого класса параметрами принимает две даты,\n\tпредставляющие объекты класса <code class=\"code inline\">Date</code>,\n\tсозданного нами в предыдущем уроке, и находит\n\tразницу между датами в днях, месяцах и годах:\n</p>\n<div class=\"block\" data-file=\"Interval.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Interval\n\t{\n\t\tpublic function __construct(Date $date1, Date $date2)\n\t\t{\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic function toDays()\n\t\t{\n\t\t\t// вернет разницу в днях\n\t\t}\n\t\t\n\t\tpublic function toMonths()\n\t\t{\n\t\t\t// вернет разницу в месяцах\n\t\t}\n\t\t\n\t\tpublic function toYears()\n\t\t{\n\t\t\t// вернет разницу в годах\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте посмотрим, как мы будем пользоваться\n\tнашим классом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$date1 = new Date('2025-12-31');\n\t$date2 = new Date('2026-11-28');\n\t\n\t$interval = new Interval($date1, $date2);\n\t\n\techo $interval-&gt;toDays();   // выведет разницу в днях\n\techo $interval-&gt;toMonths(); // выведет разницу в месяцах\n\techo $interval-&gt;toYears();  // выведет разницу в годах\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">Interval</code>.\n\t\tПроверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/File/","content":"\n\t\t\t\t<h1>Класс File в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте реализуем класс для работы с файлами.\n\tПусть этот класс реализует следующий интерфейс:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iFile\n\t{\n\t\tpublic function __construct($filePath);\n\t\t\n\t\tpublic function getPath(); // путь к файлу\n\t\tpublic function getDir();  // папка файла\n\t\tpublic function getName(); // имя файла\n\t\tpublic function getExt();  // расширение файла\n\t\tpublic function getSize(); // размер файла\n\t\t\n\t\tpublic function getText();          // получает текст файла\n\t\tpublic function setText($text);     // устанавливает текст файла\n\t\tpublic function appendText($text);  // добавляет текст в конец файла\n\t\t\n\t\tpublic function copy($copyPath);    // копирует файл\n\t\tpublic function delete();           // удаляет файл\n\t\tpublic function rename($newName);   // переименовывает файл\n\t\tpublic function replace($newPath);  // перемещает файл\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс в соответствии\n\t\tс интерфейсом. Проверьте работу вашего класса.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Tag/","content":"\n\t\t\t\t<h1>Класс Tag</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами сделаем класс <code class=\"code inline\">Tag</code>\n\tдля упрощения работы с HTML тегами. Имея\n\tтакой класс мы, вместо того, чтобы набирать\n\tHTML теги вручную, будем использовать для\n\tэтого PHP.\n</p>\n<p>\n\tНа самом деле выигрыша в длине кода мы не\n\tполучим, но сможем динамически формировать\n\tтеги по определенным условиям, что пригодится\n\tнам для решения более сложных задач. Давайте\n\tприступим к реализации, а саму выгоду такого\n\tкласса вы поймете в процессе работы над кодом,\n\tлибо в следующих уроках, когда мы будем применять\n\tнаш класс.\n</p>\n\n<h2>Приступим к реализации</h2>\n<p>\n\tИтак, наш класс называется <code class=\"code inline\">Tag</code> - это\n\tнеспроста. Каждый объект этого класса будет\n\tпредставлять собой отдельный тег, с которым\n\tмы будем производить определенные операции.\n</p>\n<p>\n\tДавайте будем передавать имя создаваемого\n\tтега в конструктор объекта и записывать в\n\tприватное свойство <code class=\"code inline\">$name</code>:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Tag\n\t{\n\t\tprivate $name; // свойство для хранения имени тега\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСделаем с помощью нашего класса, к примеру,\n\tобъект для тега <code class=\"code inline\">&lt;input&gt;</code> (пока на\n\tэкран ничего не выведется):\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$input = new Tag('input');\n?&gt;</code>\n</div>\n<p>\n\tПока мы просто получили объект с инпутом.\n\tДавайте добавим еще метод, с помощью которого\n\tмы будем выводить тег на экран.\n</p>\n<p>\n\tЗдесь следует иметь ввиду то, что теги бывают\n\tоткрывающие, например, <code class=\"code inline\">&lt;div&gt;</code>, и\n\tзакрывающие, например, <code class=\"code inline\">&lt;/div&gt;</code>. Некоторые\n\tтеги не имеют закрывающего тега, например,\n\t<code class=\"code inline\">&lt;input&gt;</code> или <code class=\"code inline\">&lt;img&gt;</code>.\n</p>\n<p>\n\tДавайте для начала сделаем метод <code class=\"code inline\">open</code>,\n\tкоторый будет только открывать тег (в случае\n\tс инпутами больше никакой метод и не понадобится,\n\tтак как они не требуют закрытия).\n</p>\n<p>\n\tИтак, реализуем:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Tag\n\t{\n\t\tprivate $name;\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\t// Выводим открывающую часть тега:\n\t\tpublic function open()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\treturn \"&lt;$name&gt;\";\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте проверим работу нашего метода:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input');\n\techo $tag-&gt;open(); // выведет &lt;input&gt;\n?&gt;</code>\n</div>\n<p class=\"comment\">\n\tЗапустите этот код, и в окне браузера действительно\n\tпоявится инпут. Чтобы посмотреть исходный HTML код,\n\tв окне браузера можно будет нажать комбинацию\n\tклавиш <code class=\"code inline\">Ctrl+U</code> - там вы увидите код нашего инпута.\n</p>\n<p class=\"comment\">\n\tОткрытый исходный код можно обновлять, будто обычную\n\tстраницу браузера. Вы можете менять ваш PHP код\n\tи сразу проверять изменения HTML кода, отправляемого\n\tв браузер.\n</p>\n<p>\n\tДавайте теперь сделаем метод <code class=\"code inline\">close</code>\n\tдля закрывающей части тега:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Tag\n\t{\n\t\tprivate $name;\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\tpublic function open()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\treturn \"&lt;$name&gt;\";\n\t\t}\n\t\t\n\t\t// Выводим закрывающую часть тега:\n\t\tpublic function close()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\treturn \"&lt;/$name&gt;\";\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВоспользуемся этим методом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('div');\n\techo $tag-&gt;open() . 'text' . $tag-&gt;close(); // выведет &lt;div&gt;text&lt;/div&gt;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно, не подсматривая в мой код,\n\t\tсделайте такой же класс <code class=\"code inline\">Tag</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте с помощью класса <code class=\"code inline\">Tag</code> тег\n\t\t<code class=\"code inline\">&lt;img&gt;</code> и выведите его на экран.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте с помощью класса <code class=\"code inline\">Tag</code> тег\n\t\t<code class=\"code inline\">&lt;header&gt;</code> и выведите его на экран\n\t\tс текстом <code class=\"string inline\">'header сайта'</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Tag/tag-attributes/","content":"\n\t\t\t\t<h1>Атрибуты тегов в классе Tag</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть теперь мы хотим сделать так, чтобы\n\tв создаваемых тегах можно было указывать\n\tатрибуты и их значения. Давайте будем передавать\n\tатрибуты для тега в виде ассоциативного массива\n\tв конструктор тега.\n</p>\n<p>\n\tВот пример (пока не рабочий, это наша цель):\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input', ['id' =&gt; 'test', 'class' =&gt; 'eee bbb']);\n\techo $tag-&gt;open(); // выведет &lt;input id=\"test\" class=\"eee bbb\"&gt;\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем в нашем классе вспомогательный\n\tприватный метод <code class=\"code inline\">getAttrsStr</code>, который\n\tпараметром будет получать массив, а возвращать\n\tстроку с атрибутами. Пример работы нашего метода:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$attrs = ['id' =&gt; 'test', 'class' =&gt; 'eee bbb'];\n\techo $this-&gt;getAttrsStr($attrs); // выведет ' id=\"test\" class=\"eee bbb\"'\n?&gt;</code>\n</div>\n<p>\n\tДавайте напишем его реализацию:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tprivate function getAttrsStr($attrs)\n\t{\n\t\tif (!empty($attrs)) {\n\t\t\t$result = '';\n\t\t\t\n\t\t\tforeach ($attrs as $name =&gt; $value) {\n\t\t\t\t$result .= \" $name=\\\"$value\\\"\";\n\t\t\t}\n\t\t\t\n\t\t\treturn $result;\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДобавим созданный метод в наш класс:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Tag\n\t{\n\t\tprivate $name;\n\t\tprivate $attrs;\n\t\t\n\t\tpublic function __construct($name, $attrs = [])\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t\t$this-&gt;attrs = $attrs; // записываем атрибуты в свойство\n\t\t}\n\t\t\n\t\tpublic function open()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\t$attrsStr = $this-&gt;getAttrsStr($this-&gt;attrs); // формируем строку с атрибутами\n\t\t\t\n\t\t\treturn \"&lt;$name$attrsStr&gt;\"; // добавляем атрибуты после имени тега\n\t\t}\n\t\t\n\t\tpublic function close()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\treturn \"&lt;/$name&gt;\";\n\t\t}\n\t\t\n\t\t// Формируем строку с атрибутами:\n\t\tprivate function getAttrsStr($attrs)\n\t\t{\n\t\t\tif (!empty($attrs)) {\n\t\t\t\t$result = '';\n\t\t\t\t\n\t\t\t\tforeach ($attrs as $name =&gt; $value) {\n\t\t\t\t\t$result .= \" $name=\\\"$value\\\"\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn $result;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нашего метода:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input', ['id' =&gt; 'test', 'class' =&gt; 'eee bbb']);\n\techo $tag-&gt;open(); // выведет &lt;input id=\"test\" class=\"eee bbb\"&gt;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно, не подсматривая в мой код,\n\t\tдобавьте в класс <code class=\"code inline\">Tag</code> возможность добавления\n\t\tатрибутов тега.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Tag/method-chains/","content":"\n\t\t\t\t<h1>Методы цепочкой в классе Tag</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте вынесем добавление атрибутов из конструктора\n\tв отдельный метод <code class=\"code inline\">setAttr</code>. Пусть при\n\tэтом наш метод позволяет добавлять только\n\tодин атрибут, а чтобы добавить несколько\n\tатрибутов - нужно будет вызвать несколько\n\tметодов в виде цепочки.\n</p>\n<p>\n\tСмотрите пример использования нашего метода:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input');\n\techo $tag-&gt;setAttr('id', 'test')-&gt;setAttr('class', 'eee bbb')-&gt;open();\n?&gt;</code>\n</div>\n<p>\n\tС комментариями:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input');\n\t\n\techo $tag\n\t\t-&gt;setAttr('id', 'test') // добавляем атрибут 'id'\n\t\t-&gt;setAttr('class', 'eee bbb') // добавляем атрибут 'class'\n\t\t-&gt;open(); // выведет &lt;input id=\"test\" class=\"eee bbb\"&gt;\n?&gt;</code>\n</div>\n<p>\n\tПока мы предполагаем, что наша цепочка всегда\n\tзавершается методом <code class=\"code inline\">open</code>. Если тег\n\tдолжен иметь еще и закрывающую часть, то\n\tмы будем вызывать метод <code class=\"code inline\">close</code> вне\n\tцепочки, вот так:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('div');\n\techo $tag-&gt;setAttr('id', 'test')-&gt;open(); // откроем тег\n\techo $tag-&gt;close(); // закроем тег\n?&gt;</code>\n</div>\n<p>\n\tИтак, давайте реализуем метод <code class=\"code inline\">setAttr</code>\n\tв нашем классе:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Tag\n\t{\n\t\tprivate $name;\n\t\tprivate $attrs = []; // изначально пустой массив\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\t// Реализуем метод для атрибутов:\n\t\tpublic function setAttr($name, $value)\n\t\t{\n\t\t\t$this-&gt;attrs[$name] = $value;\n\t\t\treturn $this; // возвращаем $this чтобы была цепочка\n\t\t}\n\t\t\n\t\tpublic function open()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\t$attrsStr = $this-&gt;getAttrsStr($this-&gt;attrs);\n\t\t\t\n\t\t\treturn \"&lt;$name$attrsStr&gt;\";\n\t\t}\n\t\t\n\t\tpublic function close()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\treturn \"&lt;/$name&gt;\";\n\t\t}\n\t\t\n\t\tprivate function getAttrsStr($attrs)\n\t\t{\n\t\t\tif (!empty($attrs)) {\n\t\t\t\t$result = '';\n\t\t\t\t\n\t\t\t\tforeach ($attrs as $name =&gt; $value) {\n\t\t\t\t\t$result .= \" $name=\\\"$value\\\"\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn $result;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно добавьте метод <code class=\"code inline\">setAttr</code>\n\t\tв созданный вами в предыдущем уроке класс\n\t\t<code class=\"code inline\">Tag</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте метод <code class=\"code inline\">removeAttr</code>, который\n\t\tбудет удалять переданный параметром атрибут.\n\t\tСделайте так, чтобы этот метод также мог\n\t\tпринимать участие в цепочке.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Tag/attributes-via-array/","content":"\n\t\t\t\t<h1>Массовое добавление атрибутов в классе Tag</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте сделаем метод <code class=\"code inline\">setAttrs</code>, который\n\tбудет работать аналогично методу <code class=\"code inline\">setAttr</code>,\n\tно параметром принимать массив атрибутов.\n</p>\n<p>\n\tСмотрите пример:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input');\n\t\n\techo $tag\n\t\t-&gt;setAttrs(['id' =&gt; 'test', 'class' =&gt; 'eee']) // задаем атрибуты массивом\n\t\t-&gt;open(); // выведет &lt;input id=\"test\" class=\"eee\"&gt;\n?&gt;</code>\n</div>\n<p>\n\tПредполагается, что пользователь нашего класса\n\tбудет использовать или метод <code class=\"code inline\">setAttrs</code>,\n\tили метод <code class=\"code inline\">setAttr</code>, или любую их комбинацию.\n\tВот пример использования двух методов сразу:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input');\n\t\n\techo $tag\n\t\t-&gt;setAttrs(['id' =&gt; 'test', 'class' =&gt; 'eee'])\n\t\t-&gt;setAttr('type', 'text')\n\t\t-&gt;open(); // выведет &lt;input id=\"test\" class=\"eee\" type=\"text\"&gt;\n?&gt;</code>\n</div>\n<p>\n\tТак как у нас уже реализован метод <code class=\"code inline\">setAttr</code>,\n\tто реализация нового метода <code class=\"code inline\">setAttrs</code>\n\tстановится элементарной:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function setAttrs($attrs)\n\t{\n\t\tforeach ($attrs as $name =&gt; $value) {\n\t\t\t$this-&gt;setAttr($name, $value);\n\t\t}\n\t\t\n\t\treturn $this;\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в ваш класс <code class=\"code inline\">Tag</code> описанный\n\t\tметод <code class=\"code inline\">setAttrs</code>. Проверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Tag/attributes-without-value/","content":"\n\t\t\t\t<h1>Атрибуты без значения в классе Tag</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ HTML существуют атрибуты без значения,\n\tнапример, <code class=\"code inline\">disabled</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;input id=\"test\" disabled&gt;</code>\n</div>\n<p>\n\tДавайте сделаем так, чтобы метод <code class=\"code inline\">setAttr</code>\n\tмог создавать и такие атрибуты. Пусть, чтобы\n\tсоздать атрибут без значения, вторым параметром\n\tметода мы будем передавать значение <code class=\"code inline\">true</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input');\n\t\n\techo $tag\n\t\t-&gt;setAttr('id', 'test')\n\t\t-&gt;setAttr('disabled', true) // создаем атрибут без значения\n\t\t-&gt;open(); // выведет &lt;input id=\"test\" disabled&gt;\n?&gt;</code>\n</div>\n<p>\n\tПока наш класс <code class=\"code inline\">Tag</code> не дает возможность\n\tсделать такой атрибут. Давайте поправим это,\n\tвнеся соответствующие правки в метод <code class=\"code inline\">getAttrsStr</code>:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tprivate function getAttrsStr($attrs)\n\t{\n\t\tif (!empty($attrs)) {\n\t\t\t$result = '';\n\t\t\t\n\t\t\tforeach ($attrs as $name =&gt; $value) {\n\t\t\t\t// Если значение атрибута равно true:\n\t\t\t\tif ($value === true) {\n\t\t\t\t\t$result .= \" $name\"; // это атрибут без значения\n\t\t\t\t} else {\n\t\t\t\t\t$result .= \" $name=\\\"$value\\\"\"; // это атрибут со значением\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn $result;\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПрименим изменение к классу:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Tag\n\t{\n\t\tprivate $name;\n\t\tprivate $attrs = [];\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\tpublic function setAttr($name, $value = true)\n\t\t{\n\t\t\t$this-&gt;attrs[$name] = $value;\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tpublic function open()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\t$attrsStr = $this-&gt;getAttrsStr($this-&gt;attrs);\n\t\t\t\n\t\t\treturn \"&lt;$name$attrsStr&gt;\";\n\t\t}\n\t\t\n\t\tpublic function close()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\treturn \"&lt;/$name&gt;\";\n\t\t}\n\t\t\n\t\tprivate function getAttrsStr($attrs)\n\t\t{\n\t\t\tif (!empty($attrs)) {\n\t\t\t\t$result = '';\n\t\t\t\t\n\t\t\t\tforeach ($attrs as $name =&gt; $value) {\n\t\t\t\t\tif ($value === true) {\n\t\t\t\t\t\t$result .= \" $name\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$result .= \" $name=\\\"$value\\\"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn $result;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нашего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input');\n\t\n\techo $tag\n\t\t-&gt;setAttr('id', 'test')\n\t\t-&gt;setAttr('disabled', true)\n\t\t-&gt;open(); // выведет &lt;input id=\"test\" disabled&gt;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно внесите соответствующие правки\n\t\tв ваш класс <code class=\"code inline\">Tag</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Tag/methods-call-after-object-creation/","content":"\n\t\t\t\t<h1>Вызов методов сразу после создания объекта Tag</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть с помощью нашего класса <code class=\"code inline\">Tag</code>\n\tмы создаем инпут:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$tag = new Tag('input');\n\t\n\techo $tag\n\t\t-&gt;setAttr('id', 'test')\n\t\t-&gt;setAttr('class', 'eee bbb')\n\t\t-&gt;open();\n?&gt;</code>\n</div>\n<p>\n\tМожно не создавать отдельную переменную для\n\tобъекта, а создать его на месте и сразу начать\n\tприменять к нему цепочку методов:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Tag('input'))\n\t\t-&gt;setAttr('id', 'test')\n\t\t-&gt;setAttr('class', 'eee bbb')\n\t\t-&gt;open();\n?&gt;</code>\n</div>\n<p>\n\tТакое удобно в том случае, когда создаваемый\n\tтег уникальный и нужен нам только в одном\n\tместе. В этом случае мы не будем плодить\n\tлишних переменных.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте указанным способом два инпута. Первый\n\t\tс атрибутом <code class=\"code inline\">name</code> в значении <code class=\"code inline\">name1</code>,\n\t\tа второй с таким же атрибутом в значении\n\t\t<code class=\"code inline\">name2</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Tag/css-classes/","content":"\n\t\t\t\t<h1>CSS классы в классе Tag</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас дан вот такой инпут с атрибутом\n\t<code class=\"code inline\">class</code>:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;input class=\"eee bbb kkk\"&gt;</code>\n</div>\n<p>\n\tКак вы видите, атрибут <code class=\"code inline\">class</code> содержит\n\tв себе несколько значений, разделенных пробелами.\n\tЭти значения представляют собой несколько\n\tCSS классов нашего элемента.\n</p>\n<p>\n\tДавайте реализуем в нашем классе <code class=\"code inline\">Tag</code>\n\tнабор методов, которые будут работать с этими\n\tCSS классами. Например, было бы удобно иметь\n\tметод <code class=\"code inline\">addClass</code>, добавляющий еще один\n\tкласс в строку с классами.\n</p>\n<p>\n\tПри этом наш метод должен проверять то, что\n\tдобавляемый класс еще не присутствует среди\n\tклассов элемента, иначе добавление нового\n\tкласса будет приводить к тому, что у элемента\n\tбудет несколько одинаковых классов, что,\n\tконечно же, неправильно.\n</p>\n<p>\n\tПример использования желаемого нами метода:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;input class=\"eee bbb\"&gt;:\n\techo (new Tag('input'))-&gt;addClass('eee')-&gt;addClass('bbb')-&gt;open();\n?&gt;</code>\n</div>\n<p>\n\tБыло бы также удобно иметь метод <code class=\"code inline\">removeClass</code>\n\tдля удаления заданного класса элемента.\n</p>\n<p>\n\tПрактическое применение этих методов вы еще\n\tувидите в следующих уроках.\n</p>\n<p>\n\tДавайте реализуем описанные методы.\n</p>\n\n<h2>Добавление класса</h2>\n<p>\n\tКак вы знаете, наш класс <code class=\"code inline\">Tag</code> хранит\n\tатрибуты тега в свойстве <code class=\"code inline\">$this->attrs</code>.\n\tДанное свойство представляет собой массив.\n\tВ этом массиве может быть элемент с ключом\n\t<code class=\"code inline\">class</code>, содержащий CSS классы элемента.\n\tЭлемента с таким ключом может, однако, и не быть.\n</p>\n<p>\n\tВсе зависит от того, был ли при создании\n\tтега вызван метод <code class=\"code inline\">setAttr</code> для установки\n\tатрибута <code class=\"code inline\">class</code> или нет.\n</p>\n<p>\n\tВот пример того, когда он был вызван:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;input class=\"eee bbb\"&gt;:\n\techo (new Tag('input'))-&gt;setAttr('class', 'eee bbb')-&gt;open();\n?&gt;</code>\n</div>\n<p>\n\tА вот пример того, когда он не был вызван:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;input id=\"test\"&gt;:\n\techo (new Tag('input'))-&gt;setAttr('id', 'test')-&gt;open();\n?&gt;</code>\n</div>\n<p>\n\tВ реализации нашего метода <code class=\"code inline\">addClass</code>\n\tнужно будет учесть оба варианта.\n</p>\n<p>\n\tПолучается, что если у элемента не заданы\n\tCSS классы, то вызов метода <code class=\"code inline\">addClass</code>\n\tдолжен просто создавать в массиве <code class=\"code inline\">$this->attrs</code>\n\tновый элемент с ключом <code class=\"code inline\">class</code> и записывать\n\tв него переданный класс:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function addClass($className)\n\t{\n\t\t// Если ключа class нет в массиве $this-&gt;attrs:\n\t\tif (!isset($this-&gt;attrs['class'])) {\n\t\t\t$this-&gt;attrs['class'] = $className; // запишем наш CSS класс\n\t\t}\n\t\t\n\t\treturn $this; // возвращаем $this для работы цепочки\n\t}\n?&gt;</code>\n</div>\n<p class=\"comment\">\n\tОбратите внимание на то, что параметр метода\n\tназывается <code class=\"code inline\">$className</code>, а не <code class=\"code inline\">$class</code>,\n\tтак как слово <code class=\"code inline\">class</code> является зарезервированным в PHP\n\tи его нельзя использовать в качестве имени переменной.\n</p>\n<p>\n\tДавайте теперь рассмотрим второй вариант,\n\tкогда в <code class=\"code inline\">$this->attrs['class']</code> уже\n\tесть один или несколько классов. Как уже\n\tупоминалось выше, эти классы были добавлены\n\tранее с помощью метода <code class=\"code inline\">setAttr</code>. Эти\n\tклассы также могли быть добавлены с помощью\n\tвызова метода (или цепочки методов) <code class=\"code inline\">addClass</code>.\n</p>\n<p>\n\tСпособ добавления, в общем-то, не имеет никакого\n\tзначения, главное, что, если классы есть,\n\tто они хранятся в виде строки, разделенные\n\tпробелами. Либо, если там один класс, то\n\tв <code class=\"code inline\">$this->attrs['class']</code> просто хранится\n\tего имя, без пробелов.\n</p>\n<p>\n\tПусть в <code class=\"code inline\">$this->attrs['class']</code> хранится\n\tнесколько классов. В этом случае будет удобнее\n\tработать не со строкой с пробелами, а с массивом\n\tCSS классов. Для этого можно просто разбить\n\tнашу строку в массив с помощью функции <code class=\"code inline\">explode</code>:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function addClass($className)\n\t{\n\t\tif (isset($this-&gt;attrs['class'])) {\n\t\t\t// Получаем массив классов:\n\t\t\t$classNames = explode(' ', $this-&gt;attrs['class']);\n\t\t}\n\t\t\n\t\treturn $this;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tЗатем необходимо проверить отсутствие переданного\n\tкласса в этом массиве классов. Это легко\n\tсделать с помощью функции <code class=\"code inline\">in_array</code>:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function addClass($className)\n\t{\n\t\tif (isset($this-&gt;attrs['class'])) {\n\t\t\t$classNames = explode(' ', $this-&gt;attrs['class']);\n\t\t\t\n\t\t\t// Если такого класса нет в массиве классов:\n\t\t\tif (!in_array($className, $classNames)) {\n\t\t\t\t// добавим новый класс\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $this;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tЕсли переданного класса нет в массиве классов,\n\tто добавим его к уже существующим классам.\n\tА если есть - то просто ничего не будем делать.\n</p>\n<p>\n\tДавайте реализуем добавление класса:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function addClass($className)\n\t{\n\t\tif (isset($this-&gt;attrs['class'])) {\n\t\t\t$classNames = explode(' ', $this-&gt;attrs['class']);\n\t\t\t\n\t\t\tif (!in_array($className, $classNames)) {\n\t\t\t\t// Добавим новый класс в массив с классами:\n\t\t\t\t$classNames[] = $className;\n\t\t\t\t\n\t\t\t\t// Сольем массив в строку и запишем ее в $this-&gt;attrs['class']:\n\t\t\t\t$this-&gt;attrs['class'] = implode(' ', $classNames);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $this;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tРассмотрим теперь вариант, когда в <code class=\"code inline\">$this->attrs['class']</code>\n\tхранится только один класс. На самом деле,\n\tреализованный выше код будет прекрасно работать\n\tи в этом случае: применение <code class=\"code inline\">explode</code>\n\tк строке без пробела просто вернет массив\n\tиз одного элемента, представляющего собой\n\tэту строку. Ну и далее все наши манипуляции\n\tбудут работать также.\n</p>\n<p>\n\tДавайте соберем весь наш код вместе:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function addClass($className)\n\t{\n\t\tif (isset($this-&gt;attrs['class'])) {\n\t\t\t$classNames = explode(' ', $this-&gt;attrs['class']);\n\t\t\t\n\t\t\tif (!in_array($className, $classNames)) {\n\t\t\t\t$classNames[] = $className;\n\t\t\t\t$this-&gt;attrs['class'] = implode(' ', $classNames);\n\t\t\t}\n\t\t} else {\n\t\t\t$this-&gt;attrs['class'] = $className;\n\t\t}\n\t\t\n\t\treturn $this;\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно реализуйте описанный метод\n\t\tи добавьте его в ваш класс <code class=\"code inline\">Tag</code>. Проверьте\n\t\tработу созданного метода, используя приведенные\n\t\tниже примеры:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;input class=\"eee\"&gt;:\n\techo (new Tag('input'))-&gt;addClass('eee')-&gt;open();\n?&gt;</code>\n\t</div>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;input class=\"eee bbb\"&gt;:\n\techo (new Tag('input'))-&gt;addClass('eee')-&gt;addClass('bbb')-&gt;open();\n?&gt;</code>\n\t</div>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;input class=\"eee bbb kkk\"&gt;:\n\techo (new Tag('input'))\n\t\t-&gt;setAttr('class', 'eee bbb')\n\t\t-&gt;addClass('kkk')-&gt;open();\n?&gt;</code>\n\t</div>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;input class=\"eee bbb\"&gt;:\n\techo (new Tag('input'))\n\t\t-&gt;setAttr('class', 'eee bbb')\n\t\t-&gt;addClass('eee') // такой класс уже есть и не добавится\n\t\t-&gt;open();\n?&gt;</code>\n\t</div>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;input class=\"eee bbb\"&gt;:\n\techo (new Tag('input'))\n\t\t-&gt;addClass('eee')\n\t\t-&gt;addClass('bbb')\n\t\t-&gt;addClass('eee') // такой класс уже есть и не добавится\n\t\t-&gt;open();\n?&gt;</code>\n\t</div>\n</div>\n\n<h2>Удаление класса</h2>\n<p>\n\tДавайте теперь реализуем удаление CSS класса.\n\tДля этого было бы удобно иметь вспомогательный\n\tметод, который будет удалять элемент из массива\n\tпо тексту этого элемента. В PHP, к сожалению,\n\tнет такой встроенной функции, поэтому реализуем\n\tее в виде приватного метода:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tprivate function removeElem($elem, $arr)\n\t{\n\t\t$key = array_search($elem, $arr); // находим ключ элемента по его тексту\n\t\tarray_splice($arr, $key, 1); // удаляем элемент\n\t\t\n\t\treturn $arr; // возвращаем измененный массив\n\t}\n?&gt;</code>\n</div>\n<p>\n\tИспользуя метод <code class=\"code inline\">removeElem</code> мы теперь\n\tможем реализовать метод <code class=\"code inline\">removeClass</code>\n\tдля удаления CSS классов. Реализуем:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function removeClass($className)\n\t{\n\t\tif (isset($this-&gt;attrs['class'])) {\n\t\t\t$classNames = explode(' ', $this-&gt;attrs['class']);\n\t\t\t\n\t\t\tif (in_array($className, $classNames)) {\n\t\t\t\t$classNames = $this-&gt;removeElem($className, $classNames);\n\t\t\t\t$this-&gt;attrs['class'] = implode(' ', $classNames);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $this;\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно реализуйте описанный метод\n\t\tи добавьте его в ваш класс <code class=\"code inline\">Tag</code>. Проверьте\n\t\tего работу, например, так:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Tag('input'))\n\t\t-&gt;setAttr('class', 'eee zzz kkk') // добавим 3 класса\n\t\t-&gt;removeClass('zzz') // удалим класс 'zzz'\n\t\t-&gt;open(); // выведет &lt;input class=\"eee kkk\"&gt;\n?&gt;</code>\n\t</div>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Tag/additional-methods/","content":"\n\t\t\t\t<h1>Дополнительные методы класса Tag</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tНаведем некоторый марафет нашему классу,\n\tдобавив дополнительные публичные методы,\n\tкоторые пригодятся нам в дальнейшем.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте геттер <code class=\"code inline\">getName</code>, возвращающий\n\t\tназвание нашего тега (то есть значение свойства\n\t\t<code class=\"code inline\">name</code>).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте геттер <code class=\"code inline\">getText</code>, возвращающий\n\t\tтекст нашего тега (то есть значение свойства\n\t\t<code class=\"code inline\">text</code>).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте геттер <code class=\"code inline\">getAttrs</code>, возвращающий\n\t\tмассив всех атрибутов тега (то есть значение\n\t\tсвойства <code class=\"code inline\">attrs</code>).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте геттер <code class=\"code inline\">getAttr</code>, параметром\n\t\tпринимающий имя атрибута и возвращающий значение\n\t\tэтого атрибута (а если такого атрибута нет\n\t\t- то <code class=\"code inline\">null</code>).\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Tag/final-code/","content":"\n\t\t\t\t<h1>Окончательный вариант класса Tag</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ данном уроке я приведу окончательный вариант\n\tкласса <code class=\"code inline\">Tag</code>, который мы и будем использовать\n\tв дальнейшем в следующих уроках.\n</p>\n<p>\n\tТак как код класса достаточно большой и в\n\tнем много методов, было бы удобно сделать\n\tтак, чтобы наш класс реализовывал некоторый\n\tинтерфейс, в котором в компактном виде были\n\tбы прописаны все публичные методы, который\n\tдолжен иметь наш класс.\n</p>\n<p>\n\tДобавим в интерфейс все публичные методы,\n\tописанные в уроках, а также те методы, которые\n\tбыли описаны в виде задач.\n</p>\n<p>\n\tИтак, вот наш интерфейс:\n</p>\n<div class=\"block\" data-file=\"iTag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tinterface iTag\n\t{\n\t\t// Геттер имени:\n\t\tpublic function getName();\n\t\t\n\t\t// Геттер текста:\n\t\tpublic function getText();\n\t\t\n\t\t// Геттер всех атрибутов:\n\t\tpublic function getAttrs();\n\t\t\n\t\t// Геттер одного атрибута по имени:\n\t\tpublic function getAttr($name);\n\t\t\n\t\t// Открывающий тег, текст и закрывающий тег:\n\t\tpublic function show();\n\t\t\n\t\t// Открывающий тег:\n\t\tpublic function open();\n\t\t\n\t\t// Закрывающий тег:\n\t\tpublic function close();\n\t\t\n\t\t// Установка текста:\n\t\tpublic function setText($text);\n\t\t\n\t\t// Установка атрибута:\n\t\tpublic function setAttr($name, $value = true);\n\t\t\n\t\t// Установка атрибутов:\n\t\tpublic function setAttrs($attrs);\n\t\t\n\t\t// Удаление атрибута:\n\t\tpublic function removeAttr($name);\n\t\t\n\t\t// Установка класса:\n\t\tpublic function addClass($className);\n\t\t\n\t\t// Удаление класса:\n\t\tpublic function removeClass($className);\n\t}\n?&gt;</code>\n</div>\n<p>\n\tА вот код нашего класса <code class=\"code inline\">Tag</code>, реализующего\n\tинтерфейс <code class=\"code inline\">iTag</code>:\n</p>\n<div class=\"block\" data-file=\"Tag.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Tag implements iTag\n\t{\n\t\tprivate $name;\n\t\tprivate $attrs = [];\n\t\tprivate $text = '';\n\t\t\n\t\tpublic function __construct($name)\n\t\t{\n\t\t\t$this-&gt;name = $name;\n\t\t}\n\t\t\n\t\tpublic function getName()\n\t\t{\n\t\t\treturn $this-&gt;name;\n\t\t}\n\t\t\n\t\tpublic function getText()\n\t\t{\n\t\t\treturn $this-&gt;text;\n\t\t}\n\t\t\n\t\tpublic function getAttrs()\n\t\t{\n\t\t\treturn $this-&gt;attrs;\n\t\t}\n\t\t\n\t\tpublic function getAttr($name)\n\t\t{\n\t\t\tif (isset($this-&gt;attrs[$name])) {\n\t\t\t\treturn $this-&gt;attrs[$name];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function show()\n\t\t{\n\t\t\treturn $this-&gt;open() . $this-&gt;text . $this-&gt;close();\n\t\t}\n\t\t\n\t\tpublic function open()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\t$attrsStr = $this-&gt;getAttrsStr($this-&gt;attrs);\n\t\t\t\n\t\t\treturn \"&lt;$name$attrsStr&gt;\";\n\t\t}\n\t\t\n\t\tpublic function close()\n\t\t{\n\t\t\t$name = $this-&gt;name;\n\t\t\treturn \"&lt;/$name&gt;\";\n\t\t}\n\t\t\n\t\tpublic function setText($text)\n\t\t{\n\t\t\t$this-&gt;text = $text;\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tpublic function setAttr($name, $value = true)\n\t\t{\n\t\t\t$this-&gt;attrs[$name] = $value;\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tpublic function setAttrs($attrs)\n\t\t{\n\t\t\tforeach ($attrs as $name =&gt; $value) {\n\t\t\t\t$this-&gt;setAttr($name, $value);\n\t\t\t}\n\t\t\t\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tpublic function removeAttr($name)\n\t\t{\n\t\t\tunset($this-&gt;attrs[$name]);\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tpublic function addClass($className)\n\t\t{\n\t\t\tif (isset($this-&gt;attrs['class'])) {\n\t\t\t\t$classNames = explode(' ', $this-&gt;attrs['class']);\n\t\t\t\t\n\t\t\t\tif (!in_array($className, $classNames)) {\n\t\t\t\t\t$classNames[] = $className;\n\t\t\t\t\t$this-&gt;attrs['class'] = implode(' ', $classNames);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this-&gt;attrs['class'] = $className;\n\t\t\t}\n\t\t\t\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tpublic function removeClass($className)\n\t\t{\n\t\t\tif (isset($this-&gt;attrs['class'])) {\n\t\t\t\t$classNames = explode(' ', $this-&gt;attrs['class']);\n\t\t\t\t\n\t\t\t\tif (in_array($className, $classNames)) {\n\t\t\t\t\t$classNames = $this-&gt;removeElem($className, $classNames);\n\t\t\t\t\t$this-&gt;attrs['class'] = implode(' ', $classNames);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tprivate function getAttrsStr($attrs)\n\t\t{\n\t\t\tif (!empty($attrs)) {\n\t\t\t\t$result = '';\n\t\t\t\t\n\t\t\t\tforeach ($attrs as $name =&gt; $value) {\n\t\t\t\t\tif ($value === true) {\n\t\t\t\t\t\t$result .= \" $name\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$result .= \" $name=\\\"$value\\\"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn $result;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate function removeElem($elem, $arr)\n\t\t{\n\t\t\t$key = array_search($elem, $arr);\n\t\t\tarray_splice($arr, $key, 1);\n\t\t\t\n\t\t\treturn $arr;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Image/","content":"\n\t\t\t\t<h1>Класс Image</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ предыдущих уроках мы с вами реализовали\n\tкласс <code class=\"code inline\">Tag</code> для работы с тегами. Пусть\n\tс помощью этого класса мы хотим сделать картинку:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$image = new Tag('img');\n\techo $image-&gt;setAttr('src', 'img.png')-&gt;open(); // &lt;img src=\"img.png\"&gt;\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем работу с картинками более\n\tудобной. Не будем использовать класс <code class=\"code inline\">Tag</code>,\n\tа создадим специальный класс для работы с\n\tкартинками, назвав его <code class=\"code inline\">Image</code>.\n</p>\n<p>\n\tС использованием нового класса мы могли бы\n\tпереписать код вот так:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$image = new Image();\n\techo $image-&gt;setAttr('src', 'img.png')-&gt;open(); // &lt;img src=\"img.png\"&gt;\n?&gt;</code>\n</div>\n<p>\n\tПока особой разницы, как вы видите, нет.\n\tУ нового класса, однако, есть преимущество\n\t- мы можем сделать вещи, характерные именно\n\tдля тега <code class=\"code inline\">img</code>.\n</p>\n<p>\n\tК примеру, в теге <code class=\"code inline\">img</code> атрибут <code class=\"code inline\">src</code>\n\tявляется обязательным. Было бы удобно, чтобы\n\tновый класс работал так: если атрибут <code class=\"code inline\">src</code>\n\tне задан через <code class=\"code inline\">setAttr</code>, то он все\n\tравно будет созданном теге, но с пустым значением:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$image = new Image();\n\techo $image-&gt;open(); // &lt;img src=\"\"&gt;\n?&gt;</code>\n</div>\n<p>\n\tКроме того, было бы неплохо сделать то же\n\tсамое и для атрибута <code class=\"code inline\">alt</code> (важен для\n\tSEO, желательно, чтобы всегда был):\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$image = new Image();\n\techo $image-&gt;open(); // &lt;img src=\"\" alt=\"\"&gt; - alt тоже будет\n?&gt;</code>\n</div>\n\n<h2>Реализация класса Image</h2>\n<p>\n\tОчевидно, что класс <code class=\"code inline\">Image</code> - это тот\n\tже класс <code class=\"code inline\">Tag</code>, но с некоторыми дополнениями.\n\tЛогично в этом случае не создавать этот класс\n\tс нуля, а унаследовать его от класса <code class=\"code inline\">Tag</code>:\n</p>\n<div class=\"block\" data-file=\"Image.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Image extends Tag\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак мы описали выше, класс <code class=\"code inline\">Image</code> отличается\n\tот класса <code class=\"code inline\">Tag</code> тем, что в <code class=\"code inline\">Image</code>\n\tпо умолчанию задаются атрибуты <code class=\"code inline\">src</code>\n\tи <code class=\"code inline\">alt</code>.\n</p>\n<p>\n\tКроме того, обратите внимание на то, как\n\tмы вызываем конструкторы классов:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$image = new Tag('img');\n\t$image = new Image();\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, класс <code class=\"code inline\">Tag</code> ожидает первым\n\tпараметром имя тега, а класс <code class=\"code inline\">Image</code>\n\tвызывается без параметра - имя тега в данном\n\tслучае нет необходимости задавать, так как\n\tнаш класс всегда делает один и тот же тег\n\t<code class=\"code inline\">img</code>.\n</p>\n<p>\n\tДля того, чтобы реализовать такое поведение,\n\tкласс <code class=\"code inline\">Image</code> должен переопределить\n\tконструктор родителя:\n</p>\n<div class=\"block\" data-file=\"Image.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Image extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t// Вызовем конструктор родителя, передав имя тега:\n\t\t\tparent::__construct('img');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте в этом же конструкторе зададим атрибуты\n\t<code class=\"code inline\">src</code> и <code class=\"code inline\">alt</code>:\n</p>\n<div class=\"block\" data-file=\"Image.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Image extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;setAttr('src', ''); // установим атрибут src\n\t\t\t$this-&gt;setAttr('alt', ''); // установим атрибут alt\n\t\t\t\n\t\t\tparent::__construct('img'); // вызовем конструктор родителя\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tУстановку атрибутов можно упростить и выполнить\n\tв виде цепочки:\n</p>\n<div class=\"block\" data-file=\"Image.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Image extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;setAttr('src', '')-&gt;setAttr('alt', '');\n\t\t\tparent::__construct('img');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПри использовании нашего класса в дальнейшем\n\tмы можем затереть эти атрибуты с помощью\n\t<code class=\"code inline\">setAttr</code> на свое значение, а можем\n\tне затереть - тогда они так и останутся со\n\tзначением '', смотрите пример:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Затрем src, но не alt:\n\techo (new Image())-&gt;setAttr('src', 'img.png')-&gt;open(); // &lt;img src=\"img.png\" alt=\"\"&gt;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно напишите реализацию описанного\n\t\tкласса <code class=\"code inline\">Image</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tИспользуя созданный вами класс выведите на\n\t\tэкран какую-нибудь картинку.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tУстановите созданной вами картинке атрибут\n\t\t<code class=\"code inline\">width</code> в значение <code class=\"number inline\">300</code>, а атрибут\n\t\t<code class=\"code inline\">height</code> - в значение <code class=\"number inline\">200</code>.\n\t</p>\n</div>\n\n<h2>Откажемся от open</h2>\n<p>\n\tВ классе <code class=\"code inline\">Tag</code> у нас есть два метода,\n\tкоторые используются для завершения цепочки\n\tи вывода тега на экран: это метод <code class=\"code inline\">open</code>\n\tи метод <code class=\"code inline\">show</code>.\n</p>\n<p>\n\tПочему у нас два метода: потому что класс\n\t<code class=\"code inline\">Tag</code> универсальный и предполагает использование\n\tкак для тегов, не требующих закрытия, так\n\tи для парных тегов.\n</p>\n<p>\n\tОчевидно, что при использовании класса <code class=\"code inline\">Image</code>\n\tмы всегда будем завершать цепочку методом\n\t<code class=\"code inline\">open</code>. Раз так, то давайте сделаем\n\tиспользование метода <code class=\"code inline\">open</code> не обязательным.\n\tТо есть вместо этого:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Image())-&gt;setAttr('src', 'img.png')-&gt;open();\n?&gt;</code>\n</div>\n<p>\n\tМы будем писать вот так:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Image())-&gt;setAttr('src', 'img.png');\n?&gt;</code>\n</div>\n<p>\n\tИспользуем для этого магический метод <code class=\"code inline\">__toString</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Image extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;setAttr('src', '')-&gt;setAttr('alt', '');\n\t\t\tparent::__construct('img');\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn parent::open(); // вызываем метод родителя\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТеперь получается, что при попытке преобразования\n\tобъекта в строку, например, при выводе его\n\tчерез <code class=\"code inline\">echo</code>, автоматически будет вызываться\n\tметод <code class=\"code inline\">__toString</code>, внутри которого\n\tбудет вызываться метод <code class=\"code inline\">open</code>.\n</p>\n<p>\n\tНапоминаю, что если не выводить объект на\n\tэкран, а, например, записать в переменную,\n\tто в эту переменную попадет объект, а не\n\tего строковое представление:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// В переменную $image запишется объект:\n\t$image = (new Image())-&gt;setAttr('src', 'img.png');\n\t\n\t$image-&gt;setAttr('width', '200'); // вызовем еще метод\n\techo $image; // тут сработает __toString\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно напишите реализацию метода\n\t\t<code class=\"code inline\">__toString</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Link/","content":"\n\t\t\t\t<h1>Класс Link</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте сделаем класс, который будет создавать\n\tHTML ссылку. Назовем его <code class=\"code inline\">Link</code>. Вот\n\tтак мы будем пользоваться нашим классом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;a href=\"/test.html\"&gt;link&lt;/a&gt;:\n\techo (new Link())-&gt;setAttr('href', '/test.html')-&gt;setText('link')-&gt;show();\n?&gt;</code>\n</div>\n<p>\n\tРеализация:\n</p>\n<div class=\"block\" data-file=\"Link.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Link extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent::__construct('a');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСделаем так, чтобы даже если атрибут <code class=\"code inline\">href</code>\n\tне задан, то по умолчанию он становился пустыми\n\tкавычками:\n</p>\n<div class=\"block\" data-file=\"Link.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Link extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent::__construct('a');\n\t\t\t$this-&gt;setAttr('href', '');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Выведет &lt;a href=\"\"&gt;index&lt;/a&gt;:\n\techo (new Link())-&gt;setText('index')-&gt;show();\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно реализуйте описанный класс\n\t\t<code class=\"code inline\">Link</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tС помощью этого класса создайте меню из <code class=\"number inline\">5</code>\n\t\tссылок. Пусть первая ссылка ведет на страницу\n\t\t<code class=\"code inline\">/1.php</code>, вторая - на страницу <code class=\"code inline\">/2.php</code>\n\t\tи так далее.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРазместите созданную менюшку в отдельном\n\t\tфайле, например, в <code class=\"code inline\">menu.php</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте страницы, на которые ведут ссылки\n\t\tвашей менюшки. Добавьте в ним какой-нибудь текст.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПодключите инклудом к тексту каждой страницы\n\t\tвашу менюшку из файла. Убедитесь, что ссылки\n\t\tиз этой менюшки будут работать корректно.\n\t</p>\n</div>\n\n<h2>Активация ссылок</h2>\n<p>\n\tПосле выполнения задач у вас должна получится\n\tменюшка. Давайте сделаем так, чтобы в этой\n\tменюшке выделялась каким-то образом та ссылка,\n\tна странице которой мы находимся.\n</p>\n<p>\n\tТакая ссылка обычно называется <dfn>активной</dfn>\n\tи ее выделение происходит путем добавления\n\tей CSS класса <code class=\"code inline\">active</code> (общепринятое\n\tназвание).\n</p>\n<p>\n\tДобавленный к ссылке класс <code class=\"code inline\">active</code>\n\tкаким-то образом выделяет ее - подчеркивает,\n\tкрасит в красный цвет и тому подобное: все\n\tэто регулируется CSS стилями для этого класса.\n</p>\n<p>\n\tИтак, давайте сделаем так, чтобы ссылки автоматически\n\tактивировались (добавляли себе CSS класс\n\t<code class=\"code inline\">active</code>), если их <code class=\"code inline\">href</code> совпадает\n\tс урлом сайта.\n</p>\n<p>\n\t<code class=\"code inline\">URL</code> сайта можно достать вот так:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo $_SERVER['REQUEST_URI'];\n?&gt;</code>\n</div>\n<p>\n\tЧтобы прочитать <code class=\"code inline\">href</code> нашей ссылки,\n\tиспользуем геттер <code class=\"code inline\">getAttr</code>, унаследованный\n\tот родительского класса <code class=\"code inline\">Tag</code>. Вот так:\n</p>\n<div class=\"block\" data-file=\"Link.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$href = $this-&gt;getAttr('href');\n?&gt;</code>\n</div>\n<p>\n\tЧтобы добавить нашей ссылке CSS класс <code class=\"code inline\">active</code>,\n\tиспользуем метод <code class=\"code inline\">addClass</code>, также унаследованный\n\tот родителя. Вот так:\n</p>\n<div class=\"block\" data-file=\"Link.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$this-&gt;addClass('active')\n?&gt;</code>\n</div>\n<p>\n\tСоберем все вместе и напишем вспомогательный\n\tметод <code class=\"code inline\">activateSelf</code>, который будет\n\tпроверять, совпадает ли <code class=\"code inline\">href</code> ссылки\n\tи <code class=\"code inline\">URI</code>, и активировать ее, если это так:\n</p>\n<div class=\"block\" data-file=\"Link.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tprivate function activateSelf()\n\t{\n\t\tif ($this-&gt;getAttr('href') === $_SERVER['REQUEST_URI']) {\n\t\t\t$this-&gt;addClass('active');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tОсталось придумать в каком месте вызывать\n\tсозданный нами метод. В конструкторе класса\n\t<code class=\"code inline\">Link</code> этого делать нельзя, так как\n\tв момент вызова конструктора <code class=\"code inline\">href</code>\n\tссылки еще не задан (конструктор же вызывается\n\tв самом начале, а потом методы цепочки, в\n\tтом числе <code class=\"code inline\">setAttr</code>, который и задает\n\t<code class=\"code inline\">href</code> ссылки).\n</p>\n<p>\n\tПосле таких рассуждений становится очевидным,\n\tчто метод <code class=\"code inline\">activateSelf</code> следует вызвать\n\tв момент вывода ссылки на экран, то есть\n\tв методе <code class=\"code inline\">show</code>, с помощью которого\n\tскорее всего и будет формироваться ссылка.\n</p>\n<p>\n\tОднако, представляется возможным то, что\n\tпри использовании нашего класса кто-то будет\n\tприменять метод <code class=\"code inline\">open</code> и метод <code class=\"code inline\">close</code>\n\tотдельно.\n</p>\n<p>\n\tХотя описанное выше и маловероятно, тем не\n\tменее вызовем метод <code class=\"code inline\">activateSelf</code> в\n\tметоде <code class=\"code inline\">open</code>, переопределив тем самым\n\tметод родителя:\n</p>\n<div class=\"block\" data-file=\"Link.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Link extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;setAttr('href', '');\n\t\t\tparent::__construct('a');\n\t\t}\n\t\t\n\t\t// Переопределяем метод родителя:\n\t\tpublic function open()\n\t\t{\n\t\t\t$this-&gt;activateSelf(); // вызываем активацию\n\t\t\treturn parent::open(); // вызываем метод родителя\n\t\t}\n\t\t\n\t\tprivate function activateSelf()\n\t\t{\n\t\t\tif ($this-&gt;getAttr('href') === $_SERVER['REQUEST_URI']) {\n\t\t\t\t$this-&gt;addClass('active');\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТак как метод <code class=\"code inline\">show</code> использует внутри\n\tсебя метод <code class=\"code inline\">open</code>, то изменения для\n\tметода <code class=\"code inline\">show</code> произойдут автоматически.\n\tМожем теперь проверить работу нашего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Link)-&gt;setAttr('href', '/index.php')-&gt;setText('index')-&gt;show();\n\t\n\t/*\n\t\tЕсли URL страницы не /index.php,\n\t\tто результат выполнения кода выведет\n\t\t&lt;a href=\"/index.php\"&gt;index&lt;/a&gt;\n\t\t\n\t\tЕсли URL страницы /index.php,\n\t\tто результат выполнения кода выведет\n\t\t&lt;a href=\"/index.php\" class=\"active\"&gt;index&lt;/a&gt;\n\t*/\n?&gt;</code>\n</div>\n<p>\n\tИтак, теперь ссылки активируют сами себя.\n\tЭто реально круто! При этом нам понадобилось\n\tсовсем мало кода, чтобы реализовать такое\n\tповедение. Все потому, что у нас есть базовый\n\tкласс <code class=\"code inline\">Tag</code>, который прячет внутри себя\n\tмного универсального кода для манипуляций\n\tс тегами.\n</p>\n<p>\n\tРеализуя новые классы на основе класса <code class=\"code inline\">Tag</code>\n\tмы не держим в голове детали реализации этого\n\tкласса <code class=\"code inline\">Tag</code>. И вообще не видим код\n\tэтого класса - он где-то в другом файле (если,\n\tконечно же, вы его туда вынесли) и не мешает\n\tнам работать. Мы просто знаем, какие методы\n\tпредоставляет этот класс своим потомкам -\n\tи пользуемся ими.\n</p>\n<p>\n\tПоэтому классы-потомки и получаются такими\n\tмаленькими и изящными.\n</p>\n<p>\n\tНа самом деле наш код класса <code class=\"code inline\">Link</code>\n\tеще более крут, чем кажется. Дело в том,\n\tчто наши ссылки могут иметь и другие - постоянные\n\t- классы. При этом наша активация никак не\n\tбудет мешать этим классам - они будут оставаться,\n\tпросто к ним будет добавляться еще и класс\n\t<code class=\"code inline\">active</code>.\n</p>\n<p>\n\tВсе потому, что так работает метод <code class=\"code inline\">addClass</code>\n\t- он добавляет новый класс к уже существующим\n\tклассам.\n</p>\n<p>\n\tВот пример:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Link)\n\t\t-&gt;setAttr('href', '/index.php')\n\t\t-&gt;setAttr('class', 'link1 link2') // добавляем ссылке классы\n\t\t-&gt;setText('index')\n\t\t-&gt;show();\n\t\n\t/*\n\t\tРезультат выполнения кода выведет\n\t\t&lt;a href=\"/index.html\" class=\"link1 link2 active\"&gt;index&lt;/a&gt;\n\t*/\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в ваш класс <code class=\"code inline\">Link</code> активацию ссылок.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПроверьте работу активации ссылок на менюшке,\n\t\tкоторую вы создали в предыдущих задачах.\n\t\tХарактерно, что правки в саму менюшку вносить\n\t\tне надо - создание ссылок никак не поменялось,\n\t\tпросто ссылки теперь активируют сами себя.\n\t\tПопереходите по ссылкам меню и убедитесь\n\t\tв том, что соответствующие ссылки активируются.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tНе очень хорошо то, что название класса <code class=\"code inline\">active</code>\n\t\tжестко зашито в коде (вдруг мы захотим поменять\n\t\tего на другое). Вынесите его в константу\n\t\tкласса (константу используем для того, чтобы\n\t\tв процессе работы скрипта случайно не изменить\n\t\tнаш CSS класс).\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/HtmlList/","content":"\n\t\t\t\t<h1>Класс HtmlList</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами сделаем класс <code class=\"code inline\">HtmlList</code>\n\tдля создания списков <code class=\"code inline\">ul</code> и <code class=\"code inline\">ol</code>.\n\tУ этого класса будет метод <code class=\"code inline\">addItem</code>\n\tдля добавления пунктов списка и метод <code class=\"code inline\">show</code>\n\tдля вывода результата на экран.\n</p>\n<p>\n\tДля самих пунктов списка также сделаем отдельный\n\tкласс, назовем его <code class=\"code inline\">ListItem</code>. Вот пример\n\tтого, как мы будем пользоваться нашими классами:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$list = new HtmlList('ul');\n\t\n\techo $list\n\t\t-&gt;addItem( (new ListItem())-&gt;setText('item1') )\n\t\t-&gt;addItem( (new ListItem())-&gt;setText('item2') )\n\t\t-&gt;addItem( (new ListItem())-&gt;setText('item3') )\n\t\t-&gt;show();\n\t\n\t/*\n\t\tРезультат выполнения кода выведет следующее:\n\t\t&lt;ul&gt;\n\t\t\t&lt;li&gt;item1&lt;/li&gt;\n\t\t\t&lt;li&gt;item2&lt;/li&gt;\n\t\t\t&lt;li&gt;item3&lt;/li&gt;\n\t\t&lt;/ul&gt;\n\t*/\n?&gt;</code>\n</div>\n\n<h2>Реализация</h2>\n<p>\n\tКласс <code class=\"code inline\">ListItem</code> по сути этот тот же\n\tкласс <code class=\"code inline\">Tag</code>. С той разницей, что конструктор\n\tкласса <code class=\"code inline\">Tag</code> требует имя тега, а конструктор\n\t<code class=\"code inline\">ListItem</code> не требует параметров, так\n\tкак всегда создает один и тот же тег <code class=\"code inline\">li</code>.\n</p>\n<p>\n\tПоэтому для реализации класса <code class=\"code inline\">ListItem</code>\n\tдостаточно просто просто наследовать от класса\n\t<code class=\"code inline\">Tag</code>, переопределив его конструктор:\n</p>\n<div class=\"block\" data-file=\"ListItem.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass ListItem extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent::__construct('li');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь напишем реализацию класса\n\t<code class=\"code inline\">HtmlList</code>. Данный класс также удобно\n\tунаследовать от <code class=\"code inline\">Tag</code>, расширив затем\n\tродителя нужными нам методами. Итак, наследуем:\n</p>\n<div class=\"block\" data-file=\"HtmlList.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass HtmlList extends Tag\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<!--\n<p class=\"comment\">\n\tКласс <code class=\"code inline\">HtmlList</code> предназначен как для создания тегов\n\t<code class=\"code inline\">ul</code>, так и для создания тегов <code class=\"code inline\">ol</code>. Тип тега будет\n\tпередаваться параметром конструктора, поэтому наш\n\tкласс <code class=\"code inline\">HtmlList</code> не будет переопределять конструктор\n\tродителя - этот конструктор как раз такой, как нам нужно.\n</p>\n<p class=\"comment\">\n\tВнимательный читатель может заметить, что на самом\n\tделе в конструктор класса <code class=\"code inline\">HtmlList</code> можно передать любое\n\tимя тега, не только <code class=\"code inline\">ul</code> или <code class=\"code inline\">ol</code>. Пока проигнорируем эту проблему,\n\tоставив контроль имени тега на программисте-пользователе\n\tнашего класса.\n</p>\n-->\n<p>\n\tРеализуем метод <code class=\"code inline\">addItem</code> для добавления\n\tпунктов списка:\n</p>\n<div class=\"block\" data-file=\"HtmlList.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass HtmlList extends Tag\n\t{\n\t\tprivate $items = []; // массив для хранения лишек\n\t\t\n\t\tpublic function addItem($li)\n\t\t{\n\t\t\t$this-&gt;items[] = $li;\n\t\t\treturn $this; // вернем $this для цепочки\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте улучшим наш код, указав, что параметр\n\tнашего метода принимает только объекты класса\n\t<code class=\"code inline\">ListItem</code>:\n</p>\n<div class=\"block\" data-file=\"HtmlList.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass HtmlList extends Tag\n\t{\n\t\tprivate $items = [];\n\t\t\n\t\tpublic function addItem(ListItem $li)\n\t\t{\n\t\t\t$this-&gt;items[] = $li;\n\t\t\treturn $this;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь сделаем метод <code class=\"code inline\">show</code>.\n\tНа самом деле наш класс <code class=\"code inline\">HtmlList</code> наследует\n\tот своего родителя такой метод - но этот\n\tнаследуемый метод делает немного не то, что\n\tнам нужно.\n</p>\n<p>\n\tНаследуемый метод <code class=\"code inline\">show</code> выводит открывающий\n\tтег, закрывающий, а между ними текст. Но\n\tв нашем случае в качестве текста будут выступать\n\tтеги <code class=\"code inline\">li</code>.\n</p>\n<p>\n\tДавайте в таком случае просто переопределим\n\tметод <code class=\"code inline\">show</code> родителя и напишем ему\n\tсвою реализацию:\n</p>\n<div class=\"block\" data-file=\"HtmlList.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass HtmlList extends Tag\n\t{\n\t\tprivate $items = [];\n\t\t\n\t\tpublic function addItem(ListItem $li)\n\t\t{\n\t\t\t$this-&gt;items[] = $li;\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\t// Переопределим метод родителя:\n\t\tpublic function show()\n\t\t{\n\t\t\t// тут будет наша реализация без вызова parent::show\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПишем свою реализацию:\n</p>\n<div class=\"block\" data-file=\"HtmlList.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function show()\n\t{\n\t\t$result = $this-&gt;open(); // открывающий тег\n\t\t\n\t\t// тут надо сформировать лишки и добавить в $result\n\t\t\n\t\t$result .= $this-&gt;close(); // закрывающий тег\n\t\t\n\t\treturn $result;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сформируем лишки. Для этого запустим\n\tцикл <code class=\"code inline\">foreach</code> для массива <code class=\"code inline\">$this->items</code>:\n</p>\n<div class=\"block\" data-file=\"HtmlList.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function show()\n\t{\n\t\t$result = $this-&gt;open();\n\t\t\n\t\tforeach ($this-&gt;items as $item) {\n\t\t\t$result .= 'тут нужно добавлять теги li';\n\t\t}\n\t\t\n\t\t$result .= $this-&gt;close();\n\t\t\n\t\treturn $result;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВ нашем цикле нужно в переменную <code class=\"code inline\">$result</code>\n\tзаписывать теги <code class=\"code inline\">li</code> в формате:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;li&gt;текст&lt;/li&gt;</code>\n</div>\n<p>\n\tЗдесь нам очень поможет то, что объекты класса\n\t<code class=\"code inline\">ListItem</code> являются наследниками класса\n\t<code class=\"code inline\">Tag</code>, а следовательно, имеют метод\n\t<code class=\"code inline\">show</code>, который и делает то, что нам нужно.\n</p>\n<p>\n\tВ нашем цикле <code class=\"code inline\">foreach</code> в переменную\n\t<code class=\"code inline\">$item</code> как раз-таки попадают объекты\n\tкласса <code class=\"code inline\">ListItem</code>. Значит, просто будем\n\tвызывать у них метод <code class=\"code inline\">show</code> и наша задача\n\tбудет решена:\n</p>\n<div class=\"block\" data-file=\"HtmlList.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tpublic function show()\n\t{\n\t\t$result = $this-&gt;open();\n\t\t\n\t\tforeach ($this-&gt;items as $item) {\n\t\t\t$result .= $item-&gt;show(); // вызываем метод show\n\t\t}\n\t\t\n\t\t$result .= $this-&gt;close();\n\t\t\n\t\treturn $result;\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДобавим созданный метод <code class=\"code inline\">show</code> в наш\n\tкласс <code class=\"code inline\">HtmlList</code>:\n</p>\n<div class=\"block\" data-file=\"HtmlList.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass HtmlList extends Tag\n\t{\n\t\tprivate $items = [];\n\t\t\n\t\tpublic function addItem(ListItem $li)\n\t\t{\n\t\t\t$this-&gt;items[] = $li;\n\t\t\treturn $this;\n\t\t}\n\t\t\n\t\tpublic function show()\n\t\t{\n\t\t\t$result = $this-&gt;open();\n\t\t\t\n\t\t\tforeach ($this-&gt;items as $item) {\n\t\t\t\t$result .= $item-&gt;show();\n\t\t\t}\n\t\t\t\n\t\t\t$result .= $this-&gt;close();\n\t\t\t\n\t\t\treturn $result;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте проверим работу нашего класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$list = new HtmlList('ul');\n\t\n\techo $list\n\t\t-&gt;addItem((new ListItem())-&gt;setText('item1'))\n\t\t-&gt;addItem((new ListItem())-&gt;setText('item2'))\n\t\t-&gt;addItem((new ListItem())-&gt;setText('item3'))\n\t\t-&gt;show();\n?&gt;</code>\n</div>\n<p>\n\tРезультат выполнения кода выведет следующее\n\t(форматирование мое):\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;ul&gt;\n\t&lt;li&gt;item1&lt;/li&gt;\n\t&lt;li&gt;item2&lt;/li&gt;\n\t&lt;li&gt;item3&lt;/li&gt;\n&lt;/ul&gt;</code>\n</div>\n<p>\n\tА теперь рассмотрим не очевидные на первый\n\tвзгляд бонусы: так как и класс <code class=\"code inline\">HtmlList</code>,\n\tи класс <code class=\"code inline\">ListItem</code> наследуют от класса\n\t<code class=\"code inline\">Tag</code>, то автоматически получают все\n\tего методы, например, <code class=\"code inline\">setAttr</code>.\n</p>\n<p>\n\tЭто дает нам возможность задавать атрибуты\n\tсоздаваемых тегов. Смотрите пример:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$list = new HtmlList('ul');\n\t\n\techo $list-&gt;setAttr('class', 'eee')\n\t\t-&gt;addItem((new ListItem())-&gt;setText('item1')-&gt;setAttr('class', 'first'))\n\t\t-&gt;addItem((new ListItem())-&gt;setText('item2'))\n\t\t-&gt;addItem((new ListItem())-&gt;setText('item3'))\n\t\t-&gt;show();\n\t\n\t/*\n\t\tРезультат выполнения кода выведет следующее:\n\t\t&lt;ul class=\"eee\"&gt;\n\t\t\t&lt;li class=\"first\"&gt;item1&lt;/li&gt;\n\t\t\t&lt;li&gt;item2&lt;/li&gt;\n\t\t\t&lt;li&gt;item3&lt;/li&gt;\n\t\t&lt;/ul&gt;\n\t*/\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте самостоятельно описанные мною\n\t\tклассы. Проверьте их работу.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте так, чтобы при преобразовании наших\n\t\tклассов к строке, метод <code class=\"code inline\">show</code> не нужно\n\t\tбыло вызывать. Модифицируйте весь код в соответствии\n\t\tс этим. Не забудьте про вот это место метода\n\t\t<code class=\"code inline\">show</code> класса <code class=\"code inline\">HtmlList</code>:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tforeach ($this-&gt;items as $item) {\n\t\t$result .= $item-&gt;show(); // здесь тоже преобразование к строке\n\t}\n?&gt;</code>\n\t</div>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте классы <code class=\"code inline\">Ul</code> и <code class=\"code inline\">Ol</code>, которые\n\t\tбудут наследовать от класса <code class=\"code inline\">HtmlList</code>.\n\t\tЭти классы должны будут создавать соответствующий\n\t\tтип списков. Пример:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$ul = new Ul; // сделаем список ul\n\t$ol = new Ol; // сделаем список ol\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tС помощью созданных классов выведите следующие\n\t\tсписки:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;ul&gt;\n\t&lt;li&gt;item1&lt;/li&gt;\n\t&lt;li&gt;item2&lt;/li&gt;\n\t&lt;li&gt;item3&lt;/li&gt;\n&lt;/ul&gt;</code>\n\t</div>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;ol&gt;\n\t&lt;li&gt;item1&lt;/li&gt;\n\t&lt;li&gt;item2&lt;/li&gt;\n\t&lt;li&gt;item3&lt;/li&gt;\n&lt;/ol&gt;</code>\n\t</div>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Form/","content":"\n\t\t\t\t<h1>Класс Form</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами займемся созданием классов\n\tдля работы с HTML формами. Первый класс,\n\tкоторый мы с вами сделаем, предназначен для\n\tсоздания открывающего и закрывающего тега\n\t<a href=\"/ru/markup/manual/html/tag/form/\"><code class=\"code inline\">form</code></a>.\n</p>\n<p>\n\tТак этот класс и назовем - <code class=\"code inline\">Form</code>. Вот\n\tпример его использования:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs([\n\t\t'action' =&gt; 'test.php',\n\t\t'method' =&gt; 'POST'\n\t]);\n\t\n\techo $form-&gt;open();\n\t\t// здесь потом будут элементы формы\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<p>\n\tВ результате выполнения кода мы должны получить\n\tследующую форму (здесь и далее форматирование\n\tHTML выполнено мною для удобства вашего восприятия):\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;form action=\"test.php\" method=\"POST\"&gt;\n\t\n&lt;/form&gt;</code>\n</div>\n<p>\n\tРеализуем наш класс:\n</p>\n<div class=\"block\" data-file=\"Form.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Form extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent::__construct('form');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">Form</code> самостоятельно\n\t\tи проверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Form/Input/","content":"\n\t\t\t\t<h1>Класс Input</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте теперь сделаем класс <code class=\"code inline\">Input</code>\n\tдля работы с инпутами. Вот готовая реализация\n\tэтого класса:\n</p>\n<div class=\"block\" data-file=\"Input.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Input extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent::__construct('input');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте используем новый класс <code class=\"code inline\">Input</code>\n\tвместе с уже созданным нами классом <code class=\"code inline\">Form</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs(['action' =&gt; '', 'method' =&gt; 'GET']);\n\t\n\techo $form-&gt;open();\n\t\techo (new Input)-&gt;setAttr('name', 'year')-&gt;open();\n\t\techo (new Input)-&gt;setAttr('type', 'submit')-&gt;open();\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующая форма:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;form action=\"\" method=\"GET\"&gt;\n\t&lt;input name=\"year\"&gt;\n\t&lt;input type=\"submit\"&gt;\n&lt;/form&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте себе мой код класса <code class=\"code inline\">Input</code>.\n\t\tСкопируйте пример формы. Запустите его в\n\t\tбраузере, убедитесь, что форма действительно\n\t\tпоявляется. Вбейте какие-нибудь данные в\n\t\tинпут и нажмите на кнопку отправки. Убедитесь,\n\t\tчто форма действительно рабочая.\n\t</p>\n</div>\n\n<h2>Убираем open</h2>\n<p>\n\tДавайте уберем метод <code class=\"code inline\">open</code>, добавив\n\tмагию метода <code class=\"code inline\">__toString</code>:\n</p>\n<div class=\"block\" data-file=\"Input.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Input extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent::__construct('input');\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn parent::open();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПерепишите приведенный ниже код с учетом\n\t\tнашей правки:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs(['action' =&gt; '', 'method' =&gt; 'GET']);\n\t\n\techo $form-&gt;open();\n\t\techo (new Input)-&gt;setAttr('name', 'year')-&gt;open();\n\t\techo (new Input)-&gt;setAttr('type', 'submit')-&gt;open();\n\techo $form-&gt;close();\n?&gt;</code>\n\t</div>\n</div>\n\n<h2>Некоторые замечания</h2>\n<p>\n\tПока наш PHP код формы получается длиннее\n\tсоответствующего HTML кода. Возникает вопрос:\n\tзачем нам PHP вариант, если все намного короче\n\tможно написать на HTML?\n</p>\n<p>\n\tВсе дело в том, что наша PHP реализация дает\n\tнам дополнительные возможности. Например,\n\tмы можем сделать так, чтобы данные из инпутов\n\tне исчезали после отправки формы.\n</p>\n<p>\n\tИ теперь преимущество в длине кода будет\n\tуже на стороне PHP варианта - длина HTML\n\tварианта существенно вырастет, а длина PHP\n\tварианта останется неизменной.\n</p>\n\n<!--\n<h2>Сохранение значений после отправки</h2>\n<p>\n\tПока наш PHP код формы получается длиннее\n\tсоответствующего HTML кода. Возникает вопрос:\n\tзачем нам PHP вариант, если все намного короче\n\tможно написать на HTML?\n</p>\n<p>\n\tВсе дело в том, что наша PHP реализация дает\n\tнам дополнительные возможности. Например,\n\tмы можем сделать так, чтобы данные из инпутов\n\tне исчезали после отправки формы.\n</p>\n<p>\n\tИ теперь преимущество в длине кода будет\n\tуже на стороне PHP варианта - длина HTML\n\tварианта существенно вырастет, а длина PHP\n\tварианта останется неизменной.\n</p>\n<p>\n\tПосмотрим на примере. Сделаем сохранение\n\tзначения одного инпута в HTML варианте формы:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;form action=\"\" method=\"GET\"&gt;\n\t&lt;input name=\"year\" value=\"&lt;?php if (isset($_REQUEST['year'])) echo $_REQUEST['year']; ?&gt;\"&gt;\n\t&lt;input type=\"submit\"&gt;\n&lt;/form&gt;</code>\n</div>\n<p>\n\tСоответствующий PHP:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs(['action' =&gt; '', 'method' =&gt; 'GET']);\n\t\n\techo $form-&gt;open();\n\t\techo (new Input)-&gt;setAttr('name', 'year');\n\t\techo (new Input)-&gt;setAttr('type', 'submit');\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<p>\n\tПусть у нас несколько инпутов:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;form action=\"\" method=\"GET\"&gt;\n\t&lt;input name=\"field1\" value=\"&lt;?php if (isset($_REQUEST['field1'])) echo $_REQUEST['field1']; ?&gt;\"&gt;\n\t&lt;input name=\"field2\" value=\"&lt;?php if (isset($_REQUEST['field2'])) echo $_REQUEST['field2']; ?&gt;\"&gt;\n\t&lt;input type=\"submit\"&gt;\n&lt;/form&gt;</code>\n</div>\n<p>\n\tСоответствующий PHP:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs(['action' =&gt; '', 'method' =&gt; 'GET']);\n\t\n\techo $form-&gt;open();\n\t\techo (new Input)-&gt;setAttr('field1', 'year');\n\t\techo (new Input)-&gt;setAttr('field2', 'year');\n\t\techo (new Input)-&gt;setAttr('name', 'submit');\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, длина инпутов PHP варианта\n\tтеперь существенно короче.\n</p>\n<p>\n\tКроме того, HTML вариант имеет еще один существенный\n\tнедостаток - для корректной работы имя инпута\n\tнужно повторить аж <code class=\"number inline\">3</code> раза: тут <i>name=\"field1\"</i>,\n\tтут <i>isset($_REQUEST['field1'])</i> и тут\n\t<i>echo $_REQUEST['field1']</i>.\n</p>\n<p>\n\tПредставьте, каким кошмаром будет изменения\n\tимен нескольких инпутов. Это не говоря о\n\tвозможность в одном из мест просто забыть\n\tизменить имя - и инпут будет работать некорректно.\n</p>\n<p>\n\tВ PHP варианте имя инпута задает в одном месте.\n</p>\n<p>\n\tУбедившись в преимуществах нашего варианта\n\tформы, приступим к его реализации.\n</p>\n-->\n\n<h2>Реализация сохранения значений после отправки</h2>\n<p>\n\tКак вы должны знать, значение инпута задается\n\tв атрибуте <code class=\"code inline\">value</code>. Нам необходимо сделать\n\tследующее: если форма была отправлена, то\n\tв <code class=\"code inline\">value</code> инпута следует записать то\n\tзначение, которое было в нем в момент отправки.\n</p>\n<p>\n\tКаким образом получить это значение? Пусть\n\tимя инпута было <code class=\"code inline\">year</code>. В этом случае\n\tпосле отправки формы в <code class=\"code inline\">$_REQUEST['year']</code>\n\tи будет находится нужное нам значение.\n</p>\n<p>\n\tВ нашем случае имя инпута хранится в родительском\n\tклассе <code class=\"code inline\">Tag</code> в приватном свойстве <code class=\"code inline\">$attrs</code>.\n\tНаш класс <code class=\"code inline\">Input</code> как потомок класса\n\t<code class=\"code inline\">Tag</code> может получить доступ к любому\n\tатрибуту с помощью геттера, вот так: <i>$inputName\n\t= $this->getAttr('name')</i>.\n</p>\n<p>\n\tДавайте получим имя нашего инпута, достанем\n\tзначение из <code class=\"code inline\">$_REQUEST</code> по этому имени\n\tи запишем в <code class=\"code inline\">value</code> инпута:\n</p>\n<div class=\"block\" data-file=\"Input.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Input extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent:__construct('input');\n\t\t}\n\t\t\n\t\t// Переопределяем метод родителя:\n\t\tpublic function open()\n\t\t{\n\t\t\t$inputName = $this-&gt;getAttr('name'); // имя инпута\n\t\t\t$value = $_REQUEST[$inputName]; // получаем значение инпута по его имени\n\t\t\t\n\t\t\t$this-&gt;setAttr('value', $value); // записываем в value инпута\n\t\t\t\n\t\t\treturn parent::open(); // вызываем метод open родителя\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn $this-&gt;open(); // здесь теперь не метод родителя, а наш\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПриведенный выше код пока не очень корректный:\n\tон не учитывает того, что отправки формы\n\tмогло еще и не быть. Давайте учтем:\n</p>\n<div class=\"block\" data-file=\"Input.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t// Пока не запускайте этот код, есть нюансы...\n\t\n\tclass Input extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent:__construct('input');\n\t\t}\n\t\t\n\t\t// Переопределяем метод родителя:\n\t\tpublic function open()\n\t\t{\n\t\t\t$inputName = $this-&gt;getAttr('name'); // имя инпута\n\t\t\t\n\t\t\t// Если форма была отправлена и есть данные с именем нашего инпута:\n\t\t\tif (isset($_REQUEST[$inputName])) {\n\t\t\t\t$value = $_REQUEST[$inputName]; // получаем значение из $_REQUEST\n\t\t\t\t$this-&gt;setAttr('value', $value); // записываем в value инпута\n\t\t\t}\n\t\t\t\n\t\t\treturn parent::open(); // вызываем метод open родителя\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn $this-&gt;open();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВот теперь наш код уже достаточно рабочий,\n\tно есть пару нюансов.\n</p>\n<p>\n\tЧто будет, если у нашего инпута по умолчанию\n\tуже есть какое-то значение (например, текущий\n\tгод), например, вот так:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Input)\n\t\t-&gt;setAttr('name', 'year')\n\t\t-&gt;setAttr('value', date('Y')); // значение по умолчанию\n?&gt;</code>\n</div>\n<p>\n\tВ этом случае <code class=\"code inline\">в теории</code> по заходу на\n\tстраницу мы должны увидеть текущий год, но\n\tпри желании можем его поменять, нажать на\n\tкнопку отправки - и после обновления страницы\n\tв инпуте будет тот год, который и был отправлен.\n</p>\n<p>\n\tНа самом деле наш код так и работает! Если\n\tбыла отправка формы, то мы попадем в условие\n\tи там изменим <code class=\"code inline\">value</code> инпута, но если\n\tотправки не было - <code class=\"code inline\">value</code> инпута останется\n\tтаким, как и было задано.\n</p>\n<p>\n\tВторой нюанс: есть инпуты, у которых нет\n\tатрибута <code class=\"code inline\">name</code>. Например, кнопка отправки\n\tформы. В этом случае с такими инпутами ничего\n\tи не надо делать. Учтем это дополнительным\n\tусловием:\n</p>\n<div class=\"block\" data-file=\"Input.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Input extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent:__construct('input');\n\t\t}\n\t\t\n\t\tpublic function open()\n\t\t{\n\t\t\t$inputName = $this-&gt;getAttr('name');\n\t\t\t\n\t\t\t// Если атрибут name задан у инпута:\n\t\t\tif ($inputName) {\n\t\t\t\tif (isset($_REQUEST[$inputName])) {\n\t\t\t\t\t$value = $_REQUEST[$inputName];\n\t\t\t\t\t$this-&gt;setAttr('value', $value);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn parent::open();\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn $this-&gt;open();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tНу вот теперь можно пробовать. Можете запустить\n\tприведенный ниже код формы, вбить что-то\n\tв инпут и нажать на кнопку отправки - после\n\tобновления страницы данные из инпута не исчезнут:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs(['action' =&gt; '', 'method' =&gt; 'GET']);\n\t\n\techo $form-&gt;open();\n\t\techo (new Input)-&gt;setAttr('name', 'year');\n\t\techo (new Input)-&gt;setAttr('type', 'submit');\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<p>\n\tА вот пример, когда в инпуте уже есть какое-то\n\tзначение по умолчанию:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs(['action' =&gt; '', 'method' =&gt; 'GET']);\n\t\n\techo $form-&gt;open();\n\t\techo (new Input)-&gt;setAttr('name', 'year')-&gt;setAttr('value', date('Y'));\n\t\techo (new Input)-&gt;setAttr('type', 'submit');\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте самостоятельно сохранение значений\n\t\tинпутов после отправки. Проверьте работу\n\t\tданного механизма.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tС помощью созданного класса сделайте форму\n\t\tс <code class=\"number inline\">5</code>-ю инпутами. Пусть в каждый инпут\n\t\tможно ввести число. Сделайте так, чтобы после\n\t\tотправки на экран выводилась сумма этих чисел,\n\t\tа введенные значения не пропадали из инпутов.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Form/Submit/","content":"\n\t\t\t\t<h1>Класс Submit</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте упростим код для создания кнопки\n\tотправки формы.\n</p>\n<p>\n\tВместо такого кода:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Input)-&gt;setAttr('type', 'submit');\n?&gt;</code>\n</div>\n<p>\n\tМы будем писать вот такой:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo new Submit;\n?&gt;</code>\n</div>\n<p>\n\tДля этого сделаем класс <code class=\"code inline\">Submit</code>, который\n\tбудет наследовать от класса <code class=\"code inline\">Input</code>,\n\tпереопределяя его конструктор и задавая в\n\tнем атрибут <code class=\"code inline\">type</code> в значении <code class=\"code inline\">submit</code>:\n</p>\n<div class=\"block\" data-file=\"Submit.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Submit extends Input\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;setAttr('type', 'submit');\n\t\t\tparent::__construct();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу нового класса:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs(['action' =&gt; 'test.php', 'method' =&gt; 'GET']);\n\t\n\techo $form-&gt;open();\n\t\techo (new Input)-&gt;setAttr('name', 'year');\n\t\techo new Submit;\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно реализуйте описанный класс\n\t\t<code class=\"code inline\">Submit</code>, проверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Form/Password/","content":"\n\t\t\t\t<h1>Класс Password</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ данном уроке мы с вами сделаем класс <code class=\"code inline\">Password</code>,\n\tсоздающий инпут с типом <code class=\"code inline\">password</code>.\n\tДавайте посмотрим, как мы будем пользоваться\n\tописанным классом:\n</p>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo new Password;\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующий код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;input type=\"password\"&gt;</code>\n</div>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Password)-&gt;setAttr('name', 'passw');\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующий код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;input type=\"password\" name=\"passw\"&gt;</code>\n</div>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<p>\n\tА вот так мы будем пользоваться нашим классом\n\tв составе формы:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs([\n\t\t'action' =&gt; 'test.php',\n\t\t'method' =&gt; 'GET'\n\t]);\n\t\n\techo $form-&gt;open();\n\t\techo (new Input)   -&gt;setAttr('name', 'login');\n\t\techo (new Password)-&gt;setAttr('name', 'passw');\n\t\techo new Submit;\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующая форма:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;form action=\"\" method=\"GET\"&gt;\n\t&lt;input name=\"login\"&gt;\n\t&lt;input type=\"password\" name=\"passw\"&gt;\n\t&lt;input type=\"submit\"&gt;\n&lt;/form&gt;</code>\n</div>\n\n<h2>Практические задачи</h2>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс, проверьте его\n\t\tработу в составе формы.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Form/Hidden/","content":"\n\t\t\t\t<h1>Класс Hidden</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ данном уроке мы с вами сделаем класс <code class=\"code inline\">Hidden</code>,\n\tсоздающий инпут с типом <code class=\"code inline\">hidden</code>. Давайте\n\tпосмотрим, как мы будем пользоваться описанным\n\tклассом:\n</p>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo new Hidden;\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующий код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;input type=\"hidden\"&gt;</code>\n</div>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Hidden)-&gt;setAttr('name', 'id');\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующий код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;input type=\"hidden\" name=\"id\"&gt;</code>\n</div>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<p>\n\tА вот так мы будем пользоваться нашим классом\n\tв составе формы:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs([\n\t\t'action' =&gt; 'test.php',\n\t\t'method' =&gt; 'GET'\n\t]);\n\t\n\techo $form-&gt;open();\n\t\techo (new Hidden)-&gt;setAttr('name', 'id')-&gt;setAttr('value', '123');\n\t\techo (new Input)-&gt;setAttr('name', 'year');\n\t\techo new Submit;\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующая форма:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;form action=\"\" method=\"GET\"&gt;\n\t&lt;input type=\"hidden\" name=\"id\" value=\"123\"&gt;\n\t&lt;input name=\"year\"&gt;\n\t&lt;input type=\"submit\"&gt;\n&lt;/form&gt;</code>\n</div>\n\n<h2>Практические задачи</h2>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс, проверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Form/Textarea/","content":"\n\t\t\t\t<h1>Класс Textarea</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ данном уроке мы с вами реализуем класс\n\t<code class=\"code inline\">Textarea</code>, который будет создавать\n\tтег <a href=\"/ru/markup/manual/html/tag/textarea/\"><code class=\"code inline\">textarea</code></a>\n\tи сохранять его значение после отправки формы.\n\tДавайте посмотрим, как мы будем пользоваться\n\tописанным классом:\n</p>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Textarea)-&gt;show();\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующий код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;textarea&gt;&lt;/textarea&gt;</code>\n</div>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Textarea)-&gt;setAttr('name', 'text')-&gt;show();\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующий код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;textarea name=\"text\"&gt;&lt;/textarea&gt;</code>\n</div>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Textarea)\n\t\t-&gt;setAttr('name', 'text')\n\t\t-&gt;setText('my mess')\n\t\t-&gt;show();\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующий код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;textarea name=\"text\"&gt;my mess&lt;/textarea&gt;</code>\n</div>\n\n<h2>Пример <span class=\"-page-\"></span></h2>\n<p>\n\tА вот так мы будем пользоваться нашим классом\n\tв составе формы:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs(['action' =&gt; 'test.php', 'method' =&gt; 'GET']);\n\t\n\techo $form-&gt;open();\n\t\techo (new Input)-&gt;setAttr('name', 'user');\n\t\techo (new Textarea)-&gt;setAttr('name', 'message')-&gt;show();\n\t\techo new Submit;\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующая форма:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;form action=\"\" method=\"GET\"&gt;\n\t&lt;input name=\"user\"&gt;\n\t&lt;textarea name=\"message\"&gt;&lt;/textarea&gt;\n\t&lt;input type=\"submit\"&gt;\n&lt;/form&gt;</code>\n</div>\n\n<h2>Практические задачи</h2>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">Textarea</code>\n\t\tпока без сохранения значение тега после отправки\n\t\tформы.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tА теперь реализуйте сохранение значение тега\n\t\tпосле отправки формы.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Form/Checkbox/","content":"\n\t\t\t\t<h1>Класс Checkbox</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте теперь реализуем класс для создания\n\t<a href=\"/ru/markup/manual/html/tag/input/checkbox/\">чекбокса</a>:\n</p>\n<div class=\"block\" data-file=\"Checkbox.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Checkbox extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;setAttr('type', 'checkbox');\n\t\t\t$this-&gt;setAttr('value', '1');\n\t\t\tparent::__construct('input');\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn parent::open();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСделаем теперь так, чтобы при создании чекбокса\n\tв пару к нему с помощью класса <code class=\"code inline\">Hidden</code>\n\tсоздавался скрытый инпут с таким же именем:\n</p>\n<div class=\"block\" data-file=\"Checkbox.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Checkbox extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;setAttr('type', 'checkbox');\n\t\t\t$this-&gt;setAttr('value', '1');\n\t\t\tparent::__construct('input');\n\t\t}\n\t\t\n\t\tpublic function open()\n\t\t{\n\t\t\t$name = $this-&gt;getAttr('name');\n\t\t\t\n\t\t\tif ($name) {\n\t\t\t\t$hidden = (new Hidden)\n\t\t\t\t\t-&gt;setAttr('name', $name)\n\t\t\t\t\t-&gt;setAttr('value', '0');\n\t\t\t\t\n\t\t\t\treturn $hidden-&gt;open() . parent::open();\n\t\t\t} else {\n\t\t\t\treturn parent::open();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn $this-&gt;open();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tРеализуем теперь сохранение состояния чекбокса\n\tпосле отправки формы:\n</p>\n<div class=\"block\" data-file=\"Checkbox.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Checkbox extends Tag\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;setAttr('type', 'checkbox');\n\t\t\t$this-&gt;setAttr('value', '1');\n\t\t\tparent::__construct('input');\n\t\t}\n\t\t\n\t\tpublic function open()\n\t\t{\n\t\t\t$name = $this-&gt;getAttr('name');\n\t\t\t\n\t\t\tif ($name) {\n\t\t\t\t$hidden = (new Hidden)\n\t\t\t\t\t-&gt;setAttr('name', $name)\n\t\t\t\t\t-&gt;setAttr('value', '0');\n\t\t\t\t\n\t\t\t\tif (isset($_REQUEST[$name])) {\n\t\t\t\t\t$value = $_REQUEST[$name];\n\t\t\t\t\t\n\t\t\t\t\tif ($value == 1) {\n\t\t\t\t\t\t$this-&gt;setAttr('checked');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this-&gt;removeAttr('checked');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn $hidden-&gt;open() . parent::open();\n\t\t\t} else {\n\t\t\t\treturn parent::open();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function __toString()\n\t\t{\n\t\t\treturn $this-&gt;open();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПроверим работу созданного класса на какой-нибудь\n\tформе:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$form = (new Form)-&gt;setAttrs([\n\t\t'action' =&gt; '',\n\t\t'method' =&gt; 'GET'\n\t]);\n\t\n\techo $form-&gt;open();\n\t\techo (new Checkbox)-&gt;setAttr('name', 'checkbox');\n\t\techo (new Input)-&gt;setAttr('name', 'user');\n\t\techo new Submit;\n\techo $form-&gt;close();\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tИзучите и разберите приведенный мною код.\n\t\tЗатем не подсматривая в учебник сделайте\n\t\tтакой же класс для создания чекбокса.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте класс <code class=\"code inline\">Radio</code> для создания\n\t\t<a href=\"/ru/markup/manual/html/tag/input/radio/\">радио\n\t\tпереключателя</a>. Проверьте работу этого класса.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Form/Select/","content":"\n\t\t\t\t<h1>Класс Select</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ данном уроке мы с вами сделаем класс <code class=\"code inline\">Select</code>,\n\tкоторый будет создавать выпадающий список\n\t<a href=\"/ru/markup/manual/html/tag/select/\"><code class=\"code inline\">select</code></a>.\n\tДавайте посмотрим, как мы будем пользоваться\n\tописанным классом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Select-&gt;setAttr('name', 'list'))\n\t\t-&gt;add( (new Option())-&gt;setText('item1') )\n\t\t-&gt;add( (new Option())-&gt;setText('item2') )\n\t\t-&gt;add( (new Option())-&gt;setText('item3') )\n\t\t-&gt;show();\n?&gt;</code>\n</div>\n<p>\n\tРезультат выполнения кода выведет следующее\n\t(форматирование мое):\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;select name=\"list\"&gt;\n\t&lt;option&gt;item1&lt;/option&gt;\n\t&lt;option&gt;item2&lt;/option&gt;\n\t&lt;option&gt;item3&lt;/option&gt;\n&lt;/select&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанные классы <code class=\"code inline\">Select</code>\n\t\tи <code class=\"code inline\">Option</code>.\n\t</p>\n</div>\n\n<h2>Атрибут selected</h2>\n<p>\n\tСделаем так, чтобы можно было задать отмеченный\n\tпо умолчанию пункт списка:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\techo (new Select)\n\t\t-&gt;add( (new Option())-&gt;setText('item1') )\n\t\t-&gt;add( (new Option())-&gt;setText('item2')-&gt;setSelected() )\n\t\t-&gt;add( (new Option())-&gt;setText('item3') )\n\t\t-&gt;show();\n?&gt;</code>\n</div>\n<p>\n\tРезультат выполнения кода выведет следующее\n\t(форматирование мое):\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;select&gt;\n\t&lt;option&gt;item1&lt;/option&gt;\n\t&lt;option selected&gt;item2&lt;/option&gt;\n\t&lt;option&gt;item3&lt;/option&gt;\n&lt;/select&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tМодифицируйте ваш код в соответствии с описанным.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте так, чтобы после отправки формы\n\t\tсписок сохранял свое выбранное значение.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/TagHelper/","content":"\n\t\t\t\t<h1>Класс TagHelper</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ предыдущих уроках мы с вами делали классы,\n\tкаждый из которых был предназначен для создания\n\tмножества объектов. Давайте теперь потренируемся\n\tделать классы, представляющие собой набор\n\tметодов для решения некоторой задачи.\n</p>\n<p>\n\tСделаем, к примеру, класс <code class=\"code inline\">TagHelper</code>,\n\tс помощью которого можно будет создавать\n\tHTML теги:\n</p>\n<div class=\"block\" data-file=\"TagHelper.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass TagHelper\n\t{\n\t\tpublic function open($name, $attrs = [])\n\t\t{\n\t\t\t$attrsStr = $this-&gt;getAttrsStr($attrs);\n\t\t\treturn \"&lt;$name$attrsStr&gt;\";\n\t\t}\n\t\t\n\t\tpublic function close($name)\n\t\t{\n\t\t\treturn \"&lt;/$name&gt;\";\n\t\t}\n\t\t\n\t\t// Формируем строку с атрибутами:\n\t\tprivate function getAttrsStr($attrs)\n\t\t{\n\t\t\tif (!empty($attrs)) {\n\t\t\t\t$result = '';\n\t\t\t\t\n\t\t\t\tforeach ($attrs as $name =&gt; $value) {\n\t\t\t\t\tif ($value === true) {\n\t\t\t\t\t\t$result .= \" $name\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$result .= \" $name=\\\"$value\\\"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn $result;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВоспользуемся нашим классом, к примеру, для\n\tтого, чтобы сделать тег div с текстом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$th = new TagHelper();\n\techo $th-&gt;open('div') . 'text' . $th-&gt;close('div'); // &lt;div&gt;text&lt;/div&gt;\n?&gt;</code>\n</div>\n<p>\n\tА теперь используем наш класс для создания формы:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$th = new TagHelper();\n\t\n\techo $th-&gt;open('form', ['action' =&gt; 'test.php', 'method' =&gt; 'GET']);\n\t\techo $th-&gt;open('input', ['name' =&gt; 'year']);\n\t\techo $th-&gt;open('input', ['type' =&gt; 'submit']);\n\techo $th-&gt;close('form');\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующий HTML код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;form action=\"test.php\" method=\"GET\"&gt;\n\t&lt;input name=\"year\"&gt;\n\t&lt;input type=\"submit\"&gt;\n&lt;/form&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно, не подсматривая в мой код,\n\t\tреализуйте описанный класс <code class=\"code inline\">Tag</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в класс <code class=\"code inline\">Tag</code> метод <code class=\"code inline\">show</code>,\n\t\tодновременно создающий открывающий и закрывающий\n\t\tтеги, а также текст между ними. Метод должен\n\t\tпринимать параметром имя тега и текст.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/FormHelper/","content":"\n\t\t\t\t<h1>Класс FormHelper</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте теперь реализуем класс <code class=\"code inline\">FormHelper</code>,\n\tс помощью которого можно будет создавать\n\tформы. При этом унаследуем этот класс от\n\tкласса <code class=\"code inline\">TagHelper</code>, созданного нами\n\tв предыдущем уроке. Вот моя реализация описанного\n\tкласса:\n</p>\n<div class=\"block\" data-file=\"FormHelper.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass FormHelper extends TagHelper\n\t{\n\t\tpublic function openForm($attrs = [])\n\t\t{\n\t\t\treturn $this-&gt;open('form', $attrs);\n\t\t}\n\t\t\n\t\tpublic function closeForm()\n\t\t{\n\t\t\treturn $this-&gt;close('form');\n\t\t}\n\t\t\n\t\tpublic function input($attrs = [])\n\t\t{\n\t\t\tif (isset($attrs['name'])) {\n\t\t\t\t$name = $attrs['name'];\n\t\t\t\t\n\t\t\t\tif (isset($_REQUEST[$name])) {\n\t\t\t\t\t$attrs['value'] = $_REQUEST[$name];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn $this-&gt;open('input', $attrs);\n\t\t}\n\t\t\n\t\tpublic function password($attrs = [])\n\t\t{\n\t\t\t$attrs['type'] = 'password';\n\t\t\treturn $this-&gt;input($attrs);\n\t\t}\n\t\t\n\t\tpublic function hidden($attrs = [])\n\t\t{\n\t\t\t$attrs['type'] = 'hidden';\n\t\t\treturn $this-&gt;open('input', $attrs);\n\t\t}\n\t\t\n\t\tpublic function submit($attrs = [])\n\t\t{\n\t\t\t$attrs['type'] = 'submit';\n\t\t\treturn $this-&gt;open('input', $attrs);\n\t\t}\n\t\t\n\t\tpublic function checkbox($attrs = [])\n\t\t{\n\t\t\t$attrs['type'] = 'checkbox';\n\t\t\t$attrs['value'] = 1;\n\t\t\t\n\t\t\tif (isset($attrs['name'])) {\n\t\t\t\t$name = $attrs['name'];\n\t\t\t\t\n\t\t\t\tif (isset($_REQUEST[$name]) and $_REQUEST[$name] == 1) {\n\t\t\t\t\t$attrs['checked'] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$hidden = $this-&gt;hidden(['name' =&gt; $name, 'value' =&gt; '0']);\n\t\t\t} else {\n\t\t\t\t$hidden = '';\n\t\t\t}\n\t\t\t\n\t\t\treturn $hidden . $this-&gt;open('input', $attrs);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте применим наш класс для создания формы:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$fh = new FormHelper();\n\t\n\techo $fh-&gt;openForm(['action' =&gt; '', 'method' =&gt; 'GET']);\n\t\techo $fh-&gt;input(['name' =&gt; 'year']);\n\t\techo $fh-&gt;checkbox(['name' =&gt; 'check']);\n\t\techo $fh-&gt;submit();\n\techo $fh-&gt;closeForm();\n?&gt;</code>\n</div>\n<p>\n\tВ результате получится следующий HTML код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;form action=\"\" method=\"GET\"&gt;\n\t&lt;input name=\"year\"&gt;\n\t&lt;input type=\"hidden\" name=\"check\" value=\"0\"&gt;\n\t&lt;input type=\"checkbox\" name=\"check\" value=\"1\"&gt;\n\t&lt;input type=\"submit\"&gt;\n&lt;/form&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tИзучите и разберите мой код описанного класса.\n\t\tСоздайте с его помощью какую-нибудь HTML\n\t\tформу, применив как можно больше методов\n\t\tэтого класса.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСамостоятельно, не подсматривая в мой код,\n\t\tреализуйте описанный класс.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в вашу реализацию метод для создания\n\t\tтега <code class=\"code inline\">textarea</code>. Пусть этот тег сохраняет\n\t\tсвое значение после отправки формы.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте в вашу реализацию метод для создания\n\t\tвыпадающего списка. Пусть метод первым параметром\n\t\tпринимает массив атрибутов тега <code class=\"code inline\">select</code>,\n\t\tа вторым - массив для создания тегов <code class=\"code inline\">option</code>.\n\t\tПусть этот массив содержит ключ <code class=\"string inline\">'text'</code>\n\t\tдля текста пункта списка и ключ <code class=\"string inline\">'attrs'</code>\n\t\tдля массива атрибутов пункта списка. Вот\n\t\tпример использования описанного метода:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$fh = new FormHelper();\n\t\n\techo $fh-&gt;select(\n\t\t['name' =&gt; 'list', 'class' =&gt; 'eee'],\n\t\t[\n\t\t\t['text' =&gt; 'item1', 'attrs' =&gt; ['value' =&gt; '1']],\n\t\t\t['text' =&gt; 'item2', 'attrs' =&gt; ['value' =&gt; '1', 'selected' =&gt; true]],\n\t\t\t['text' =&gt; 'item1', 'attrs' =&gt; ['value' =&gt; '1', 'class' =&gt; 'last']],\n\t\t],\n\t\t\n\t);\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tВ результате должен получится следующий HTML код:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;select name=\"list\" class=\"eee\"&gt;\n\t&lt;option value=\"1\"&gt;item1&lt;/option&gt;\n\t&lt;option value=\"2\" selected&gt;item2&lt;/option&gt;\n\t&lt;option value=\"3\" class=\"last\"&gt;item3&lt;/option&gt;\n&lt;/form&gt;</code>\n\t</div>\n\t<p>\n\t\tСделайте так, чтобы выпадающий список сохранял\n\t\tсвое значение после отправки формы.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/CookieShell/","content":"\n\t\t\t\t<h1>Класс CookieShell</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами реализуем класс-оболочку\n\tдля работы с куки. Как вы должны уже знать,\n\tработа с куками в PHP реализована не очень\n\tоднородным образом: чтобы установить куку\n\tмы используем одну функцию, а чтобы прочитать\n\t- другую.\n</p>\n<p>\n\tДавайте сделаем свой набор методов для работы\n\tс куками, оформив этот набор в виде следующего\n\tкласса:\n</p>\n<div class=\"block\" data-file=\"CookieShell.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass CookieShell\n\t{\n\t\tpublic function set($name, $value, $time)\n\t\t{\n\t\t\t// устанавливает куки\n\t\t\t// $time задает время в сек, через сколько кука умрет\n\t\t}\n\t\t\n\t\tpublic function get($name)\n\t\t{\n\t\t\t// получает куки\n\t\t}\n\t\t\n\t\tpublic function del($name)\n\t\t{\n\t\t\t// удаляет куки\n\t\t}\n\t\t\n\t\tpublic function exists($name)\n\t\t{\n\t\t\t// проверяет наличие куки\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте посмотрим примеры того, как должен\n\tработать наш класс:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$csh = new CookieShell;\n\t$csh-&gt;set('test', '123', 3600 * 24);\n\t\n\techo $csh-&gt;get('test'); // выведет 123\n?&gt;</code>\n</div>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$csh = new CookieShell;\n\t$csh-&gt;set('test', '123', 3600 * 24);\n\t\n\t$csh-&gt;del('test');\n\techo $csh-&gt;get('test'); // выведет null\n?&gt;</code>\n</div>\n\n<h2>Некоторые советы</h2>\n<p>\n\tРабота с куками на чистом PHP кошмарна. Если\n\tвы установите куку и попытаетесь ее сразу\n\tпрочитать через <code class=\"code inline\">$_COOKIE</code>, то ничего\n\tне получится:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tsetcookie('name', 'value', time() + 3600);\n\tvar_dump($_COOKIE['name']); // выведет null\n?&gt;</code>\n</div>\n<p>\n\tДело в том, что установленная кука будет\n\tдоступна только после обновления страницы!\n\tНо чаще всего она нам нужна сразу, после\n\tустановки.\n</p>\n<p>\n\tЧто ж, используем хитрый прием:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tsetcookie('name', 'value', time() + 3600);\n\t$_COOKIE['name'] = 'value'; // принудительно запишем в массив\n\t\n\tvar_dump($_COOKIE['name']); // выведет 'value'\n?&gt;</code>\n</div>\n<p>\n\tАналогичным образом я рекомендую поступать\n\tи при удалении куки.\n</p>\n\n<h2>Пратические задачи</h2>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">CookieShell</code>.\n\t\tПроверьте его работу.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tС помощью созданного вами класса реализуйте\n\t\tсчетчик обновления страницы, работающий на куках.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/SessionShell/","content":"\n\t\t\t\t<h1>Класс SessionShell</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tРабота с сессиями в PHP реализована гораздо\n\tлучше работы с куками. Тем не менее, очень\n\tчасто делают оболочку и над сессиями.\n</p>\n<p>\n\tДавайте реализуем такую оболочку и для единообразия\n\tнабор методов этой оболочки по возможности\n\tсделаем таким же, как и набор методов оболочки\n\tдля работы с куками.\n</p>\n<p>\n\tВот заготовка такого класса:\n</p>\n<div class=\"block\" data-file=\"SessionShell.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass SessionShell\n\t{\n\t\t// Удобно стартуем сессию в конструкторе класса:\n\t\tpublic function __construct()\n\t\t{\n\t\t\tif (!isset($_SESSION)) {\n\t\t\t\tsession_start();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic function set($name, $value)\n\t\t{\n\t\t\t// устанавливает переменную сессии\n\t\t}\n\t\t\n\t\tpublic function get($name)\n\t\t{\n\t\t\t// получает переменную сессии\n\t\t}\n\t\t\n\t\tpublic function del($name)\n\t\t{\n\t\t\t// удаляет переменную сессии\n\t\t}\n\t\t\n\t\tpublic function exists($name)\n\t\t{\n\t\t\t// проверяет переменную сессии\n\t\t}\n\t\t\n\t\tpublic function destroy()\n\t\t{\n\t\t\t// разрушает сессию\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">SessionShell</code>.\n\t\tПроверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/FileManipulator/","content":"\n\t\t\t\t<h1>Класс FileManipulator</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте теперь создадим класс для работы\n\tс файлами:\n</p>\n<div class=\"block\" data-file=\"FileManipulator.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass FileManipulator\n\t{\n\t\tpublic function create($filePath)\n\t\t{\n\t\t\t// создает файл\n\t\t}\n\t\t\n\t\tpublic function delete($filePath)\n\t\t{\n\t\t\t// удаляет файл\n\t\t}\n\t\t\n\t\tpublic function copy($filePath, $copyPath)\n\t\t{\n\t\t\t// копирует файл\n\t\t}\n\t\t\n\t\tpublic function rename($filePath, $newName)\n\t\t{\n\t\t\t// переименовывает файл\n\t\t\t// вторым параметром принимает новое имя файла (только имя, не путь)\n\t\t}\n\t\t\n\t\tpublic function replace($filePath, $newPath)\n\t\t{\n\t\t\t// перемещает файл\n\t\t}\n\t\t\n\t\tpublic function weigh($filePath)\n\t\t{\n\t\t\t// узнает размер файла\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">FileManipulator</code>.\n\t\tПроверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/Validator/","content":"\n\t\t\t\t<h1>Класс Validator</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте реализуем класс для валидации строк:\n</p>\n<div class=\"block\" data-file=\"Validator.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass Validator\n\t{\n\t\tpublic function isEmail($str)\n\t\t{\n\t\t\t// проверяет строку на то, что она корректный email\n\t\t}\n\t\t\n\t\tpublic function isDomain($str)\n\t\t{\n\t\t\t// проверяет строку на то, что она корректное имя домена\n\t\t}\n\t\t\n\t\tpublic function inRange($num, $from, $to)\n\t\t{\n\t\t\t// проверяет число на то, что оно входит в диапазон\n\t\t}\n\t\t\n\t\tpublic function inLength($str, $from, $to)\n\t\t{\n\t\t\t// проверяет строку на то, что ее длина входит в диапазон\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">Validator</code>.\n\t\tПроверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/class/DatabaseShell/","content":"\n\t\t\t\t<h1>Класс DatabaseShell</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tРеализуем оболочку для работы с базой данных.\n\tТакая оболочка позволит нам не писать сырые\n\tSQL запросы, а делать их средствами PHP.\n\tЗачастую это занимает гораздо меньше кода\n\tи проще в обслуживании.\n</p>\n<p>\n\tЗдесь следует сказать, что подобные оболочки\n\tдля работы с базой зачастую занимают более\n\t<code class=\"number inline\">1000</code> строк. Мы не будем делать такого\n\tмонстра, а просто реализуем некоторый упрощенный\n\tвариант, чтобы вы поняли принцип. Например,\n\tвот такой:\n</p>\n<div class=\"block\" data-file=\"DatabaseShell.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tclass DatabaseShell\n\t{\n\t\tprivate $link;\n\t\t\n\t\tpublic function __construct($host, $user, $password, $database)\n\t\t{\n\t\t\t$this-&gt;link = mysqli_connect($host, $user, $password, $database);\n\t\t\tmysqli_query($this-&gt;link, \"SET NAMES 'utf8'\");\n\t\t}\n\t\t\n\t\tpublic function save($table, $data)\n\t\t{\n\t\t\t// сохраняет запись в базу\n\t\t}\n\t\t\n\t\tpublic function del($table, $id)\n\t\t{\n\t\t\t// удаляет запись по ее id\n\t\t}\n\t\t\n\t\tpublic function delAll($table, $ids)\n\t\t{\n\t\t\t// удаляет записи по их id\n\t\t}\n\t\t\n\t\tpublic function get($table, $id)\n\t\t{\n\t\t\t// получает одну запись по ее id\n\t\t}\n\t\t\n\t\tpublic function getAll($table, $ids)\n\t\t{\n\t\t\t// получает массив записей по их id\n\t\t}\n\t\t\n\t\tpublic function selectAll($table, $condition)\n\t\t{\n\t\t\t// получает массив записей по условию\n\t\t}\n\t}\n\t\n\t\n?&gt;</code>\n</div>\n<p>\n\tДавайте посмотрим, как мы будем пользоваться\n\tнашим классом. Создаем объект для работы:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$db = new DatabaseShell('localhost', 'root', 'root', '', 'test');\n?&gt;</code>\n</div>\n<p>\n\tСохраним нового юзера:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$db-&gt;save('users', ['name' =&gt; 'user1', 'age' =&gt; '23']);\n?&gt;</code>\n</div>\n<p>\n\tУдалим юзера с id равным <code class=\"number inline\">3</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$db-&gt;del('users', 3);\n?&gt;</code>\n</div>\n<p>\n\tУдалим юзеров с заданными id:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$db-&gt;delAll('users', [1, 2, 3, 5]);\n?&gt;</code>\n</div>\n<p>\n\tПолучим юзера с id равным <code class=\"number inline\">3</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$user = $db-&gt;get('users', 3);\n?&gt;</code>\n</div>\n<p>\n\tПолучим юзеров с заданными id:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$users = $db-&gt;getAll('users', [1, 2, 3, 5]);\n?&gt;</code>\n</div>\n<p>\n\tПолучим юзеров по условию:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$users = $db-&gt;getAll('users', 'where id &gt;= 3');\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">DatabaseShell</code>.\n\t\tПроверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/namespaces/intro/","content":"\n\t\t\t\t<h1>Введение в пространства имен в ООП на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tЕсли при запуске PHP скрипта будут два класса\n\tс одинаковыми именами, то они вступят в конфликт,\n\tчто приведет к фатальной ошибке. Это на самом\n\tделе не очень удобно, так как постоянно приходится\n\tследить за уникальностью имен.\n</p>\n<p>\n\tДля примера рассмотрим следующую ситуацию:\n\tу вас есть сайт, на котором есть пользователи\n\tи админ. При этом в папке <code class=\"path inline\">users</code> хранятся\n\tклассы для юзеров, а в папке <code class=\"path inline\">admin</code>\n\t- классы для админа.\n</p>\n<p>\n\tПусть и для юзеров, и для админа нужен некий\n\tкласс <code class=\"code inline\">Page</code>, отвечающий за какие-то\n\tстраницы сайта. При этом для юзеров будет\n\tсвой класс, а для админа - свой. В таком\n\tслучае нас и поджидает конфликт имен.\n</p>\n<p>\n\tСамый простой способ решения этого конфликта\n\t- дать отличающиеся имена классам, например,\n\t<code class=\"code inline\">UsersPage</code> и <code class=\"code inline\">AdminPage</code>. Этот\n\tпуть, однако, постепенно ведет к появлению\n\tочень длинных имен классов.\n</p>\n<p>\n\tВ PHP существует и другой путь решения проблемы\n\t- пространства имен. Суть в следующем: каждый\n\tкласс может относится к какому-то пространству\n\tимен и при этом уникальность имен классов\n\tдолжна соблюдаться только внутри этого пространства.\n</p>\n<p>\n\tТо есть, для решения нашей проблемы мы можем\n\tсделать следующее: отнести один класс <code class=\"code inline\">Page</code>\n\tк какому-нибудь пространству имен, например,\n\t<code class=\"code inline\">Users</code>, а второй класс <code class=\"code inline\">Page</code>\n\tотнести к другому пространству имен, например,\n\t<code class=\"code inline\">Admin</code>.\n</p>\n\n<h2>Синтаксис пространств имен</h2>\n<p>\n\tЧтобы задать классу пространство имен, нужно\n\tпервой строчкой файла, в котом хранится этот\n\tкласс написать команду <code class=\"code inline\">namespace</code>,\n\tа после нее через пробел - название этого\n\tпространства.\n</p>\n<p>\n\tЕсли класс относится к какому-нибудь пространству\n\tимен, то для создания объекта класса нужно\n\tбудет указать не только имя класса, но и\n\tего пространство имен, разделенные обратным\n\tслешем. Давайте посмотрим на примере.\n</p>\n<p>\n\tПусть у нас есть класс <code class=\"code inline\">Page</code>, не относящийся\n\tни к какому пространству имен. Тогда объект\n\tэтого класса мы создадим следующим образом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$page = new Page;\n?&gt;</code>\n</div>\n<p>\n\tПусть теперь этот класс принадлежит пространству\n\tимен <code class=\"code inline\">Admin</code>. В этом случае объект этого\n\tкласса мы будем создавать уже вот таким образом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$page = new \\Admin\\Page;\n?&gt;</code>\n</div>\n\n<h2>Посмотрим на примере</h2>\n<p>\n\tДавайте разнесем классы для юзеров и классы\n\tдля админа по разным пространствам имен,\n\tчтобы избежать описанных выше конфликтов классов.\n</p>\n<p>\n\tДля класса <code class=\"code inline\">Page</code> из файла <code class=\"path inline\">/admin/page.php</code>\n\tукажем пространство имен <code class=\"code inline\">Admin</code>:\n</p>\n<div class=\"block\" data-file=\"/admin/page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin;\n\t\n\tclass Page\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tА для класса Page из файла <code class=\"path inline\">/users/page.php</code>\n\tукажем пространство имен <code class=\"code inline\">Users</code>:\n</p>\n<div class=\"block\" data-file=\"/users/page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Users;\n\t\n\tclass Page\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь в файле <code class=\"path inline\">/index.php</code>\n\tсоздадим объект одного и второго класса <code class=\"code inline\">Page</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\trequire_once '/admin/page.php';\n\trequire_once '/users/page.php';\n\t\n\t$adminPage = new \\Admin\\Page;\n\t$usersPage = new \\Users\\Page;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас есть папка <code class=\"path inline\">core</code> и папка\n\t\t<code class=\"path inline\">project</code>. В каждой из папок есть свой\n\t\tкласс <code class=\"code inline\">Controller</code>. Сделайте так, чтобы\n\t\tэти классы принадлежали разным пространствам\n\t\tимен. В файле <code class=\"path inline\">index.php</code> создайте объекты\n\t\tодного и второго классов.\n\t</p>\n</div>\n\n<h2>Подпространства имен</h2>\n<p>\n\tПусть теперь у нас есть более сложная ситуация:\n\tдля админа нужно сделать два класса <code class=\"code inline\">Page</code>\n\t- один с данными страницы, а второй - с представлением\n\tэтих данных. Пусть первый класс находится\n\tв файле <code class=\"path inline\">/admin/data/page.php</code>, а второй\n\t- в файле <code class=\"path inline\">/admin/view/page.php</code>.\n</p>\n<p>\n\tВыше мы уже решили, что все классы из папки\n\t<code class=\"path inline\">admin</code> будут относится к пространству\n\tимен <code class=\"code inline\">Admin</code>. Однако, теперь в этом\n\tсамом пространстве у нас конфликт двух классов.\n\tДля решения проблемы можно сделать дополнительные\n\tподпространства имен. Например, можно сделать\n\tпространство имен <code class=\"code inline\">Admin</code>, а в нем подпространства\n\t<code class=\"code inline\">Data</code> и <code class=\"code inline\">View</code>. В таком случае\n\tимена этих подпространств просто записываются\n\tчерез обратный слеш - как при задании пространства\n\tимен, так и при создании объекта класса.\n</p>\n<p>\n\tЗдесь следует уточнить, что уровень вложенности\n\tподпространств не ограничен (можно создавать\n\tпод под пространства в подпространствах и\n\tтак далее).\n</p>\n<p>\n\tИтак, давайте доделаем наш описанный выше\n\tпример. Для класса <code class=\"code inline\">Page</code> из файла <code class=\"path inline\">/admin/data/page.php</code>\n\tукажем пространство имен <code class=\"code inline\">Admin\\Data</code>:\n</p>\n<div class=\"block\" data-file=\"/admin/data/page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin\\Data;\n\t\n\tclass Page\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДля класса <code class=\"code inline\">Page</code> из файла <code class=\"path inline\">/admin/view/page.php</code>\n\tукажем пространство имен <code class=\"code inline\">Admin\\View</code>:\n</p>\n<div class=\"block\" data-file=\"/admin/view/page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin\\View;\n\t\n\tclass Page\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСоздадим объекты наших классов:\n</p>\n<div class=\"block\" data-file=\"/index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\trequire_once '/admin/data/page.php';\n\trequire_once '/admin/view/page.php';\n\t\n\t$adminDataPage = new \\Admin\\Data\\Page;\n\t$adminViewPage = new \\Admin\\View\\Page;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас есть папка <code class=\"path inline\">modules/cart</code>.\n\t\tСделайте так, чтобы все классы из этой папки\n\t\tотносились к пространству имен <code class=\"code inline\">Modules\\Cart</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас есть папка <code class=\"path inline\">modules/shop/cart/</code>.\n\t\tСделайте так, чтобы все классы из этой папки\n\t\tотносились к пространству имен <code class=\"code inline\">Modules\\Shop\\Cart</code>.\n\t</p>\n</div>\n\n<h2>Некоторые замечания</h2>\n<p>\n\tВ примерах выше имена пространств имен совпадают\n\tс именами папок, в которых хранятся файлы.\n\tДелать так - хорошая практика, но обязательным\n\tэто не является.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас есть папка <code class=\"path inline\">modules</code>, а\n\t\tв ней файл <code class=\"path inline\">marketCart.php</code> и файл <code class=\"path inline\">shopCart.php</code>.\n\t\tПусть в обоих файлах размещается класс <code class=\"code inline\">Cart</code>.\n\t\tСделайте так, чтобы класс из первого файла\n\t\tпринадлежал пространству имен <code class=\"code inline\">Market\\Cart</code>,\n\t\tа из второго файла - пространству <code class=\"code inline\">Shop\\Cart</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/namespaces/simplified-class-calling/","content":"\n\t\t\t\t<h1>Упрощенное обращение к пространствам имен</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас есть следующий класс <code class=\"code inline\">Controller</code>:\n</p>\n<div class=\"block\" data-file=\"/admin/controller.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin;\n\t\n\tclass Controller\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть также есть класс <code class=\"code inline\">Page</code>, наследующий\n\tот класса <code class=\"code inline\">Controller</code>:\n</p>\n<div class=\"block\" data-file=\"/admin/page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin;\n\t\n\tclass Page extends \\Admin\\Controller\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, при наследовании мы указываем\n\tимя родителя вместе с пространством имен.\n\tВ данном примере, однако, есть нюанс: оба\n\tкласса принадлежат одному и тому же пространству\n\tимен. В таком случае при обращении к классу\n\tможно просто написать имя этого класса, вот так:\n</p>\n<div class=\"block\" data-file=\"/admin/page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin;\n\t\n\tclass Page extends Controller\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДаны два класса:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Modules\\Shop;\n\t\n\tclass Cart\n\t{\n\t\t\n\t}\n?&gt;</code>\n\t</div>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Modules\\Shop;\n\t\n\tclass UserCart extends \\Modules\\Shop\\Cart\n\t{\n\t\t\n\t}\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tУпростите код для наследования класса, учитывая\n\t\tто, что оба класса находятся в одном пространстве\n\t\tимен.\n\t</p>\n</div>\n\n<h2>Пространства имен в файлах</h2>\n<p>\n\tКоманду <code class=\"code inline\">namespace</code> можно писать не\n\tтолько в файлах с определениями классов,\n\tно и вообще в любых других файлах. Например,\n\tзададим пространство имен в файле <code class=\"path inline\">index.php</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin;\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть в файле <code class=\"path inline\">index.php</code> создается\n\t\tобъект класса <code class=\"code inline\">Controller</code>:\n\t</p>\n\t<div class=\"block\" data-file=\"index.php\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin;\n\t\n\tnew \\Admin\\Controller;\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tУпростите код для создания объекта, учитывая\n\t\tто, что создание объекта класса происходит\n\t\tв том же пространстве имен, которому принадлежит\n\t\tкласс.\n\t</p>\n</div>\n\n<h2>Относительные пути</h2>\n<p>\n\tПусть в файле <code class=\"path inline\">index.php</code> происходит\n\tследующий вызов:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin\\Data;\n\t\n\tnew \\Core\\Controller;\n?&gt;</code>\n</div>\n<p>\n\tКак вы уже знаете, при обращении к классу\n\tперед его пространством имен следует писать\n\tобратный слеш. На самом деле это не обязательно.\n\tЕсли этот слеш не написать, то вызываемое\n\tпространство имен будет рассчитано относительно\n\tтекущего пространства. Смотрите пример:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Admin\\Data;\n\t\n\tnew Core\\Controller; // эквивалентно \\Admin\\Data\\Core\\Controller\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДаны два класса:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Modules\\Shop\\Core;\n\t\n\tclass Cart\n\t{\n\t\t\n\t}\n?&gt;</code>\n\t</div>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Modules\\Shop;\n\t\n\tclass UserCart extends \\Modules\\Shop\\Core\\Cart\n\t{\n\t\t\n\t}\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tУпростите код для наследования класса, учитывая\n\t\tто, что пространства имен наших классов имеют\n\t\tсовпадающую часть.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДаны два класса:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core\\Data;\n\t\n\tclass Controller\n\t{\n\t\t\n\t}\n?&gt;</code>\n\t</div>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core\\Data;\n\t\n\tclass Model\n\t{\n\t\t\n\t}\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tВот так создаются объекты этих классов в\n\t\tфайле <code class=\"path inline\">index.php</code>:\n\t</p>\n\t<div class=\"block\" data-file=\"index.php\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core\\Data;\n\t\n\t$controller = new \\Core\\Data\\Controller;\n\t$model      = new \\Core\\Data\\Model;\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tУпростите код для создания объектов, учитывая\n\t\tпространство имен, в котором создаются объекты\n\t\tнаших классов.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/namespaces/command-use/","content":"\n\t\t\t\t<h1>Команда use и пространства имен</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас есть следующий класс <code class=\"code inline\">Data</code>:\n</p>\n<div class=\"block\" data-file=\"/core/admin/data.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace \\Core\\Admin;\n\t\n\tclass Data\n\t{\n\t\tpublic function __construct($num)\n\t\t{\n\t\t\t\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть также есть класс <code class=\"code inline\">Page</code>, создающий\n\tвнутри себя объекты класса <code class=\"code inline\">Data</code>:\n</p>\n<div class=\"block\" data-file=\"/users/page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Users;\n\t\n\tclass Page\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$data1 = new \\Core\\Admin\\Data('1');\n\t\t\t$data2 = new \\Core\\Admin\\Data('2');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, оба наших класса находятся\n\tв совсем разных пространствах имен, поэтому\n\tвызовы класса <code class=\"code inline\">Data</code> упростить нельзя,\n\tподобно тому, как мы это делали в предыдущем\n\tуроке. Эти вызовы, однако, очень длинные\n\tи неудобные, так как в каждом вызове класса\n\t<code class=\"code inline\">Data</code> приходится указывать его длинное\n\tпространство имен.\n</p>\n<p>\n\tДля решения подобной проблемы существует\n\tспециальная команда <code class=\"code inline\">use</code>. С помощью\n\tэтой команды достаточно один раз подключить\n\tкласс по его полному имени, и после этого\n\tможно будет обращаться к этому классу просто\n\tпо имени класса. Смотрите пример:\n</p>\n<div class=\"block\" data-file=\"/users/page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Users;\n\tuse \\Core\\Admin\\Data; // подключаем класс\n\t\n\tclass Page extends Controller\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$data1 = new Data('1'); // вызываем просто по имени\n\t\t\t$data2 = new Data('2'); // вызываем просто по имени\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tУпростите следующий код с использованием\n\t\t<code class=\"code inline\">use</code>:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project;\n\t\n\tclass Test\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t// Создаем 3 объекта одного класса:\n\t\t\t$data1  = new \\Core\\Users\\Data('user1');\n\t\t\t$data2  = new \\Core\\Users\\Data('user3');\n\t\t\t$data3  = new \\Core\\Users\\Data('user3');\n\t\t}\n\t}\n?&gt;</code>\n\t</div>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДаны следующие классы:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core\\Admin;\n\t\n\tclass Controller\n\t{\n\t\t\n\t}\n?&gt;</code>\n\t</div>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Users;\n\t\n\tclass Page extends \\Core\\Admin\\Controller\n\t{\n\t\t\n\t}\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tУпростите код наследования класса, применив\n\t\tкоманду <code class=\"code inline\">use</code>.\n\t</p>\n</div>\n\n<h2>Подключение нескольких классов</h2>\n<p>\n\tЕсли нужно подключить несколько классов,\n\tто каждый из них подключается своей командой\n\t<code class=\"code inline\">use</code>:\n</p>\n<div class=\"block\" data-file=\"/users/page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Users;\n\tuse \\Core\\Admin\\Data1; // подключаем класс\n\tuse \\Core\\Admin\\Data2; // подключаем класс\n\t\n\tclass Page extends Controller\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$data1 = new Data1; // вызываем просто по имени\n\t\t\t$data2 = new Data2; // вызываем просто по имени\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tУпростите следующий код с использованием\n\t\t<code class=\"code inline\">use</code>:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project;\n\t\n\tclass Test\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$model = new \\Core\\Admin\\Model;\n\t\t\t$data  = new \\Core\\Users\\Storage\\Data;\n\t\t}\n\t}\n?&gt;</code>\n\t</div>\n</div>\n\n<h2>Команда use и относительные пути</h2>\n<p>\n\tПри использовании команды <code class=\"code inline\">use</code> можно\n\tуказывать относительные пути, подобно тому,\n\tкак мы это делали в предыдущем уроке. Давайте\n\tпосмотрим на примере. Пусть мы подключаем\n\tнекоторый класс:\n</p>\n<div class=\"block\" data-file=\"/core/admin/controller.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core\\Admin;\n\tuse \\Core\\Admin\\Path\\Router; // подключаем класс\n\t\n\tclass Controller extends Router\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, начало пространства имен подключаемого\n\tкласса совпадает с текущим пространством.\n\tЭто значит, что мы можем эту часть при подключении\n\tнашего класса, убрав при этом начальный обратный\n\tслеш:\n</p>\n<div class=\"block\" data-file=\"/core/admin/controller.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core\\Admin;\n\tuse Path\\Router; // делаем относительный путь\n\t\n\tclass Controller extends Router\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tУпростите следующий код с использованием\n\t\t<code class=\"code inline\">use</code>:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core\\Storage;\n\t\n\tclass Model\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$database  = new \\Core\\Storage\\DataBase;\n\t\t}\n\t}\n?&gt;</code>\n\t</div>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/namespaces/classes-aliases/","content":"\n\t\t\t\t<h1>Псевдонимы классов для пространств имен</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПусть у нас есть два класса <code class=\"code inline\">Data</code>,\n\tпринадлежащие разным пространствам имен.\n\tПусть в каком-то классе нам нужны объекты\n\tобоих этих классов:\n</p>\n<div class=\"block\" data-file=\"/project/test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project;\n\t\n\tclass Test\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$data1 = new \\Core\\Users\\Data; // создаем объект\n\t\t\t$data2 = new \\Core\\Admin\\Data; // создаем объект\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть мы решили упростить вызовы классов\n\tчерез команду <code class=\"code inline\">use</code>. В этом случае нас\n\tждет проблема: оба класса имеют имя <code class=\"code inline\">Data</code>,\n\tа это значит, что у нас будет конфликт имен:\n</p>\n<div class=\"block\" data-file=\"/project/test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project;\n\t\n\t// Будет конфликт имен:\n\tuse \\Core\\Users\\Data; // подключаем первый класс\n\tuse \\Core\\Admin\\Data; // подключаем второй класс\n\t\n\tclass Test\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$data1 = new Data;\n\t\t\t$data2 = new Data;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДля решения этой проблемы существует специальная\n\tкоманда <code class=\"code inline\">as</code>, позволяющая задать подключаемому\n\tклассу <dfn>псевдоним</dfn> - имя, под которым\n\tэтот класс будет доступен в этом файле. Давайте\n\tвыполним переименование наших классов <code class=\"code inline\">Data</code>:\n</p>\n<div class=\"block\" data-file=\"/project/test.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project;\n\tuse \\Core\\Users\\Data as UsersData;\n\tuse \\Core\\Admin\\Data as AdminData;\n\t\n\tclass Test\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$data1 = new UsersData;\n\t\t\t$data2 = new AdminData;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tУпростите следующий код с использованием\n\t\t<code class=\"code inline\">use</code>:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project;\n\t\n\tclass Test\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$pageController  = new \\Resource\\Controller\\Page;\n\t\t\t$pageModel       = new \\Resource\\Model\\Page;\n\t\t}\n\t}\n?&gt;</code>\n\t</div>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tУпростите следующий код с использованием\n\t\t<code class=\"code inline\">use</code>:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Data;\n\t\n\tclass Test\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$pageController  = new \\Project\\Data\\Controller\\Page;\n\t\t\t$pageModel       = new \\Project\\Data\\Model\\Page;\n\t\t}\n\t}\n?&gt;</code>\n\t</div>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/autoloading/default/","content":"\n\t\t\t\t<h1>Автозагрузка классов</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВы уже знаете, что чтобы воспользоваться\n\tкаким-нибудь классом, мы должны подключить\n\tего через <code class=\"code inline\">require</code>. Когда в проекте\n\tочень много классов, то получается много\n\tподключений, которые очень неудобно писать\n\tи трудно контролировать.\n</p>\n<p>\n\tДля решения такой проблемы в PHP была добавлена\n\t<dfn>автозагрузка</dfn> классов. Автозагрузка\n\tпозволяет PHP автоматически загружать файл\n\tс классом при попытке обращения к этому классу\n\tв коде. Однако, просто так классы загружаться\n\tне будут - их необходимо разместить по папкам\n\tсайта специальным образом, следуя какому-нибудь\n\tсоглашению об именах файлов и папок классов.\n\tМожно пользоваться встроенным в PHP соглашением,\n\tлибо придумать свое и пользоваться им.\n</p>\n<p>\n\tДавайте для начала разберем стандартное соглашение\n\tPHP. Это соглашение заключается в то, что\n\tесли у нас есть некоторый файл с классом,\n\tто путь по папкам сайта к этому файлу должен\n\tсовпадать с пространством имен файла, а имя\n\tфайла должно совпадать с именем хранящегося\n\tв нем класса. При этом имена папок и файла\n\tдолжны быть в нижнем регистре.\n</p>\n<p>\n\tПосмотрим на примере. Пусть у нас есть\n\tследующий класс:\n<p>\n<div class=\"block\" data-file=\"/core/admin/pagecontroller.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core\\Admin;\n\t\n\tclass PageController\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПо соглашению данный класс должен располагаться\n\tв папке <code class=\"path inline\">/core/admin/</code> в файле <code class=\"path inline\">pagecontroller.php</code>.\n</p>\n<p>\n\tДавайте теперь в файле <code class=\"path inline\">index.php</code> используем\n\tнаш класс, не подключая его через <code class=\"code inline\">require</code>,\n\tа используя автозагрузку. Для этого в начале\n\tфайла, в котором вызываются классы, следует\n\tвызвать функцию <code class=\"code inline\">spl_autoload_register</code>.\n\tСделаем это:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tspl_autoload_register(); // включаем автозагрузку\n\t\n\t$obj = new Core\\Admin\\PageController; // спокойно создаем объект\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ файле <code class=\"path inline\">index.php</code> включите автоматическую\n\t\tзагрузку классов. Следуя соглашению об именах\n\t\tпапок и файлов сделайте класс <code class=\"code inline\">Core\\User</code>,\n\t\tкласс <code class=\"code inline\">Core\\Admin\\Controller</code> и класс\n\t\t<code class=\"code inline\">Project\\User\\Data</code>. В файле <code class=\"path inline\">index.php</code>\n\t\tсоздайте объекты этих классов.\n\t</p>\n</div>\n\n<h2>Замечания</h2>\n<p>\n\tФункция <code class=\"code inline\">spl_autoload_register</code> пишется\n\tтолько один раз в начале файла. Затем можно\n\tсоздавать столько объектов разных классов,\n\tсколько угодно, главное, чтобы их имена следовали\n\tсоглашениям.\n</p>\n<p>\n\tФункция <code class=\"code inline\">spl_autoload_register</code> пишется\n\tтолько в начале того файла, который вызывается\n\tчерез адресную строку браузера. То есть,\n\tесли какой-то класс вызывает внутри себя\n\tдругой класс или наследует от кого-то, а\n\tсам класс вызывается в другом файле, то <code class=\"code inline\">spl_autoload_register</code>\n\tнужно написать только в этом другом файле\n\t- в самом файле класса дублировать эту функцию\n\tне надо.\n</p>\n</div>\n\n\n<!--\nhttp://php.net/manual/ru/language.oop5.autoload.php\nhttps://klisl.com/ClassLoader.html\nhttps://habr.com/post/138920/\nhttp://qaru.site/questions/309126/php-autoloading-in-namespaces\n\nhttps://codengineering.ru/post/28\n\n\n\nСообщество PHP-разработчиков давно занимается стандартизацией того, как лучше всего организовать механизм автозагрузки, который бы использовался всеми остальными заинтересованными сторонами. Преследуется довольно банальная цель: чтобы при подключении стороннего класса или фреймворка можно было быстро его внедрить в вашу автозагрузку и начать использовать как можно быстрее. Текущая спецификация, описывающая актуальный стандарт автозагрузки называется PSR-4. Ее перевод доступен здесь.\n\n\n\n\t\t$filename = BASE_PATH . DIRECTORY_SEPARATOR . str_replace('\\\\', DIRECTORY_SEPARATOR, $class) . <code class=\"string inline\">'.php'</code>;\n\t\tinclude($filename);\n\n\nspl_autoload_register(function($class) {\n\n\tpreg_match('#(.+)\\\\\\\\(.+?)$#', get_class($this), $match);\n\n\t$path = $_SERVER['DOCUMENT_ROOT'] . DIRECTORY_SEPARATOR . str_replace('\\\\', DIRECTORY_SEPARATOR, $class) . <code class=\"string inline\">'.php'</code>;\n\n\tvar_dump($path);\n\n\t\n\n\tif (file_exists($path)) {\n\n\t\trequire_once $path;\n\n\t\treturn true;\n\n\t}\n\n\t\n\n\treturn false;\n\n});\n-->\t\t\t"},{"url":"/ru/php/book/oop/autoloading/own-function","content":"\n\t\t\t\t<h1>Своя функция для автозагрузки классов</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tЧасто автозагрузка по умолчанию может вас\n\tне устраивать по каким-нибудь причинам. В\n\tтаком случае можно написать свою автозагрузку.\n</p>\n<p>\n\tДля этого в функцию <code class=\"code inline\">spl_autoload_register</code>\n\tнужно первым параметром передать написанную\n\tвами функцию-коллбэк. Эта функция будет вызываться,\n\tкогда PHP будет обнаруживать обращение к\n\tнезагруженному классу. В параметр этой функции\n\tбудет попадать имя класса с пространством имен:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tspl_autoload_register(function($class) {\n\t\t// в переменной $class будет имя класса с пространством имен\n\t});\n?&gt;</code>\n</div>\n<p>\n\tА обязанностью функции будет по имени класса\n\tвыполнить загрузку этого класса через <code class=\"code inline\">require</code>.\n\tТо есть внутри этой функции мы должны прописать\n\tсвое правило для загрузки классов, то есть\n\tсвое соглашение имен.\n</p>\n<p>\n\tДавайте напишем пример какой-нибудь своей\n\tавтозагрузки. Пусть, например, мы говорим,\n\tчто путь к файлу класса от корня сайта будет\n\tтакой же, как и пространство имен, но с сохранением\n\tрегистра символов.\n</p>\n<p>\n\tТо есть, если у нас есть класс <code class=\"code inline\">Core\\Admin\\PageController</code>,\n\tто путь к нему должен быть <code class=\"path inline\">Core/Admin/PageController.php</code>.\n</p>\n<p>\n\tКак вы видите, для преобразования имени класса\n\tс его пространством нужно просто поменять\n\tобратные слеши на прямые, а к имени класса\n\tдобавить <code class=\"path inline\">.php</code>. Сделаем это:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tspl_autoload_register(function($class) {\n\t\t$filename = str_replace('\\\\', '/', $class) . '.php';\n\t\trequire($filename);\n\t});\n?&gt;</code>\n</div>\n<p>\n\tУ нас, однако, получится относительный путь\n\tк файлу (относительно корня сайта). Лучше\n\tсделать абсолютный путь, вот так:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tspl_autoload_register(function($class) {\n\t\t$root = $_SERVER['DOCUMENT_ROOT'];\n\t\t$filename = $root . '/' . str_replace('\\\\', '/', $class) . '.php';\n\t\trequire($filename);\n\t});\n?&gt;</code>\n</div>\n<p>\n\tЕсть еще нюанс. В разных операционных системах\n\tпуть по папкам может быть с прямым слешем\n\tили с обратным. Сделаем наш код независимым\n\tот операционной системы. Для этого вместо\n\tпрямого слеша для разделения путей будем\n\tставить константу <code class=\"code inline\">DIRECTORY_SEPARATOR</code>,\n\tсодержащую правильный слеш той операционной\n\tсистемы, в который сейчас запускается наш\n\tскрипт. В итоге получим следующий код:\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tspl_autoload_register(function($class) {\n\t\t$root = $_SERVER['DOCUMENT_ROOT'];\n\t\t$ds = DIRECTORY_SEPARATOR;\n\t\t\n\t\t$filename = $root . $ds . str_replace('\\\\', $ds, $class) . '.php';\n\t\trequire($filename);\n\t});\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПотестируйте созданную мною функцию автозагрузки.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПридумайте свое правило автозагрузки и реализуйте\n\t\tего.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/using/intro/","content":"\n\t\t\t\t<h1>Подход MVC для разработки сайтов на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tКогда мы разрабатываем сайт, то пишем HTML\n\tи PHP код в одном и том же файле, перемешивая\n\tэти языки между собой. Если проект маленький,\n\tто ничего страшного в этом нет. Но если проект\n\tначнет расти, то через некоторое время его\n\tстанет достаточно тяжело поддерживать из-за\n\tсмешения языков. Со временем проект будет\n\tстановиться все больше и больше, код становиться\n\tвсе запутанней, и вам тяжело будет его поддерживать.\n</p>\n<p>\n\tДля решения таких проблем был придуман специальный\n\tподход под названием MVC. Эта аббревиатура\n\tрасшифровывается следующим образом: M - модель\n\t(<span class=\"translate-en\">model</span>), V - представление (<span class=\"translate-en\">view</span>),\n\tС - контроллер (<span class=\"translate-en\">controller</span>). При\n\tэтом модель отвечает за получение данных,\n\tпредставление - за вывод этих данных на экран\n\tв нужном виде, а контроллер представляет\n\tсобой связующее звено между моделью и представлением.\n</p>\n<p>\n\tНа основе MVC созданы все PHP <dfn>фреймворки</dfn>.\n\tФреймворк представляет собой заготовку проекта,\n\tупрощающую разработку сайта PHP программистом,\n\tизбавляя его от многих рутинных операций.\n\tКроме того, фреймворк представляет собой\n\tнабор правил, которым необходимо следовать\n\tпри разработке. Следование этим правилам\n\tвносит четкую структуру в проект, обеспечивая\n\tлегкую поддержку созданного кода, а также\n\tпозволяя легко брать новых людей в проект.\n\tОдним из таких правил и является подход MVC.\n</p>\n\n<h2>Как работает MVC</h2>\n<p>\n\tРассмотрим, как работает сайт на MVC. Все\n\tначинается с того, что пользователь вбивает\n\tадрес в адресную строку (чаще всего перейдя\n\tпо ссылке). В этот момент контроллер разбирается,\n\tчто именно хотел получить пользователь и\n\tпросит модель дать соответствующие данные.\n\tМодель дает контроллеру данные. Контроллер\n\tполучает эти данные и отправляет их в представление.\n\tПредставление показывает данные в оформленном\n\tнужным образом виде.\n</p>\n<p>\n\tПри этом у нас получается разделение труда:\n\tконтроллер не знает, как получить данные\n\t- он просто просит об этом модель, представление\n\tне знает, откуда приходят данные - оно просто\n\tих отображает.\n</p>\n<p>\n\tУверен, что пока это все звучит не понятно,\n\tпоэтому специально для вас я сделал учебный\n\tмини фреймворк, использующий MVC подход.\n\tДля начала я научу вас пользоваться этим\n\tфреймворком, чтобы вы поняли, как именно\n\tследует разрабатывать на MVC. А затем вы\n\tсами, следуя моим указаниям, напишите такой\n\tже фреймворк на ООП.\n</p>\n\n<h2>Уставновка фреймворка</h2>\n<p>\n\tДля начала фреймворк необходимо скачать по\n\tследующей ссылке: <a href=\"/content/php/book/oop/mvc/using/intro/&/download/framework.zip\">скачать\n\tфреймворк</a>. Распакуйте файлы фреймворка\n\tв какую-нибудь папку сервера, например, в\n\t<code class=\"path inline\">framework.local</code>. В PhpMyAdmin создайте\n\tбазу данных для вашего фреймворка. Затем\n\tперейдите в файл <code class=\"path inline\">/project/config/connection.php</code>\n\tи настройте там подключение к базе данных.\n\tДля проверки работы перейдите по следующему\n\tадресу: <code class=\"path inline\">http://framework.local/hello/</code>.\n\tТам вы должны увидеть приветственное сообщение.\n\tЕсли вы его видите - значит все работает.\n</p>\n\n<h2>Структура папок</h2>\n<p>\n\tПосле распаковки фреймворка у вас будут две\n\tпапки: папка <code class=\"path inline\">core</code> и папка <code class=\"path inline\">project</code>.\n</p>\n<p>\n\tВ папке <code class=\"path inline\">core</code> размещается написанное\n\tмною ядро нашего фреймворка. Под ядром понимается\n\tкод, который обеспечивает функционал, которым\n\tвы будете пользоваться при разработке. При\n\tиспользовании фреймворка в эту папку заглядывать\n\tвам, как правило, не будет нужно. В папке\n\t<code class=\"path inline\">project</code> будут размещаться файлы вашего\n\tпроекта: контроллеры, модели, представления,\n\tа также настройки фреймворка. Именно в этой\n\tпапке и будет вестись вся работа по разработке\n\tсайта.\n</p>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/using/controllers-actions-routes/","content":"\n\t\t\t\t<h1>Контроллеры, действия и роуты в MVC на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПервое, с чем мы разберемся - это контроллеры.\n\tКонтроллеры обрабатывают запросы пользователя,\n\tпонимают, что хотел попросить пользователь\n\tу сайта, просят соответствующие данные из\n\tмодели и отправляют их в представление.\n</p>\n<p>\n\tКонтроллеры представляют собой ООП классы.\n\tОдин файл - это один класс и, соответственно,\n\tодин контроллер. В нашем фреймворке контроллеры\n\tбудут храниться в папке <code class=\"path inline\">project/controllers</code>.\n</p>\n<p>\n\tДавайте потренируемся в создании контроллеров.\n\tДля разминки сделаем класс <code class=\"code inline\">PageController</code>,\n\tкоторый будет управлять текстовыми страницами\n\tна нашем сайте.\n</p>\n<p>\n\tДавайте сразу создадим файл для нашего контроллера.\n\tПо правилам нашего фреймворка каждый класс\n\tдолжен хранится в файле с одноименным названием\n\t(вплоть до регистра). То есть наш класс <code class=\"code inline\">PageController</code>\n\tбудет хранится в файле <code class=\"path inline\">PageController.php</code>.\n\tСоздайте этот файл в папке <code class=\"path inline\">project/controllers</code>.\n</p>\n<p>\n\tСделаем в этом файле наш класс:\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse \\Core\\Controller;\n\t\n\tclass PageController extends Controller\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, наш класс принадлежит пространству\n\tимен <code class=\"code inline\">Project\\Controllers</code>, следуя соглашению\n\tоб автозагрузке файлов (то есть путь по папкам\n\tдолжен совпадать с пространством имен).\n</p>\n<p>\n\tКроме того, наш класс наследуется от класса\n\t<code class=\"code inline\">Core\\Controller</code>, находящегося в ядре\n\tфреймворка. В этом не нужно искать глубокий\n\tсмысл, а просто нужно принять как правило\n\tфреймворка. Вот это правило: <i>все создаваемые\n\tвами контроллеры должны наследоваться от\n\tкласса <code class=\"code inline\">Core\\Controller</code>, чтобы все\n\tработало, как надо.</i>\n</p>\n\n<h2>Действия</h2>\n<p>\n\tДобавим теперь в наш контроллер методы класса.\n\tВ терминах MVC методы контроллеров называются\n\t<dfn>действиями</dfn> (<span class=\"translate-prefix\">англ.</span> <span class=\"translate-en\">actions</span>).\n\tСделаем, например, два действия - <code class=\"code inline\">show1</code>\n\tи <code class=\"code inline\">show2</code>, и в каждом действии выведем\n\tчто-нибудь на экран:\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse \\Core\\Controller;\n\t\n\tclass PageController extends Controller\n\t{\n\t\tpublic function show1()\n\t\t{\n\t\t\techo '1';\n\t\t}\n\t\t\n\t\tpublic function show2()\n\t\t{\n\t\t\techo '2';\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Роутинг</h2>\n<p>\n\tТеперь вам необходимо познакомиться с таким\n\tпонятием, как <dfn>роутинг</dfn>. Он представляет\n\tсобой механизм, с помощью которого можно\n\tвызывать определенное действие определенного\n\tконтроллера через адресную строку браузера.\n</p>\n<p>\n\tНастройки роутинга хранятся в файле <code class=\"path inline\">/project/config/routes.php</code>\n\tи представляют собой массив объектов класса\n\t<code class=\"code inline\">\\Core\\Route</code>. Конструктор этого класса\n\tпервым параметром принимает URI, по запросу\n\tкоторого вызовется соответствующий метод\n\tсоответствующего контроллера. Имя контроллера\n\tи имя действия задаются вторым и третьим\n\tпараметрами. При этом имя контроллера задается\n\tс маленькой буквы.\n</p>\n<p>\n\tДавайте для примера добавим два роута (то\n\tесть маршрута): первый при обращении к адресу\n\t<code class=\"path inline\">/my-page1/</code> будет вызывать метод\n\t<code class=\"code inline\">show1</code> контроллера <code class=\"code inline\">page</code>, а второй\n\t- метод <code class=\"code inline\">show2</code> этого же контроллера:\n</p>\n<div class=\"block\" data-file=\"/project/config/routes.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tuse \\Core\\Route;\n\t\n\treturn [\n\t\tnew Route('/my-page1/', 'page', 'show1'),\n\t\tnew Route('/my-page2/', 'page', 'show2'),\n\t];\n?&gt;</code>\n</div>\n\n<h2>Практические задачи</h2>\n<div class=\"task\">\n\t<p>\n\t\tСделайте контроллер <code class=\"code inline\">TestController</code>\n\t\tс действиями <code class=\"code inline\">act1</code>, <code class=\"code inline\">act2</code> и <code class=\"code inline\">act3</code>.\n\t\tСделайте три роута, задающие адреса, по которым\n\t\tможно будет обратиться к этим действиям.\n\t\tПроверьте работу созданного вами кода, по\n\t\tочереди обратившись через адресную строку\n\t\tк каждому из действий.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/using/routes-parameters/","content":"\n\t\t\t\t<h1>Параметры в роутах в MVC на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ предыдущем уроке наши роуты имели фиксированные\n\tадреса. На самом деле механизм роутинга более\n\tсложный - можно сделать так, чтобы часть\n\tURI страницы попадала в именованные параметры,\n\tдоступные затем в контроллере.\n</p>\n<p>\n\tПусть, к примеру, наши адреса будут выглядеть\n\tвот так: <code class=\"path inline\">/test/параметр1/параметр2/</code>,\n\tгде параметр1 и параметр2 - произвольные\n\tстроки. При этом мы хотим, чтобы адреса такого\n\tвида обрабатывались одним действием контроллера.\n\tДля этого следует придумать имя параметра\n\tи перед ним поставить двоеточие, вот так:\n</p>\n<div class=\"block\" data-file=\"/project/config/routes.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tuse \\Core\\Route;\n\t\n\treturn [\n\t\tnew Route('/test/:var1/:var2/', 'page', 'act'),\n\t];\n?&gt;</code>\n</div>\n<p>\n\tВ нашем случае получится, что все запросы\n\tвида <code class=\"path inline\">/test/параметр1/параметр2/</code>\n\tбудут попадать на действие <code class=\"code inline\">act</code>. При\n\tэтом в первый параметр этого действия будет\n\tпопадать ассоциативный массив с параметрами:\n\tтекст, который будет на месте первого параметра,\n\tпопадает в элемент массива с ключом <code class=\"string inline\">'var1'</code>,\n\tа текст второго параметра - в <code class=\"string inline\">'var2'</code>.\n</p>\n<p>\n\tПусть, к примеру, в адресной строке набрано\n\tследующее: <code class=\"path inline\">/test/eee/bbb/</code>. Давайте\n\tпосмотрим, что будет содержать первый параметр\n\tдействия:\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse Core\\Controller;\n\t\n\tclass PageController extends Controller\n\t{\n\t\tpublic function act($params)\n\t\t{\n\t\t\tvar_dump($params); // ['var1' =&gt; 'eee', 'var2' =&gt; 'bbb']\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСделайте контроллер <code class=\"code inline\">NumController</code>,\n\t\tа в нем - действие <code class=\"code inline\">sum</code>. Пусть это\n\t\tдействие обрабатывает адреса следующего вида:\n\t\t<code class=\"path inline\">/nums/:n1/:n2/:n3/</code>, где параметрами\n\t\tбудут некоторые числа. Сделайте так, чтобы\n\t\tна экран выводилась сумма переданных чисел.\n\t</p>\n</div>\n\n<h2>Применение</h2>\n<p>\n\tДавайте посмотрим применение описанного на\n\tболее жизненном примере. Пусть наш контроллер\n\t<code class=\"code inline\">PageController</code> содержит массив страниц\n\t(эти данные должна отдавать модель, но с\n\tмоделями мы еще не разобрались, поэтому пусть\n\tданные пока просто хранятся в контроллере):\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse Core\\Controller;\n\t\n\tclass PageController extends Controller\n\t{\n\t\tprivate $pages;\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;pages = [\n\t\t\t\t1 =&gt; 'страница 1',\n\t\t\t\t2 =&gt; 'страница 2',\n\t\t\t\t3 =&gt; 'страница 3',\n\t\t\t];\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте сделаем действие <code class=\"code inline\">show</code>, которое\n\tбудет выводить на экран страницу с определенным\n\tномером (<code class=\"string inline\">id</code>):\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse Core\\Controller;\n\t\n\tclass PageController extends Controller\n\t{\n\t\tprivate $pages;\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;pages = [\n\t\t\t\t1 =&gt; 'страница 1',\n\t\t\t\t2 =&gt; 'страница 2',\n\t\t\t\t3 =&gt; 'страница 3',\n\t\t\t];\n\t\t}\n\t\t\n\t\tpublic function show()\n\t\t{\n\t\t\t// здесь выведем страницу с определенным номером\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПусть при обращении к адресу <code class=\"path inline\">/page/1/</code>\n\tбудет выводится текст первой страницы, при\n\tобращении к адресу <code class=\"path inline\">/page/2/</code> -\n\tтекст второй страницы и так далее. Сделаем\n\tсоответствующий роут:\n</p>\n<div class=\"block\" data-file=\"/project/config/routes.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tuse \\Core\\Route;\n\t\n\treturn [\n\t\tnew Route('/page/:id/', 'page', 'show'),\n\t];\n?&gt;</code>\n</div>\n<p>\n\tРеализуем описанный метод <code class=\"code inline\">show</code>:\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse Core\\Controller;\n\t\n\tclass PageController extends Controller\n\t{\n\t\tprivate $pages;\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;pages = [\n\t\t\t\t1 =&gt; 'страница 1',\n\t\t\t\t2 =&gt; 'страница 2',\n\t\t\t\t3 =&gt; 'страница 3',\n\t\t\t];\n\t\t}\n\t\t\n\t\tpublic function show($params)\n\t\t{\n\t\t\techo $this-&gt;pages[ $params['id'] ]; // выводим страницу по номеру\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте контроллер <code class=\"code inline\">UserController</code>,\n\t\tсодержащий следующий массив:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$this-&gt;users = [\n\t\t1 =&gt; ['name'=&gt;'user1', 'age'=&gt;'23', 'salary' =&gt; 1000],\n\t\t2 =&gt; ['name'=&gt;'user2', 'age'=&gt;'24', 'salary' =&gt; 2000],\n\t\t3 =&gt; ['name'=&gt;'user3', 'age'=&gt;'25', 'salary' =&gt; 3000],\n\t\t4 =&gt; ['name'=&gt;'user4', 'age'=&gt;'26', 'salary' =&gt; 4000],\n\t\t5 =&gt; ['name'=&gt;'user5', 'age'=&gt;'27', 'salary' =&gt; 5000],\n\t];\n?&gt;</code>\n\t</div>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ контроллере <code class=\"code inline\">UserController</code>, сделайте\n\t\tдействие <code class=\"code inline\">show</code>, которое будет выводить\n\t\tюзера по определенному <code class=\"string inline\">id</code>. Пусть оно\n\t\tбудет доступно по адресу следующего вида:\n\t\t<code class=\"path inline\">/user/:id/</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ контроллере <code class=\"code inline\">UserController</code>, сделайте\n\t\tдействие <code class=\"code inline\">info</code>, которое будет выводить\n\t\tимя или возраст заданного юзера. Пусть это\n\t\tдействие будет доступно по адресу следующего\n\t\tвида: <code class=\"path inline\">/user/:id/:key/</code>, где <code class=\"path inline\">key</code>\n\t\tбудет иметь значение <code class=\"string inline\">'name'</code>, <code class=\"string inline\">'age'</code>\n\t\tили <code class=\"string inline\">'salary'</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ контроллере <code class=\"code inline\">UserController</code>, сделайте\n\t\tдействие <code class=\"code inline\">all</code>, которое будет выводить\n\t\tсписок всех юзеров на экран. Пусть это действие\n\t\tбудет доступно по адресу следующего вида:\n\t\t<code class=\"path inline\">/user/all/</code> (параметров тут никаких\n\t\tне будет).\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ контроллере <code class=\"code inline\">UserController</code>, сделайте\n\t\tдействие <code class=\"code inline\">first</code>, которое будет выводить\n\t\tсписок N первых юзеров на экран. Пусть это\n\t\tдействие будет доступно по адресу следующего\n\t\tвида: <code class=\"path inline\">/user/first/:n/</code>, где в параметре\n\t\tбудет количество юзеров, которые следует\n\t\tвывести на экран.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/using/views/","content":"\n\t\t\t\t<h1>Представления в MVC на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте теперь добавим нашим действиям представления.\n\tПо правилам нашего фреймворка представления\n\tхранятся в папке <code class=\"path inline\">/project/views/</code>.\n</p>\n<p>\n\tКроме того, в нашем фреймворке действует\n\tсоглашение: имя файла с представлением должно\n\tсовпадать с именем действия и размещаться\n\tв папке с таким же названием, как имя контроллера.\n\tНапример, если у нас есть контроллер <code class=\"code inline\">PageController</code>,\n\tто все его представления следует хранить\n\tв папке <code class=\"path inline\">/project/views/page/</code>. Сам\n\tфайл представления должен иметь расширение\n\t<code class=\"path inline\">.php</code>. К примеру, если в контроллере\n\t<code class=\"code inline\">PageController</code> будет действие <code class=\"code inline\">act</code>,\n\tто его представление следует размещать в\n\t<code class=\"path inline\">/project/views/page/act.php</code>.\n</p>\n<p>\n\tДля того, чтобы задать представление какому-нибудь\n\tдействию, это действие должно вызвать метод\n\t<code class=\"code inline\">render</code>, передав ему параметром имя\n\tпредставления. Имя представления должно состоять\n\tиз имени контроллера с маленькой буквы, после\n\tкоторого через <code class=\"code inline\">/</code> будет записано имя\n\tдействия\n</p>\n<p>\n\tМетод <code class=\"code inline\">render</code> не нужно реализовывать\n\tв контроллере - он наследуется от родительского\n\tкласса <code class=\"code inline\">Core\\Controller</code>. Кроме того,\n\tдля корректной работы результат работы метода\n\tследует вернуть через <code class=\"code inline\">return</code>.\n</p>\n<p>\n\tИтак, пусть у нас есть контроллер <code class=\"code inline\">Page</code>\n\tс действием <code class=\"code inline\">act</code>. Давайте привяжем\n\tк этому действию представление:\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse Core\\Controller;\n\t\n\tclass PageController extends Controller\n\t{\n\t\tpublic function act()\n\t\t{\n\t\t\treturn $this-&gt;render('page/act');\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tСделаем теперь файл с HTML кодом нашего представления:\n</p>\n<div class=\"block\" data-file=\"/project/views/page/act.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;div&gt;\n\tэто представление\n\tдействия act контроллера page\n&lt;/div&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПроделайте описанные манипуляции, а затем\n\t\tобратитесь к нашему действию через адресную\n\t\tстроку. Убедитесь, что в браузере появится\n\t\tтекст из созданного вами представления.\n\t</p>\n</div>\n\n<h2>Передача данных в представление</h2>\n<p>\n\tС помощью второго параметра метода <code class=\"code inline\">render</code>\n\tможно передавать данные из контроллера в\n\tпредставление. Данные следует передавать\n\tв виде ассоциативного массива. При этом в\n\tпредставлении ключи этого массива станут\n\tпеременными с соответствующими значениями.\n</p>\n<p>\n\tДавайте посмотрим на практике. Передадим\n\tв наше представление массив с тремя элементами:\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse Core\\Controller;\n\t\n\tclass PageController extends Controller\n\t{\n\t\tpublic function act()\n\t\t{\n\t\t\treturn $this-&gt;render('page/act', [\n\t\t\t\t'var1' =&gt; 'eee',\n\t\t\t\t'var2' =&gt; 'bbb',\n\t\t\t\t'var3' =&gt; 'kkk',\n\t\t\t]);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, ключи нашего массива - <code class=\"string inline\">'var1'</code>,\n\t<code class=\"string inline\">'var2'</code> и <code class=\"string inline\">'var3'</code>. Это значит,\n\tчто в представлении будут доступны такие\n\tпеременные и мы можем вывести их значения\n\tв нужных местах HTML кода. Сделаем это:\n</p>\n<div class=\"block\" data-file=\"/project/views/page/act.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;div&gt;\n\tэто представление\n\tдействия act контроллера test\n&lt;/div&gt;\n&lt;ul&gt;\n\t&lt;li&gt;&lt;?php echo $var1; ?&gt;&lt;/li&gt;\n\t&lt;li&gt;&lt;?php echo $var2; ?&gt;&lt;/li&gt;\n\t&lt;li&gt;&lt;?php echo $var3; ?&gt;&lt;/li&gt;\n&lt;/ul&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПроделайте описанные манипуляции, а затем\n\t\tобратитесь к нашему действию через адресную\n\t\tстроку. Убедитесь, что в браузере появится\n\t\tтекст из созданного вами представления.\n\t</p>\n</div>\n\n<h2>Передача массивов</h2>\n<p>\n\tВ представление можно также передавать и\n\tмассивы. Давайте, например, передадим массив\n\tюзеров:\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse Core\\Controller;\n\t\n\tclass PageController extends Controller\n\t{\n\t\tpublic function act()\n\t\t{\n\t\t\treturn $this-&gt;render('page/act', [\n\t\t\t\t'header' =&gt; 'список юзеров',\n\t\t\t\t'users'  =&gt; ['user1', 'user2', 'user3'],\n\t\t\t]);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tМожно обратиться к каждому элементу массива:\n</p>\n<div class=\"block\" data-file=\"/project/views/page/act.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;h1&gt;&lt;?= $header ?&gt;&lt;/h1&gt;\n&lt;ul&gt;\n\t&lt;li&gt;&lt;?= $users[0]; ?&gt;&lt;/li&gt;\n\t&lt;li&gt;&lt;?= $users[1]; ?&gt;&lt;/li&gt;\n\t&lt;li&gt;&lt;?= $users[2]; ?&gt;&lt;/li&gt;\n&lt;/ul&gt;</code>\n</div>\n<p>\n\tА можно перебрать массив циклом и сформировать\n\tнужный HTML код:\n</p>\n<div class=\"block\" data-file=\"/project/views/page/act.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;h1&gt;&lt;?= $header ?&gt;&lt;/h1&gt;\n&lt;ul&gt;\n\t&lt;?php foreach ($users as $user): ?&gt;\n\t\t&lt;li&gt;&lt;?= $user; ?&gt;&lt;/li&gt;\n\t&lt;?php endforeach; ?&gt;\n&lt;/ul&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПроделайте описанные манипуляции, а затем\n\t\tобратитесь к нашему действию через адресную\n\t\tстроку. Убедитесь, что в браузере появится\n\t\tтекст из созданного вами представления.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/using/controllers-and-views-training/","content":"\n\t\t\t\t<h1>Практика на контроллеры и представления в MVC</h1>\n\t\t\t\t<div class=\"content\">\n<div class=\"task\">\n\t<p>\n\t\tСоздайте контроллер <code class=\"code inline\">Product</code>, в конструкторе\n\t\tкоторого будет задаваться следующий массив:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$this-&gt;products = [\n\t\t1 =&gt; [\n\t\t\t'name'     =&gt; 'product1',\n\t\t\t'price'    =&gt; 100,\n\t\t\t'quantity' =&gt; 5,\n\t\t\t'category' =&gt; 'category1',\n\t\t],\n\t\t2 =&gt; [\n\t\t\t'name'     =&gt; 'product2',\n\t\t\t'price'    =&gt; 200,\n\t\t\t'quantity' =&gt; 6,\n\t\t\t'category' =&gt; 'category2',\n\t\t],\n\t\t3 =&gt; [\n\t\t\t'name'     =&gt; 'product3',\n\t\t\t'price'    =&gt; 300,\n\t\t\t'quantity' =&gt; 7,\n\t\t\t'category' =&gt; 'category2',\n\t\t],\n\t\t4 =&gt; [\n\t\t\t'name'     =&gt; 'product4',\n\t\t\t'price'    =&gt; 400,\n\t\t\t'quantity' =&gt; 8,\n\t\t\t'category' =&gt; 'category3',\n\t\t],\n\t\t5 =&gt; [\n\t\t\t'name'     =&gt; 'product5',\n\t\t\t'price'    =&gt; 500,\n\t\t\t'quantity' =&gt; 9,\n\t\t\t'category' =&gt; 'category3',\n\t\t],\n\t]\n?&gt;</code>\n\t</div>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ контроллере <code class=\"code inline\">Product</code> сделайте действие\n\t\t<code class=\"code inline\">show</code>, которое будет показывать информацию\n\t\tоб одном продукте. Пусть это действие обрабатывает\n\t\tадреса следующего вида: <code class=\"path inline\">/product/:n/</code>,\n\t\tгде параметром будет номер продукта в массиве.\n\t\tСделайте так, чтобы обращение по таким адресам\n\t\tвыводило через <code class=\"code inline\">var_dump</code> данные того\n\t\tпродукта, который был запрошен через адресную\n\t\tстроку.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tДобавьте к созданному действию представление.\n\t\tИспользуйте для этого следующую верстку:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;h1&gt;Продукт \"product1\" из категории \"category1\"&lt;/h1&gt;\n&lt;p&gt;\n\tЦена: 100$, количество: 5\n&lt;/p&gt;\n&lt;p&gt;\n\tСтоимость (цена * количество): 500$\n&lt;/p&gt;</code>\n\t</div>\n\t<p>\n\t\tДанные в этой верстке соответствуют первому\n\t\tпродукту. Сделайте так, чтобы представление\n\t\tпоказывало данные того продукта, который\n\t\tбыл запрошен через адресную строку.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tВ контроллере <code class=\"code inline\">Product</code> сделайте действие\n\t\t<code class=\"code inline\">all</code>, которое будет выводить список всех\n\t\tпродуктов в виде HTML таблицы. Пусть это действие\n\t\tобрабатывает адрес <code class=\"path inline\">/products/all/</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/using/layouts/","content":"\n\t\t\t\t<h1>Шаблоны в MVC на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПредставления, которые мы с вами изучали\n\tв предыдущем уроке, на самом деле представляют\n\tсобой контент страницы. Кроме контента, на\n\tстранице, как правило, есть еще хедер, сайдбары,\n\tфутер. Эти части обычно одинаковые на всех\n\tстраницах сайта.\n</p>\n<p>\n\tВ нашем фреймворке каждая страница сайта\n\tпредставляет собой один и тот же HTML файл\n\tшаблона, к которому для каждой страницы сайта\n\tподключается в заданное место контент страницы\n\tиз представления.\n</p>\n<p>\n\tФайл с шаблоном размещается по следующему\n\tпути: <code class=\"path inline\">/project/layouts/default.php</code>.\n\tСогласно правилам фреймворка, в этом файле\n\tдоступна переменная <code class=\"code inline\">$content</code>. В том\n\tместе, где будет выведена эта переменная\n\tи произойдет вставка контента страницы.\n</p>\n<p>\n\tПо умолчанию этот файл содержит следующий\n\tпростейший код:\n</p>\n<div class=\"block\" data-file=\"/project/layouts/default.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;title&gt;&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t&lt;?= $content ?&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРазместите в файле с шаблоном вот такой макет\n\t\tсайта:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset=\"utf-8\"&gt;\n\t\t&lt;title&gt;тайтл страницы&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t&lt;header&gt;\n\t\t\tхедер сайта\n\t\t&lt;/header&gt;\n\t\t&lt;div class=\"container\"&gt;\n\t\t\t&lt;aside class=\"sidebar left\"&gt;\n\t\t\t\tлевый сайдбар\n\t\t\t&lt;/aside&gt;\n\t\t\t&lt;main&gt;\n\t\t\t\t&lt;?= $content ?&gt;\n\t\t\t&lt;/main&gt;\n\t\t\t&lt;aside class=\"sidebar right\"&gt;\n\t\t\t\tправый сайдбар\n\t\t\t&lt;/aside&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;footer&gt;\n\t\t\tфутер сайта\n\t\t&lt;/footer&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;</code>\n\t</div>\n\t<p>\n\t\tЗайдите на любое действие любого контроллера.\n\t\tПосмотрите, что поменялось.\n\t</p>\n</div>\n\n<h2>Тайтл страницы</h2>\n<p>\n\tВ файле шаблона также доступна переменная\n\t<code class=\"code inline\">$title</code>, содержащая тайтл страницы.\n\tОчевидно, что этот заголовок также будет\n\tразным для различных страниц. Давайте используем\n\tэту переменную по назначению:\n</p>\n<div class=\"block\" data-file=\"/project/layouts/default.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset=\"utf-8\"&gt;\n\t\t&lt;title&gt;&lt;?= $title ?&gt;&lt;/title&gt; &lt;!-- выводим тайтл страницы --&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t...\n\t&lt;/body&gt;\n&lt;/html&gt;</code>\n</div>\n<p>\n\tДля того, чтобы задать тайтл для определенного\n\tпредставления необходимо в контроллере записать\n\tего в свойство <code class=\"code inline\">title</code>:\n</p>\n<div class=\"block\" data-file=\"project/controllers/TestController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse Core\\Controller;\n\t\n\tclass TestController extends Controller\n\t{\n\t\tpublic function act()\n\t\t{\n\t\t\t// Зададим тайтл:\n\t\t\t$this-&gt;title = 'Действие act контроллера test';\n\t\t\t\n\t\t\t// Отрендерим представление, передав какие-то данные:\n\t\t\treturn $this-&gt;render('test/act', [\n\t\t\t\t'var1' =&gt; 'eee',\n\t\t\t\t'var2' =&gt; 'bbb',\n\t\t\t\t'var3' =&gt; 'kkk',\n\t\t\t]);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tМодифицируйте файл шаблона и все ваши контроллеры\n\t\tтак, чтобы для каждого представления выводился\n\t\tсвой тайтл.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПусть в контроллере <code class=\"code inline\">Page</code> дан следующий\n\t\tмассив:\n\t</p>\n\t<div class=\"block\">\n\t\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$this-&gt;pages = [\n\t\t1 =&gt; ['title'=&gt;'страница 1', 'text'=&gt;'текст страницы 1'],\n\t\t2 =&gt; ['title'=&gt;'страница 2', 'text'=&gt;'текст страницы 2'],\n\t\t3 =&gt; ['title'=&gt;'страница 3', 'text'=&gt;'текст страницы 3'],\n\t];\n?&gt;</code>\n\t</div>\n\t<p>\n\t\tСделайте действие <code class=\"code inline\">show</code>, которое будет\n\t\tвыводить заданную страницу. Пусть в представлении\n\t\tтекст страницы из ключа <code class=\"string inline\">'text'</code> будет\n\t\tобернут в абзац, а текст из ключа <code class=\"string inline\">'title'</code>\n\t\tстанет тайтлом страницы.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/using/resources/","content":"\n\t\t\t\t<h1>Ресурсы в MVC на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПри разработке сайта требуются некоторые\n\t<dfn>ресурсы</dfn>, доступные по прямой ссылке.\n\tЭто CSS файлы, JavaScript файлы, картинки\n\tи другое. Для таких вещей в нашем фреймворке\n\tсуществует папка <code class=\"path inline\">/project/webroot/</code>.\n\tВсё, размещенное в этой папке будет доступно\n\tпо прямой ссылке.\n</p>\n<p>\n\tДавайте, например, подключим к нашему сайту\n\tCSS файл. Пусть имя этого файла <code class=\"path inline\">styles.css</code>.\n\tРазместим этот файл в папке <code class=\"path inline\">webroot</code>\n\tи подключим следующим образом:\n</p>\n<div class=\"block\" data-file=\"/project/layouts/default.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset=\"utf-8\"&gt;\n\t\t&lt;link rel=\"stylesheet\" href=\"/project/webroot/styles.css\"&gt;\n\t\t&lt;title&gt;&lt;?= $title ?&gt;&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t...\n\t&lt;/body&gt;\n&lt;/html&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПодключите к вашему сайту какой-нибудь CSS\n\t\tфайл. Проверьте его работу.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРазместите на вашем сайте какую-нибудь картинку.\n\t\tПроверьте, что она корректно отображается\n\t\tна странице сайта.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/using/models/","content":"\n\t\t\t\t<h1>Модели в MVC на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте теперь разберемся с моделями. Модели\n\tтакже, как и контроллеры, представляют собой\n\tООП классы. Их следует размещать в папке\n\t<code class=\"path inline\">/project/models/</code>. Давайте в этой папке\n\tв файле <code class=\"path inline\">Page.php</code> сделаем модель <code class=\"code inline\">Page</code>\n\tотвечающую за данные страниц нашего сайта:\n</p>\n<div class=\"block\" data-file=\"/project/models/Page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Models;\n\tuse \\Core\\Model;\n\t\n\tclass Page extends Model\n\t{\n\t\t\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, наша модель наследует от класса\n\t<code class=\"code inline\">\\Core\\Model</code>. От этого класса наша\n\tмодель наследует защищенные методы <code class=\"code inline\">findOne</code>\n\tи <code class=\"code inline\">findMany</code>. Метод <code class=\"code inline\">findOne</code> параметром\n\tпринимает SQL запрос и возвращает первую\n\tзапись из БД, попавшую в результат запроса.\n\tМетод <code class=\"code inline\">findMany</code> также принимает SQL\n\tзапрос, но возвращает массив записей.\n</p>\n<p>\n\tПри этом вам не нужно писать код, устанавливающий\n\tсоединение с БД, а также обрабатывать результаты\n\tзапроса через <code class=\"code inline\">mysqli_fetch_assoc</code>.\n\tФреймворк делает это за вас. Вам просто нужно\n\tвыбрать, ожидаете ли вы от запроса одну запись\n\tиз БД или несколько и использовать соответствующую\n\tфункцию, получив результатом вменяемый массив,\n\tкоторым можно просто взять и воспользоваться\n\tдальше.\n</p>\n\n<h2>Попробуем на практике</h2>\n<p>\n\tПусть в вашей базе данных есть таблица page\n\tс какими-нибудь записями. Давайте сделаем\n\tмодель <code class=\"code inline\">Page</code> с двумя методами. Первый\n\tметод будет получать одну запись по ее <code class=\"string inline\">id</code>,\n\tа второй метод - получать массив записей\n\tиз диапазона <code class=\"string inline\">id</code>:\n</p>\n<div class=\"block\" data-file=\"/project/models/Page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Models;\n\tuse \\Core\\Model;\n\t\n\tclass Page extends Model\n\t{\n\t\tpublic function getById($id)\n\t\t{\n\t\t\treturn $this-&gt;findOne(\"SELECT * FROM page WHERE id=$id\");\n\t\t}\n\t\t\n\t\tpublic function getByRange($from, $to)\n\t\t{\n\t\t\treturn $this-&gt;findMany(\"SELECT * FROM page WHERE id&gt;=$from AND id&lt;=$to\");\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tДавайте теперь поработаем с нашей моделью\n\tв контроллере:\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse \\Core\\Controller;\n\tuse \\Project\\Models\\Page; // подключаем нашу модель\n\t\n\tclass PageController extends Controller\n\t{\n\t\tpublic function test() {\n\t\t\t$page = new Page; // создаем объект модели\n\t\t\n\t\t\t$data = $page-&gt;getById(3); // получим запись с id=3\n\t\t\tvar_dump($data);\n\t\t\t\n\t\t\t$data = $page-&gt;getById(5); // получим запись с id=5\n\t\t\tvar_dump($data);\n\t\t\t\n\t\t\t$data = $page-&gt;getByRange(2, 5); // записи с id от 2 до 5\n\t\t\tvar_dump($data);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте в вашей базе данных таблицу <code class=\"string inline\">page</code>,\n\t\tзаполните ее данными. Проверьте работу кода,\n\t\tописанного в теории.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/using/application-example/","content":"\n\t\t\t\t<h1>Применение MVC на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tДавайте посмотрим на совместное применение\n\tвсего изученного. Пусть, к примеру, у нас\n\tна сайте есть какие-то статьи-страницы. Мы\n\tхотим либо показать одну статью, либо показать\n\tвсе статьи. Давайте рассмотрим, как это сделать\n\tв нашем фреймворке\n</p>\n\n<h2>Таблица в БД</h2>\n<p>\n\tДля начала создадим таблицу <code class=\"string inline\">pages</code>\n\tв базе данных. Добавим туда колонки <code class=\"string inline\">id</code>,\n\t<code class=\"string inline\">title</code> и <code class=\"string inline\">text</code>. Заполним эту\n\tтаблицу какими-нибудь данными через PhpMyAdmin.\n</p>\n\n<h2>Модель</h2>\n<p>\n\tСделаем модель с методом для получения одной\n\tзаписи и методом для получения всех записей:\n</p>\n<div class=\"block\" data-file=\"/project/models/Page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Models;\n\tuse \\Core\\Model;\n\t\n\tclass Page extends Model\n\t{\n\t\tpublic function getById($id)\n\t\t{\n\t\t\treturn $this-&gt;findOne(\"SELECT * FROM pages WHERE id=$id\");\n\t\t}\n\t\t\n\t\tpublic function getAll()\n\t\t{\n\t\t\treturn $this-&gt;findMany(\"SELECT id, title FROM pages\");\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Роутинг</h2>\n<p>\n\tСделаем соответствующий роутинг:\n</p>\n<div class=\"block\" data-file=\"/project/config/routes.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tuse \\Core\\Route;\n\t\n\treturn [\n\t\tnew Route('/page/:id', 'page', 'one'),\n\t\tnew Route('/pages/',   'page', 'all'),\n\t];\n?&gt;</code>\n</div>\n\n<h2>Контроллер</h2>\n<p>\n\tСделаем контроллер:\n</p>\n<div class=\"block\" data-file=\"project/controllers/PageController.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Project\\Controllers;\n\tuse \\Core\\Controller;\n\tuse \\Project\\Models\\Page;\n\t\n\tclass PageController extends Controller\n\t{\n\t\tpublic function one($params)\n\t\t{\n\t\t\t$page = (new Page) -&gt; getById($params['id']);\n\t\t\t\n\t\t\t$this-&gt;title = $page['title'];\n\t\t\treturn $this-&gt;render('page/one', [\n\t\t\t\t'text' =&gt; $page['text'],\n\t\t\t\t'h1' =&gt; $this-&gt;title\n\t\t\t]);\n\t\t}\n\t\t\n\t\tpublic function all()\n\t\t{\n\t\t\t$this-&gt;title = 'Список всех страниц';\n\t\t\t\n\t\t\t$pages = (new Page) -&gt; getAll();\n\t\t\treturn $this-&gt;render('page/all', [\n\t\t\t\t'pages' =&gt; $pages,\n\t\t\t\t'h1' =&gt; $this-&gt;title\n\t\t\t]);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Представления</h2>\n<p>\n\tСделаем представление для метода <code class=\"code inline\">one</code>:\n</p>\n<div class=\"block\" data-file=\"/project/views/page/one.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;h1&gt;&lt;?= $h1; ?&gt;&lt;/h1&gt;\n&lt;div id=\"content\"&gt;\n\t&lt;?= $text; ?&gt;\n&lt;/div&gt;</code>\n</div>\n<p>\n\tСделаем представление для метода <code class=\"code inline\">all</code>:\n</p>\n<div class=\"block\" data-file=\"/project/views/page/all.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"html\">&lt;h1&gt;&lt;?= $h1; ?&gt;&lt;/h1&gt;\n&lt;div id=\"content\"&gt;\n\t&lt;table&gt;\n\t\t&lt;tr&gt;\n\t\t\t&lt;th&gt;id&lt;/th&gt;\n\t\t\t&lt;th&gt;title&lt;/th&gt;\n\t\t\t&lt;th&gt;ссылка&lt;/th&gt;\n\t\t&lt;/tr&gt;\n\t\t&lt;?php foreach ($pages as $page): ?&gt;\n\t\t&lt;tr&gt;\n\t\t\t&lt;td&gt;&lt;?= $page['id']; ?&gt;&lt;/td&gt;\n\t\t\t&lt;td&gt;&lt;?= $page['title']; ?&gt;&lt;/td&gt;\n\t\t\t&lt;td&gt;&lt;a href=\"/page/&lt;?= $page['id']; ?&gt;/\"&gt;ссылка на страницу&lt;/td&gt;\n\t\t&lt;/tr&gt;\n\t\t&lt;?php endforeach; ?&gt;\n\t&lt;/table&gt;\n&lt;/div&gt;</code>\n</div>\n\n<h2>Практические задачи</h2>\n<div class=\"task\">\n\t<p>\n\t\tПусть у вас в базе данных есть продукты.\n\t\tКаждый продукт содержит название, цену и\n\t\tколичество, описание. Реализуйте вывод одного\n\t\tпродукта по <code class=\"string inline\">id</code> и всех продуктов подобно\n\t\tтому, как это сделано в теории.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/framework/intro/","content":"\n\t\t\t\t<h1>Разработка своего MVC фреймворка на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВ предыдущих уроках вы тренировались использовать\n\tготовый MVC фреймворк. Как правило, этим\n\tPHP программисты и занимаются - берут один\n\tиз популярных готовых фреймворков, изучают\n\tего, а потом используют. В настоящее время\n\tесть <code class=\"number inline\">3</code> самых популярных фреймворка:\n\t<a href=\"/ru/php/framework/laravel/book/prime/\">Laravel</a>,\n\tYii и Symfony.\n</p>\n<p>\n\tПолученных вами знаний уже достаточно для\n\tизучения настоящих фреймворков. При желании\n\tили при недостатке времени вы можете не проходить\n\tдальнейшие уроки данного учебника по ООП,\n\tа перейти сразу на фреймворки.\n</p>\n<p>\n\tДалее в данном учебнике мы с вами разработаем\n\tсвой MVC фреймворк на PHP. Еще раз подчеркну,\n\tчто данный этап уже не обязателен, но поспособствует\n\tзакреплению ваших знаний ООП на практическом\n\tпримере.\n</p>\n<p>\n\tИтак, приступим к разработке. На самом деле\n\tвы будете разрабатывать не какой-то абстрактный\n\tфреймворк, а просто реализуете функционал\n\tтого учебного фреймворка, который мы использовали\n\tв предыдущих уроках.\n</p>\n<p>\n\tВы уже знаете, какой функционал у вас должен\n\tбыть. Осталось его реализовать. Приступим!\n</p>\n\n<h2>Точка входа</h2>\n<p>\n\tДля начала в корневой папке вашего домена\n\tсделаем файл <code class=\"path inline\">index.php</code> со следующим\n\tсодержанием:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\terror_reporting(E_ALL);\n\tini_set('display_errors', 'on');\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте файл <code class=\"code inline\">index.php</code> и добавьте\n\t\tв него указанные строки.\n\t</p>\n</div>\n\n<h2>Настраиваем htaccess</h2>\n<p>\n\tТеперь сделаем так, чтобы все запросы из\n\tадресной строки адресовались на наш файл\n\t<code class=\"path inline\">index.php</code>. То есть всё, что бы не\n\tвбил пользователь в браузер будет адресоваться\n\tна <code class=\"path inline\">index.php</code>, а код этого файла будет\n\tразбираться с тем, какую именно страницу\n\tпоказать пользователю.\n</p>\n<p>\n\tВот содержимое файла <code class=\"path inline\">htaccess</code>:\n</p>\n<div class=\"block\" data-file=\".htaccess\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"htaccess\">RewriteEngine On\nRewriteBase /\n\nRewriteRule .+ index.php</code>\n</div>\n<p>\n\tВспомним теперь, что адреса из папки <code class=\"path inline\">project/webroot</code>\n\tне должны перенаправляться на индекс, так\n\tкак там мы храним стили, скрипты, картинки\n\tи тому подобные вещи. Учтем это в нашем <code class=\"path inline\">htaccess</code>:\n</p>\n<div class=\"block\" data-file=\".htaccess\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"htaccess\">RewriteEngine On\nRewriteBase /\n\nRewriteCond %{REQUEST_URI} !^/project/webroot/\nRewriteRule .+ index.php</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСоздайте файл <code class=\"path inline\">htaccess</code>. Выполните\n\t\tописанную настройку. Проверьте ее работу:\n\t\tвсе адреса, кроме адресов из папки <code class=\"path inline\">project/webroot</code>\n\t\tдолжны редиректится на <code class=\"path inline\">index</code>.\n\t</p>\n</div>\n\n<h2>Автозагрузка классов</h2>\n<p>\n\tНаш учебный фреймворк использует нестандартные\n\tправила для автозагрузки классов (расскажите,\n\tв чем отличия), поэтому нам придется реализовать\n\tсвою автозагрузку в файле <code class=\"path inline\">index.php</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\terror_reporting(E_ALL);\n\tini_set('display_errors', 'on');\n\t\n\tspl_autoload_register(function($class) {\n\t\t// ваша реализация автозагрузки\n\t});\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте функцию автозагрузки. Проверьте\n\t\tее работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/framework/routes/","content":"\n\t\t\t\t<h1>Работа с роутами в своем MVC фреймворке</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВы уже знаете, что в файле <code class=\"path inline\">/project/config/routes.php</code>\n\tразмещаются роуты, указывающие соответствия\n\tмежду URL и контроллерами с действиями. Роуты\n\tпредставляют собой объекты класса <code class=\"code inline\">Route</code>.\n\tДавайте сделаем этот класс в файле <code class=\"path inline\">/core/Route.php</code>:\n</p>\n<div class=\"block\" data-file=\"/core/Route.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Route\n\t{\n\t\tprivate $path;\n\t\tprivate $controller;\n\t\tprivate $action;\n\t\t\n\t\tpublic function __construct($path, $controller, $action)\n\t\t{\n\t\t\t$this-&gt;path = $path;\n\t\t\t$this-&gt;controller = $controller;\n\t\t\t$this-&gt;action = $action;\n\t\t}\n\t\t\n\t\tpublic function __get($property)\n\t\t{\n\t\t\treturn $this-&gt;$property;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, в этом классе свойства предназначены\n\tтолько для чтения, что достигается использованием\n\tмагии.\n</p>\n<p>\n\tЗагляните теперь в файл с роутами. Вы можете\n\tувидеть, что там находится массив, который\n\tвозвращается через <code class=\"code inline\">return</code>. Это значит,\n\tчто если подключить такой файл через <code class=\"code inline\">require</code>,\n\tто результат подключения можно записать в\n\tпеременную и в этой переменной окажется наш\n\tмассив:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\terror_reporting(E_ALL);\n\tini_set('display_errors', 'on');\n\t\n\tspl_autoload_register(function($class) {\n\t\t// ваша реализация автозагрузки\n\t});\n\t\n\t// Прочитываем массив из файла с роутами в переменную:\n\t$routes = require $_SERVER['DOCUMENT_ROOT'] . '/project/config/routes.php';\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте код моего класса <code class=\"code inline\">Route</code>\n\t\tи разместите его в файле <code class=\"path inline\">/core/Route.php</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tПолучите массив с роутами в файле <code class=\"path inline\">index.php</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/framework/router/","content":"\n\t\t\t\t<h1>Разработка роутера в своем MVC фреймворке</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tТеперь вам нужно разработать <dfn>роутер</dfn>.\n\tОн представляет собой класс, который будет\n\tбрать массив роутов, брать запрошенный URL,\n\tи определять, какой из роутов соответствует\n\tданному урл. После нахождения соответствующего\n\tроута наш класс должен получить части URL,\n\tсоответствующие параметрам роута.\n</p>\n<p>\n\tПусть своим результатом наш роутер возвращает\n\tобъект класса <code class=\"code inline\">Track</code>, содержащего имя\n\tконтроллера, который должен быть вызван на\n\tданный запрос, имя действия и параметры из URL.\n</p>\n<p>\n\tПусть наш класс <code class=\"code inline\">Track</code> имеет свойства\n\t<code class=\"code inline\">controller</code>, <code class=\"code inline\">action</code> и <code class=\"code inline\">params</code>,\n\tдоступные только для чтения:\n</p>\n<div class=\"block\" data-file=\"/core/Track.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Track\n\t{\n\t\tprivate $controller;\n\t\tprivate $action;\n\t\tprivate $params;\n\t\t\n\t\tpublic function __construct($controller, $action, $params)\n\t\t{\n\t\t\t$this-&gt;controller = $controller;\n\t\t\t$this-&gt;action = $action;\n\t\t\t$this-&gt;params = $params;\n\t\t}\n\t\t\n\t\tpublic function __get($property)\n\t\t{\n\t\t\treturn $this-&gt;$property;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Пример</h2>\n<p>\n\tДля примера, пусть в адресной строке вбито\n\t<code class=\"path inline\">/test/1/2/</code>. Пусть у нас есть роут,\n\tсоответствующий этому адресу:\n</p>\n<div class=\"block\" data-file=\"/project/config/routes.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnew Route('/test/:var1/:var2/', 'test', 'index');\n?&gt;</code>\n</div>\n<p>\n\tЭто значит, что имя контроллера будет <code class=\"code inline\">test</code>,\n\tимя действия - <code class=\"code inline\">index</code>, а массив параметров\n\tбудет следующий:.\n</p>\n<div class=\"block\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t ['var1' =&gt; 1, 'var2' =&gt; 2]\n?&gt;</code>\n</div>\n<p>\n\tЦель данного урока - написать класс <code class=\"code inline\">Router</code>,\n\tвозвращающий объект класса <code class=\"code inline\">Track</code>.\n\tОстальное нас пока не касается. Давайте приступим\n\tк написанию этого класса.\n</p>\n\n<h2>Использование роутера</h2>\n<p>\n\tВспомним текущее содержимое файла <code class=\"path inline\">index.php</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\terror_reporting(E_ALL);\n\tini_set('display_errors', 'on');\n\t\n\tspl_autoload_register(function($class) {\n\t\t// ваша реализация автозагрузки\n\t});\n\t\n\t$routes = require $_SERVER['DOCUMENT_ROOT'] . '/project/config/routes.php';\n?&gt;</code>\n</div>\n<p>\n\tПусть теперь далее в <code class=\"path inline\">index.php</code> мы\n\tхотим использовать наш роутер следующим образом:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$router = new Router();\n\t$track  = $router-&gt;getTrack($routes, $_SERVER['REQUEST_URI']);\n?&gt;</code>\n</div>\n<p>\n\tМожно переписать более компактно:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\t$track = ( new Router ) -&gt; getTrack($routes, $_SERVER['REQUEST_URI']);\n?&gt;</code>\n</div>\n\n<h2>Реализация роутера</h2>\n<p>\n\tДавайте теперь напишем заготовку класса <code class=\"code inline\">Router</code>\n\tв соответствии с нашими вызовами:\n</p>\n<div class=\"block\" data-file=\"/core/Router.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Router\n\t{\n\t\tprivate $routes;\n\t\t\n\t\tpublic function getTrack($routes, $uri)\n\t\t{\n\t\t\t// тут будет код\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tВ методе <code class=\"code inline\">getTrack</code> мы должны определить,\n\tкакой из роутов соответствует данному <code class=\"code inline\">$uri</code>.\n\tДля этого нужно перебрать наш массив с роутами\n\tциклом:\n</p>\n<div class=\"block\" data-file=\"/core/Router.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Router\n\t{\n\t\tpublic function getTrack($routes, $uri)\n\t\t{\n\t\t\tforeach ($routes as $route) {\n\t\t\t\t// проверка $uri и $route\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tЕсли какой-то роут соответствует URI, мы\n\tдолжны получить из этого URI значения параметров\n\tроута и вернуть объект класса <code class=\"code inline\">Track</code>:\n</p>\n<div class=\"block\" data-file=\"/core/Router.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Router\n\t{\n\t\tpublic function getTrack($routes, $uri)\n\t\t{\n\t\t\tforeach ($routes as $route) {\n\t\t\t\tif (проверка соответствия роута и URI) {\n\t\t\t\t\t$params = ; // нужно получить параметры из uri\n\t\t\t\t\treturn new Track($route-&gt;controller, $route-&gt;action, $params);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn new Track('error', 'notFound'); // если ни один роут не подойдет\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте код моего класса <code class=\"code inline\">Track</code>\n\t\tи разместите его в файле <code class=\"path inline\">/core/Track.php</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте мою заготовку класса <code class=\"code inline\">Router</code>\n\t\tи разместите его в файле <code class=\"path inline\">/core/Router.php</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте описанный класс <code class=\"code inline\">Router</code>,\n\t\tсвоим результатом возвращающий объект класса\n\t\t<code class=\"code inline\">Track</code>. Если будете испытывать затруднения\n\t\t(что весьма вероятно), подсмотрите в исходный\n\t\tкод фреймворка, по которому вы изучали использование\n\t\tMVC. Там в классе <code class=\"code inline\">Router</code> вы найдете\n\t\tнедостающую часть реализации и мои комментарии\n\t\tк ней.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/framework/controlles/","content":"\n\t\t\t\t<h1>Контроллеры в своем MVC фреймворке на PHP</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tКак вы уже знаете, все контроллеры нашего\n\tфреймворка имеют метод <code class=\"code inline\">render</code>, который\n\tнужно вызывать для отправки данных в представление.\n\tЭтот метод наши, пользовательские контроллеры\n\tнаследуют от родительского класса <code class=\"code inline\">Controller</code>,\n\tрасположенного в ядре. Давайте сделаем этот класс:\n</p>\n<div class=\"block\" data-file=\"/core/Controller.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Controller\n\t{\n\t\tprotected function render($view, $data) {\n\t\t\t\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, метод <code class=\"code inline\">render</code> параметром\n\tпринимает имя представления и данные для\n\tотображения. Пусть этот метод возвращает\n\tобъект специального класса <code class=\"code inline\">Page</code>, в\n\tкотором будет содержаться информация о представлении\n\tданных действия контроллера. В этом классе\n\tбудет содержаться имя представления, данные,\n\tа также тайтл страницы и имя файла с макетом\n\tсайта:\n</p>\n<div class=\"block\" data-file=\"/core/Page.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Page\n\t{\n\t\tprivate $layout;\n\t\tprivate $title;\n\t\tprivate $view;\n\t\tprivate $data;\n\t\t\n\t\tpublic function __construct($layout, $title, $view, $data)\n\t\t{\n\t\t\t$this-&gt;layout = $layout;\n\t\t\t$this-&gt;title  = $title;\n\t\t\t$this-&gt;view   = $view;\n\t\t\t$this-&gt;data   = $data;\n\t\t}\n\t\t\n\t\tpublic function __get($property)\n\t\t{\n\t\t\treturn $this-&gt;$property;\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tТогда код нашего метода <code class=\"code inline\">render</code> будет\n\tвыглядеть вот так:\n</p>\n<div class=\"block\" data-file=\"/core/Controller.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Controller\n\t{\n\t\tprotected $layout = 'default';\n\t\t\n\t\tprotected function render($view, $data) {\n\t\t\treturn new Page($this-&gt;layout, $this-&gt;title, $view, $data);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tПоясню, что здесь происходит. Имя представления\n\tи данные приходят параметрами метода. Однако,\n\tв пользовательском контроллере задается еще\n\tи тайтл страницы - путем записывания свойства\n\t<code class=\"code inline\">title</code>. Значит, в <code class=\"code inline\">$this->title</code>\n\tи будет содержаться тайтл, который мы передадим\n\tконструктору класса <code class=\"code inline\">Page</code>.\n</p>\n<p>\n\tЕсть также нюансы с лейаутом. Как вы знаете,\n\tнаш фреймворк использует лейаут из файла\n\t<code class=\"path inline\">default.php</code>. На самом деле, каждое\n\tдействие может иметь и другой лэйаут. Для\n\tэтого нужно в самом действии в свойство <code class=\"code inline\">layout</code>\n\tзаписать другое имя лэйаута.\n</p>\n<p>\n\tКак это достигается: наш родительский контроллер\n\tимеет свойство <code class=\"code inline\">layout</code>, по умолчанию\n\tимеющее значение <code class=\"string inline\">'default.php'</code>. Это\n\tи будет лэйаутом по умолчанию. Однако, если\n\tдействие пользовательского контроллера переопределит\n\tзначение свойства <code class=\"code inline\">layout</code>, то и лэйаут\n\tбудет другим.\n</p>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте код моего класса <code class=\"code inline\">Controller</code>\n\t\tи разместите его в файле <code class=\"path inline\">/core/Controller.php</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте код моего класса <code class=\"code inline\">Page</code> и\n\t\tразместите его в файле <code class=\"path inline\">/core/Page.php</code>.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/framework/dispatcher/","content":"\n\t\t\t\t<h1>Разработка диспетчера в своем MVC фреймворке</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tВспомним текущее содержимое файла <code class=\"path inline\">index.php</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\terror_reporting(E_ALL);\n\tini_set('display_errors', 'on');\n\t\n\tspl_autoload_register(function($class) {\n\t\t// ваша реализация автозагрузки\n\t});\n\t\n\t$routes = require $_SERVER['DOCUMENT_ROOT'] . '/project/config/routes.php';\n\t\n\t$track = ( new Router ) -&gt; getTrack($routes, $_SERVER['REQUEST_URI']);\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, пока у нас наш роутер возвращает\n\tобъект класса <code class=\"code inline\">Track</code>, содержащий имя\n\tконтроллера, имя действия и параметры из\n\tадресной строки. Кроме того, в предыдущем\n\tуроке мы с вами сделали родителя всех контроллеров.\n</p>\n<p>\n\tТеперь мы можем сделать так, чтобы происходил\n\tвызов метода контроллера, данные которого\n\tсодержатся в нашей переменной <code class=\"code inline\">$track</code>.\n</p>\n<p>\n\tЭтим будет заниматься специальный класс <code class=\"code inline\">Dispatcher</code>.\n\tДиспетчер будет получать объект класса <code class=\"code inline\">Track</code>\n\tи по его данным создавать объект указанного\n\tкласса, вызывать метод этого класса, передавая\n\tв этот метод параметры.\n</p>\n<p>\n\tДавайте добавим вызов диспетчера в файл <code class=\"path inline\">index.php</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\terror_reporting(E_ALL);\n\tini_set('display_errors', 'on');\n\t\n\tspl_autoload_register(function($class) {\n\t\t// ваша реализация автозагрузки\n\t});\n\t\n\t$routes = require $_SERVER['DOCUMENT_ROOT'] . '/project/config/routes.php';\n\t\n\t$track = ( new Router ) -&gt; getTrack($routes, $_SERVER['REQUEST_URI']);\n\t\n\t// Вызов диспетчера:\n\t$page  = ( new Dispatcher ) -&gt; getPage($track);\n?&gt;</code>\n</div>\n<p>\n\tВызов метода <code class=\"code inline\">getPage</code> нашего диспетчера\n\tбудет вызывать метод <code class=\"code inline\">render</code> контроллера\n\tи возвращать то, что вернул вызов этого метода.\n\tКак вы уже знаете из предыдущего урока, метод\n\t<code class=\"code inline\">render</code> контроллера возвращает объект\n\tкласса <code class=\"code inline\">Page</code>.\n</p>\n<p>\n\tВот заготовка нашего класса <code class=\"code inline\">Dispatcher</code>:\n</p>\n<div class=\"block\" data-file=\"/core/Dispatcher.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Dispatcher\n\t{\n\t\tpublic function getPage(Track $track)\n\t\t{\n\t\t\t...код\n\t\t\treturn контроллер -&gt; render(параметры);\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tИспользуя мою заготовку реализуйте описанный\n\t\tкласс <code class=\"code inline\">Dispatcher</code>. Проверьте его работу.\n\t\tПри затруднениях посмотрите исходный код\n\t\tв файлах сделанного мною учебного фреймворка.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/framework/view/","content":"\n\t\t\t\t<h1>Разработка класса View в своем MVC фреймворке</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tСейчас мы с вами сделаем класс <code class=\"code inline\">View</code>,\n\tкоторый будет заниматься представлением данных.\n\tОн будет получать параметром объект класса\n\t<code class=\"code inline\">Page</code>, а своим результатом возвращать\n\tготовый HTML код страницы, который можно\n\tбудет выводить на экран.\n</p>\n<p>\n\tПосмотрим, как мы будем использовать класс\n\t<code class=\"code inline\">View</code> в файле <code class=\"path inline\">index.php</code>:\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\terror_reporting(E_ALL);\n\tini_set('display_errors', 'on');\n\t\n\tspl_autoload_register(function($class) {\n\t\t// ваша реализация автозагрузки\n\t});\n\t\n\t$routes = require $_SERVER['DOCUMENT_ROOT'] . '/project/config/routes.php';\n\t\n\t$track = ( new Router($routes) ) -&gt; getTrack($_SERVER['REQUEST_URI']);\n\t$page  = ( new Dispatcher )      -&gt; getPage($track);\n\t\n\techo (new View) -&gt; render($page); // вот так используем класс View\n?&gt;</code>\n</div>\n<p>\n\tСтруктура кода класса <code class=\"code inline\">View</code> будет иметь\n\tследующий вид:\n</p>\n<div class=\"block\" data-file=\"/core/View.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass View\n\t{\n\t\tpublic function render(Page $page) {\n\t\t\treturn $this-&gt;renderLayout($page, $this-&gt;renderView($page));\n\t\t}\n\t\t\n\t\tprivate function renderLayout(Page $page, $content) {\n\t\t\t\n\t\t}\n\t\t\n\t\tprivate function renderView(Page $page) {\n\t\t\t\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Метод renderView</h2>\n<p>\n\tМетод <code class=\"code inline\">renderView</code> будет получать файл\n\tпредставления и подставлять в него значения\n\tпеременных. Это делается хитрым образом.\n\tКак вы знаете, переменные, которые используются\n\tв файле с представлением, содержатся в свойстве\n\tdata объекта класса <code class=\"code inline\">Page</code>.\n</p>\n<p>\n\tЭти переменные представляют собой ассоциативный\n\tмассив. Нам нужно превратить этот массив\n\tв настоящие переменные, а затем подключить\n\tфайл с представлением через <code class=\"code inline\">include</code>.\n\tВ этом случае указанные доступные в этом\n\tфайле переменные получат свое значение и\n\tна выходе мы получим просто HTML код уже\n\tс подставленными значениями переменных.\n</p>\n<p>\n\tДля того, чтобы преобразовать массив в переменные,\n\tиспользуем специальную функцию <code class=\"code inline\">extract</code>:\n</p>\n<div class=\"block\" data-file=\"/core/View.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tprivate function renderView(Page $page) {\n\t\t$viewPath = $_SERVER['DOCUMENT_ROOT'] . \"/project/views/{$page-&gt;view}.php\";\n\t\t\n\t\tif (file_exists($viewPath)) {\n\t\t\tob_start();\n\t\t\t\t$data = $page-&gt;data;\n\t\t\t\textract($data);    // массив в переменные\n\t\t\t\tinclude $viewPath; // подключаем файл с представлением\n\t\t\treturn ob_get_clean();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Метод renderLayout</h2>\n<p>\n\tДавайте теперь сделаем метод <code class=\"code inline\">renderLayout</code>.\n\tЭтот метод будет брать файл лэйаута и подставлять\n\tв него значение переменных <code class=\"code inline\">$title</code>\n\tи <code class=\"code inline\">$content</code> (она будет передаваться\n\tпараметром метода и будет представлять собой\n\tрезультат работы метода <code class=\"code inline\">renderView</code>):\n</p>\n<div class=\"block\" data-file=\"/core/View.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tprivate function renderLayout(Page $page, $content) {\n\t\t$layoutPath = $_SERVER['DOCUMENT_ROOT'] . \"/project/layouts/{$page-&gt;layout}.php\";\n\t\t\n\t\tif (file_exists($layoutPath)) {\n\t\t\tob_start();\n\t\t\t\t$title = $page-&gt;title;\n\t\t\t\tinclude $layoutPath; // тут будут доступны переменные $title и $content\n\t\t\treturn ob_get_clean();\n\t\t}\n\t}\n?&gt;</code>\n</div>\n\n<h2>Итоговый код</h2>\n<p>\n\tДавайте соберем весь наш код вместе:\n</p>\n<div class=\"block\" data-file=\"/core/View.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass View\n\t{\n\t\tpublic function render(Page $page) {\n\t\t\treturn $this-&gt;renderLayout($page, $this-&gt;renderView($page));\n\t\t}\n\t\t\n\t\tprivate function renderLayout(Page $page, $content) {\n\t\t\t$layoutPath = $_SERVER['DOCUMENT_ROOT'] . \"/project/layouts/{$page-&gt;layout}.php\";\n\t\t\t\n\t\t\tif (file_exists($layoutPath)) {\n\t\t\t\tob_start();\n\t\t\t\t\t$title = $page-&gt;title;\n\t\t\t\t\tinclude $layoutPath;\n\t\t\t\treturn ob_get_clean();\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate function renderView(Page $page) {\n\t\t\t$viewPath = $_SERVER['DOCUMENT_ROOT'] . \"/project/views/{$page-&gt;view}.php\";\n\t\t\t\n\t\t\tif (file_exists($viewPath)) {\n\t\t\t\tob_start();\n\t\t\t\t\t$data = $page-&gt;data;\n\t\t\t\t\textract($data);\n\t\t\t\t\tinclude $viewPath;\n\t\t\t\treturn ob_get_clean();\n\t\t\t}\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРазберите приведенный код класса <code class=\"code inline\">View</code>.\n\t\tЗатем самостоятельно, не подсматривая в мой\n\t\tкод, реализуйте такой же класс. Проверьте\n\t\tего работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/mvc/framework/models/","content":"\n\t\t\t\t<h1>Реализация моделей в своем MVC фреймворке</h1>\n\t\t\t\t<div class=\"content\">\n<p>\n\tПоследнее, что нам осталось реализовать,\n\tэто работа с моделями. Для начала давайте\n\tв файле <code class=\"path inline\">index.php</code> подключим файл с\n\tнастройками подключения к базе данных (разместим\n\tэто подключение вверху файла):\n</p>\n<div class=\"block\" data-file=\"index.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\terror_reporting(E_ALL);\n\tini_set('display_errors', 'on');\n\t\n\trequire_once $_SERVER['DOCUMENT_ROOT'] . '/project/config/connection.php';\n\t\n\t...\n?&gt;</code>\n</div>\n<p>\n\tФайл настроек содержит константы PHP. После\n\tподключения файла эти константы будут доступны\n\tво всех вызываемых нами классах.\n</p>\n\n<h2>Родитель всех моделей</h2>\n<p>\n\tДавайте реализуем родительский класс всех моделей:\n</p>\n<div class=\"block\" data-file=\"/core/Model.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Model\n\t{\n\t\tprivate $link;\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\t$this-&gt;link = mysqli_connect(DB_HOST, DB_USER, DB_PASS, DB_NAME);\n\t\t\tmysqli_query($this-&gt;link, \"SET NAMES 'utf8'\");\n\t\t}\n\t\t\n\t\tprotected function findOne($query)\n\t\t{\n\t\t\t// тут будет какой-то код\n\t\t}\n\t\t\n\t\tprotected function findMany($query)\n\t\t{\n\t\t\t// тут будет какой-то код\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<p>\n\tКак вы видите, в конструкторе класса мы осуществляем\n\tподключение к базе данных. Есть, однако,\n\tпроблема: каждая создаваемая модель (если\n\tвнутри одного действия контроллера будет\n\tнесколько моделей) будет делать свое подключение\n\tк базе данных, а это не оптимально.\n</p>\n<p>\n\tДавайте сделаем так, чтобы подключение к\n\tбазе создавалось только для первой созданной\n\tмодели, а остальные модели использовали уже\n\tсозданное подключение. Для этого свойство\n\t<code class=\"code inline\">link</code> сделаем статическим:\n</p>\n<div class=\"block\" data-file=\"/core/Model.php\">\n\t<code class=\"highlight\" data-module=\"highlight\" data-lang=\"php\">&lt;?php\n\tnamespace Core;\n\t\n\tclass Model\n\t{\n\t\tprivate static $link;\n\t\t\n\t\tpublic function __construct()\n\t\t{\n\t\t\tif (!self::$link) { // если свойство не задано, то подключаемся\n\t\t\t\tself::$link = mysqli_connect(DB_HOST, DB_USER, DB_PASS, DB_NAME);\n\t\t\t\tmysqli_query(self::$link, \"SET NAMES 'utf8'\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tprotected function findOne($query)\n\t\t{\n\t\t\t\n\t\t}\n\t\t\n\t\tprotected function findMany($query)\n\t\t{\n\t\t\t\n\t\t}\n\t}\n?&gt;</code>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tСкопируйте приведенный код класса <code class=\"code inline\">Model</code>\n\t\tи разместите его в файле <code class=\"path inline\">/core/Model.php</code>.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте метод <code class=\"code inline\">findOne</code> в этом классе.\n\t\tПроверьте его работу.\n\t</p>\n</div>\n<div class=\"task\">\n\t<p>\n\t\tРеализуйте метод <code class=\"code inline\">findMany</code> в этом классе.\n\t\tПроверьте его работу.\n\t</p>\n</div>\n</div>\t\t\t"},{"url":"/ru/php/book/oop/namespace/","content":""}]